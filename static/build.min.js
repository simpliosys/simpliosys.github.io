(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;
                if (!u && a)return a(o, !0);
                if (i)return i(o, !0);
                throw new Error("Cannot find module '" + o + "'")
            }
            var f = n[o] = {exports: {}};
            t[o][0].call(f.exports, function (e) {
                var n = t[o][1][e];
                return s(n ? n : e)
            }, f, f.exports, e, t, n, r)
        }
        return n[o].exports
    }

    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++)s(r[o]);
    return s
})({1: [function (require, module, exports) {
    var debug = require("debug")("notifications:boot");
    var repliesCache = require("comment-replies-cache");
    var preloadedAssets = window.preloadedAssets = require("./preload");
    require("html5-history-api");
    preloadedAssets.preloadImage("https://www.gravatar.com/avatar/ad516503a11cd5ca435acc9bb6523536?s=128");
    var path = require("path");
    var page = require("page");
    var qs = require("qs");
    var i18n = require("i18n");
    var bootstrap = require("bootstrap");
    var config = require("config");
    var client = require("client-switch");
    var React = window.React = require("react");
    var Layout = React.createFactory(require("templates"));
    var layout = false;
    var notifications = require("notifications");
    var note = require("note");
    var notfound = require("notfound");
    var receiveMessage = function (event) {
        var data = null;
        if (!window) {
            return
        }
        if (event.source !== window.parent) {
            return
        }
        if (typeof event.data === "string") {
            try {
                data = JSON.parse(event.data)
            } catch (e) {
                debug("couldnt parse data: %s", event.data)
            }
        } else {
            data = event.data
        }
        if (!data || data.type !== "notesIframeMessage") {
            return
        }
        client.handleIncomingMessage(data)
    };
    var sendMessage = function (message) {
        message["type"] = "notesIframeMessage";
        if (window && window.parent) {
            debug("sending message: %s", JSON.stringify(message));
            window.parent.postMessage(JSON.stringify(message), "*")
        } else {
            debug("send ignored")
        }
    };
    client.sendMessage = sendMessage;
    client.receiveMessage = receiveMessage;
    window.addEventListener("message", client.receiveMessage);
    client.sendMessage({action: "iFrameReady"});
    var content = document.getElementById("content");
    var router = page.show.bind(page);
    var routeWithState = function (route, state) {
        if (state && layout) {
            layout.setState(state)
        }
        router(path.resolve("/", config("prefix"), path.basename(route)))
    };
    i18n.initialize(bootstrap);
    repliesCache.cleanup();
    var render = function (data) {
        data.router = routeWithState;
        data.client = client;
        if (!layout) {
            layout = React.render(Layout(data), content)
        } else {
            layout.setProps(data)
        }
    };
    page("*", function (ctx, next) {
        debug("processing route: %o", ctx);
        var query = qs.parse(document.location.search.slice(1));
        ctx.data = {notes: [], current: false, title: "", error: false, path: ctx.path};
        ctx.render = function () {
            ctx.data.notes = client.notes;
            render(ctx.data, [])
        };
        client.removeAllListeners("ready");
        client.on("ready", ctx.render);
        client.router = routeWithState;
        client.start();
        if (query.locale) {
            i18n.updateLocale(query.locale, function (err, locale) {
                next()
            })
        } else {
            next()
        }
    });
    page(path.resolve("/", config("prefix")), notifications());
    page(path.resolve("/", config("prefix"), "rtl.html"), notifications());
    page(path.resolve("/", config("prefix"), ":note"), note());
    page("*", notfound());
    page()
}, {"./preload": 2, bootstrap: 271, "client-switch": 273, "comment-replies-cache": 274, config: 275, debug: 48, "html5-history-api": 51, i18n: 6, note: 278, notfound: 279, notifications: 280, page: 55, path: 45, qs: 59, react: 213, templates: 284}], 2: [function (require, module, exports) {
    function preloadImage(src) {
        var preload = new Image;
        preload.src = src
    }

    module.exports.preloadImage = preloadImage
}, {}], 3: [function (require, module, exports) {
    var restClient = require("rest-client");
    module.exports = new restClient
}, {"rest-client": 281}], 4: [function (require, module, exports) {
    var debug = require("debug")("notifications:client-switch:simperium");
    var config = require("config");
    var store = require("store");
    var wp = require("wp");
    var simperiumClient = require("simperium-client");
    var settings = config("simperium");
    var client = new simperiumClient(settings);
    if ("rest-proxy" === config("api_transport")) {
        debug("token:rest-proxy");
        var simperium_token = store.get("simperium_token");
        if (simperium_token) {
            client.setToken(simperium_token)
        } else {
            wp.undocumented().simperiumToken().add(settings.api_key, function (err, data) {
                if (err) {
                    throw err
                }
                simperium_token = data.token;
                store.set("simperium_token", simperium_token);
                client.setToken(simperium_token)
            })
        }
    } else {
        debug("token:WPCC");
        var token = require("token");
        client.setToken("WPCC/" + settings.api_key + "/" + token)
    }
    module.exports = client
}, {config: 275, debug: 48, "simperium-client": 282, store: 237, token: 33, wp: 34}], 5: [function (require, module, exports) {
    var testClient = require("test-client");
    module.exports = new testClient
}, {"test-client": 285}], 6: [function (require, module, exports) {
    var debug = require("debug")("notifications:i18n"), Jed = require("jed"), request = require("superagent"), moment = require("moment");
    var config = require("config"), numberFormatPHPJS = require("./number-format");
    var i18n = {jed: null, numberFormatSettings: {}};

    function I18n() {
        if (!(this instanceof I18n)) {
            return new I18n
        }
    }

    var singleton = I18n();
    I18n.prototype.initialize = function (bootstrap) {
        if (bootstrap) {
            this.localeSlug = bootstrap.locale;
            debug("Initialize i18n with bootstrapped localeSlug: " + this.localeSlug);
            this.buildJed(bootstrap.i18n);
            this.buildMomentAndNumber(bootstrap.i18n)
        } else {
            this.localeSlug = config("i18n_default_locale_slug");
            debug("Initialize i18n with localeSlug: " + this.localeSlug);
            this.getLanguage(this.localeSlug)
        }
    };
    I18n.prototype.getLanguage = function (localeSlug, callback) {
        if (typeof callback !== "function") {
            callback = function () {
            }
        }
        var localeJson = "//widgets.wp.com/languages/notifications/" + encodeURIComponent(localeSlug) + ".json";
        if (config("i18n_default_locale_slug") === localeSlug) {
            this.buildJed({"": {}});
            callback(null, localeSlug);
            return
        }
        if (!i18n.jed) {
            this.buildJed({"": {}})
        }
        request.get(localeJson).end(function (error, response) {
            if (error || response && response.error) {
                debug("Encountered an error loading file");
                callback("Encountered an error loading file");
                return
            }
            debug("Received new locale file", response.body);
            this.localeSlug = localeSlug;
            this.buildJed(response.body);
            this.buildMomentAndNumber(response.body);
            callback(null, localeSlug)
        }.bind(this))
    };
    I18n.prototype.updateLocale = function (localeSlug, callback) {
        if (typeof callback !== "function") {
            callback = function () {
            }
        }
        if (this.localeSlug === localeSlug) {
            debug("localeSlug already set to `" + localeSlug + "`, nothing to load.");
            callback(null, localeSlug);
            return
        }
        this.getLanguage(localeSlug, callback)
    };
    I18n.prototype.buildJed = function (data) {
        i18n.jed = new Jed({locale_data: {messages: data}})
    };
    I18n.prototype.buildMomentAndNumber = function (data) {
        if ("undefined" === typeof data[""] || "undefined" === typeof data[""].momentjs_locale) {
            return
        }
        var momentLocale = data[""].momentjs_locale;
        moment.locale(this.localeSlug, momentLocale);
        i18n.numberFormatSettings = momentLocale.numberFormat
    };
    var getJedArgs = function (jedMethod, props) {
        var argsByMethod = {gettext: [props.original], ngettext: [props.original.single, props.original.plural, props.original.count], npgettext: [props.context, props.original.single, props.original.plural, props.original.count], pgettext: [props.context, props.original]};
        return argsByMethod[jedMethod] || []
    };

    function numberFormat(number) {
        var options = arguments[1] || {}, decimals = "number" === typeof options ? options : options.decimals || 0, decPoint = options.decPoint || i18n.numberFormatSettings.decimal_point || ".", thousandsSep = options.thousandsSep || i18n.numberFormatSettings.thousands_sep || ",";
        return numberFormatPHPJS(number, decimals, decPoint, thousandsSep)
    }

    var translate = function (options) {
        var jedMethod = "gettext", jedArgs, translation;
        if ("string" === typeof options) {
            return i18n.jed.gettext(options)
        }
        if ("undefined" === typeof options.original) {
            debug("Translate called without a `options.original` value.");
            return
        }
        if (options.context) {
            jedMethod = "p" + jedMethod
        }
        if ("string" === typeof options.original.single && "string" === typeof options.original.plural) {
            jedMethod = "n" + jedMethod
        }
        jedArgs = getJedArgs(jedMethod, options);
        debug("Calling i18n." + jedMethod + "() with these params:", jedArgs);
        translation = i18n.jed[jedMethod].apply(i18n.jed, jedArgs);
        if ("undefined" === typeof options.args) {
            return translation
        }
        if (Array.isArray(options.args)) {
            options.args.unshift(translation);
            return Jed.sprintf.apply(Jed, options.args)
        }
        return Jed.sprintf(translation, options.args)
    };
    module.exports = {initialize: singleton.initialize.bind(singleton), updateLocale: singleton.updateLocale.bind(singleton), translate: translate, moment: moment, numberFormat: numberFormat}
}, {"./number-format": 7, config: 275, debug: 48, jed: 53, moment: 54, superagent: 238}], 7: [function (require, module, exports) {
    function number_format(number, decimals, dec_point, thousands_sep) {
        number = (number + "").replace(/[^0-9+\-Ee.]/g, "");
        var n = !isFinite(+number) ? 0 : +number, prec = !isFinite(+decimals) ? 0 : Math.abs(decimals), sep = typeof thousands_sep === "undefined" ? "," : thousands_sep, dec = typeof dec_point === "undefined" ? "." : dec_point, s = "", toFixedFix = function (n, prec) {
            var k = Math.pow(10, prec);
            return"" + (Math.round(n * k) / k).toFixed(prec)
        };
        s = (prec ? toFixedFix(n, prec) : "" + Math.round(n)).split(".");
        if (s[0].length > 3) {
            s[0] = s[0].replace(/\B(?=(?:\d{3})+(?!\d))/g, sep)
        }
        if ((s[1] || "").length < prec) {
            s[1] = s[1] || "";
            s[1] += new Array(prec - s[1].length + 1).join("0")
        }
        return s.join(dec)
    }

    module.exports = number_format
}, {}], 8: [function (require, module, exports) {
    var getRegExpFor = function (type, textToHighlight) {
        var expressions = {};
        expressions["username"] = "(^" + textToHighlight + ")(\\w*)\\s*";
        expressions["fullname"] = "(^.*?)(\\b" + textToHighlight + ")(.*)";
        return new RegExp(expressions[type], "ig")
    };
    var highlight = function (content, textToHighlight, type) {
        var matcher = getRegExpFor(type, textToHighlight);
        var matches = matcher.exec(content);
        if (matches) {
            var highlight = [];
            var highlighted = false;
            for (var i = 1, length = matches.length; i < length; i++) {
                var item = matches[i];
                if (textToHighlight.toLowerCase() === item.toLowerCase() && !highlighted) {
                    item = React.createElement("strong", null, matches[i]);
                    highlighted = true
                }
                highlight.push(item)
            }
            return highlight
        }
        return[content]
    };
    module.exports = React.createClass({displayName: "exports", render: function () {
        var username = highlight(this.props.username, this.props.suggestionsQuery, "username");
        username.unshift("@");
        var fullName = highlight(this.props.fullName, this.props.suggestionsQuery, "fullname");
        return React.createElement("li", {className: this.props.selected ? "cur" : "", onClick: this.props.onClick, onMouseEnter: this.props.onMouseEnter}, React.createElement("img", {src: this.props.avatarUrl}), React.createElement("span", {className: "username"}, username), React.createElement("small", null, fullName))
    }})
}, {}], 9: [function (require, module, exports) {
    var functions = require("./functions");
    var i18n = require("i18n");
    var ApproveButton = require("./button-approve");
    var EditButton = require("./button-edit");
    var LikeButton = require("./button-like");
    var SpamButton = require("./button-spam");
    var TrashButton = require("./button-trash");
    var ReplyInput = require("./comment-reply-input");
    module.exports = React.createClass({displayName: "exports", render: function () {
        var note = this.props.note;
        var actions = this.props.block.actions;
        var replyField = "";
        var actionButtons = [];
        if ("like-post"in actions)actionButtons.push(React.createElement(LikeButton, {key: "like-post-" + note.id, note: note, global: this.props.global}));
        if ("like-comment"in actions)actionButtons.push(React.createElement(LikeButton, {key: "like-comment-" + note.id, note: note, global: this.props.global}));
        if ("approve-comment"in actions)actionButtons.push(React.createElement(ApproveButton, {key: "approve-comment-" + note.id, note: note, global: this.props.global}));
        if ("trash-comment"in actions)actionButtons.push(React.createElement(TrashButton, {key: "trash-comment-" + note.id, note: note, global: this.props.global}));
        if ("spam-comment"in actions)actionButtons.push(React.createElement(SpamButton, {key: "spam-comment-" + note.id, note: note, global: this.props.global}));
        if ("trash-comment"in actions)actionButtons.push(React.createElement(EditButton, {key: "edit-comment-" + note.id, note: note, global: this.props.global}));
        if ("replyto-comment"in actions && actions["replyto-comment"]) {
            var username;
            if ("user" == note.subject[0].ranges[0].type) {
                var userRange = note.subject[0].ranges[0].indices;
                username = note.subject[0].text.substring(userRange[0], userRange[1])
            } else if ("user" == note.body[0].type) {
                username = note.body[0].text
            } else {
                username = i18n.translate({original: "original author", context: "noun"})
            }
            var initialReplyValue = functions.formatString(i18n.translate({original: "Reply to {0}..."}), username);
            replyField = React.createElement(ReplyInput, {key: "reply-to-comment-" + note.id, note: note, defaultValue: initialReplyValue, global: this.props.global})
        }
        return React.createElement("div", {className: "note-actions"}, actionButtons, replyField)
    }})
}, {"./button-approve": 14, "./button-edit": 16, "./button-like": 17, "./button-spam": 18, "./button-trash": 19, "./comment-reply-input": 20, "./functions": 23, i18n: 6}], 10: [function (require, module, exports) {
    var functions = require("./functions");
    var indices = require("indices-to-html");
    module.exports = React.createClass({displayName: "exports", render: function () {
        var commentText = functions.p(indices.html(this.props.block));
        var className = "comment";
        if (this.props.meta.ids.comment != this.props.block.meta.ids.comment) {
            className += " comment-other"
        } else {
            className += " comment-self"
        }
        return React.createElement("div", {className: className}, commentText)
    }})
}, {"./functions": 23, "indices-to-html": 277}], 11: [function (require, module, exports) {
    var functions = require("./functions");
    var indices = require("indices-to-html");
    module.exports = React.createClass({displayName: "exports", render: function () {
        var postText = functions.p(indices.html(this.props.block));
        return React.createElement("div", {className: "post"}, postText)
    }})
}, {"./functions": 23, "indices-to-html": 277}], 12: [function (require, module, exports) {
    var functions = require("./functions");
    var i18n = require("i18n");
    var indices = require("indices-to-html");
    var FollowLink = require("./follow-link");

    function getHostName(url) {
        var parser = document.createElement("a");
        parser.href = url;
        return parser.hostname
    }

    module.exports = React.createClass({displayName: "exports", render: function () {
        var grav = this.props.block.media[0], home_url = "", home_title = "", timeIndicator, homeTemplate, followLink, noteBody, noteActions;
        if (this.props.block.meta) {
            if (this.props.block.meta.links) {
                home_url = this.props.block.meta.links.home || ""
            }
            if (this.props.block.meta.titles) {
                home_title = this.props.block.meta.titles.home || ""
            }
        }
        if (!home_title && home_url) {
            home_title = getHostName(home_url)
        }
        if ("comment" === this.props.note.type) {
            noteBody = this.props.note.body;
            noteActions = noteBody[noteBody.length - 1].actions;
            if ("approve-comment"in noteActions && false === noteActions["approve-comment"] && home_url) {
                home_title = getHostName(home_url)
            }
            timeIndicator = React.createElement("span", {className: "timeIndicator"}, React.createElement("a", {href: this.props.note.url, target: "_blank"}, i18n.moment(this.props.note.timestamp).fromNow()), React.createElement("span", {className: "bullet"}))
        } else {
            timeIndicator = ""
        }
        if (home_title) {
            var homeClassName = timeIndicator != "" ? "meta bulleted" : "meta";
            homeTemplate = React.createElement("div", {className: homeClassName}, React.createElement("span", {className: "ago"}, timeIndicator), React.createElement("a", {className: "site", href: home_url, target: "_blank"}, home_title))
        } else {
            homeTemplate = React.createElement("div", {className: "meta"}, React.createElement("span", {className: "ago"}, timeIndicator))
        }
        if (this.props.block.actions && "undefined" != this.props.block.meta.ids.site) {
            followLink = React.createElement(FollowLink, {site: this.props.block.meta.ids.site, isFollowing: this.props.block.actions.follow, noteType: this.props.note.type})
        }
        if (home_url) {
            return React.createElement("div", {className: "user"}, React.createElement("a", {className: "site", href: home_url, target: "_blank"}, React.createElement("img", {src: grav.url, height: grav.height, width: grav.width})), React.createElement("span", {className: "username"}, React.createElement("a", {className: "home", href: home_url, target: "_blank"}, this.props.block.text)), homeTemplate, followLink)
        } else {
            return React.createElement("div", {className: "user"}, React.createElement("img", {src: grav.url, height: grav.height, width: grav.width}), React.createElement("span", {className: "username"}, this.props.block.text), homeTemplate, followLink)
        }
    }})
}, {"./follow-link": 22, "./functions": 23, i18n: 6, "indices-to-html": 277}], 13: [function (require, module, exports) {
    var User = require("./block-user");
    var Comment = require("./block-comment");
    var Post = require("./block-post");
    var NotePreface = require("./preface");
    var NoteActions = require("./actions");
    var indices = require("indices-to-html");
    var functions = require("./functions");
    var wpcom = require("wp");
    module.exports = React.createClass({displayName: "exports", componentDidMount: function () {
        wpcom.bumpStat("notes-click-type", this.props.note.type)
    }, render: function () {
        var blocks = functions.zipWithSignature(this.props.note.body);
        var actions = "";
        var preface = "";
        var firstNonTextIndex;
        var i;
        for (i = 0; i < blocks.length; i++) {
            if ("text" !== blocks[i].signature.type) {
                firstNonTextIndex = i;
                break
            }
        }
        if (firstNonTextIndex) {
            preface = React.createElement(NotePreface, {blocks: this.props.note.body.slice(0, i)});
            blocks = blocks.slice(i)
        }
        var body = [];
        for (i = 0; i < blocks.length; i++) {
            var block = blocks[i];
            var blockKey = "block-" + this.props.note.id + "-" + i;
            if (block.block.actions && "user" !== block.signature.type) {
                actions = React.createElement(NoteActions, {note: this.props.note, block: block.block, global: this.props.global})
            }
            switch (block.signature.type) {
                case"user":
                    body.push(React.createElement(User, {key: blockKey, block: block.block, noteType: this.props.note.type, note: this.props.note, timestamp: this.props.note.timestamp, url: this.props.note.url}));
                    break;
                case"comment":
                    body.push(React.createElement(Comment, {key: blockKey, block: block.block, meta: this.props.note.meta}));
                    break;
                case"post":
                    body.push(React.createElement(Post, {key: blockKey, block: block.block, meta: this.props.note.meta}));
                    break;
                default:
                    body.push(functions.p(indices.html(block.block)));
                    break
            }
        }
        return React.createElement("div", {className: "body"}, preface, React.createElement("div", {className: "body-content"}, body), actions)
    }})
}, {"./actions": 9, "./block-comment": 10, "./block-post": 11, "./block-user": 12, "./functions": 23, "./preface": 27, "indices-to-html": 277, wp: 34}], 14: [function (require, module, exports) {
    var wpcom = require("wp");
    var i18n = require("i18n");
    module.exports = React.createClass({displayName: "exports", componentDidMount: function () {
        window.addEventListener("keydown", this.handleKeyDown, false)
    }, componentWillUnmount: function () {
        window.removeEventListener("keydown", this.handleKeyDown)
    }, handleKeyDown: function (event) {
        if (!this.props.global.keyboardShortcutsAreEnabled) {
            return
        }
        if (this.props.global.input.modifierKeyIsActive(event)) {
            return
        }
        if (65 == event.keyCode) {
            this.toggleApproveStatus()
        }
    }, noteIsApproved: function (note) {
        return this.props.note.body[this.props.note.body.length - 1].actions["approve-comment"]
    }, toggleApproveStatus: function (event) {
        var isApproved = this.noteIsApproved(this.props.note);
        var comment = wpcom.site(this.props.note.meta.ids.site).comment(this.props.note.meta.ids.comment);
        var component = this;
        component.props.global.client.approveNoteLocal(component.props.note.id);
        var updateState = function (error, data) {
            if (error)throw error;
            component.props.global.client.getNote(component.props.note.id)
        };
        if (isApproved) {
            wpcom.bumpStat("notes-click-action", "unapprove-comment")
        } else {
            wpcom.bumpStat("notes-click-action", "approve-comment")
        }
        comment.update({status: !isApproved ? "approved" : "unapproved"}, updateState)
    }, render: function () {
        var link_class;
        var link_text;
        if (this.noteIsApproved(this.props.note)) {
            link_text = i18n.translate({original: "Approved", context: "verb: past-tense"});
            link_class = "active-action"
        } else {
            link_text = i18n.translate({original: "Approve", context: "verb: imperative"});
            link_class = "inactive-action"
        }
        var linkTitle;
        if (this.noteIsApproved(this.props.note)) {
            linkTitle = i18n.translate({original: "Unapprove comment", context: "verb: imperative"})
        } else {
            linkTitle = i18n.translate({original: "Approve comment", context: "verb: imperative"})
        }
        return React.createElement("div", {className: "action-link"}, React.createElement("a", {href: "#", className: link_class, title: linkTitle, onClick: this.toggleApproveStatus}, React.createElement("span", {className: "action-link noticon noticon-checkmark"}), " ", React.createElement("p", null, link_text)))
    }})
}, {i18n: 6, wp: 34}], 15: [function (require, module, exports) {
    var i18n = require("i18n");
    module.exports = React.createClass({displayName: "exports", routeBack: function (event) {
        event.preventDefault();
        this.props.global.input.lastInputWasKeyboard = false;
        this.props.client.router("/")
    }, render: function () {
        var back_text = i18n.translate({original: "Back", context: "go back (like the back button in a browser)"});
        if (this.props.enabled) {
            return React.createElement("a", {className: "back", onClick: this.routeBack, href: "#"}, back_text)
        } else {
            return React.createElement("a", {className: "back disabled", disabled: "disabled", href: "#"}, back_text)
        }
    }})
}, {i18n: 6}], 16: [function (require, module, exports) {
    var i18n = require("i18n");
    module.exports = React.createClass({displayName: "exports", render: function () {
        var edit_text = i18n.translate({original: "Edit"});
        var editLink = document.createElement("a");
        editLink.href = this.props.note.url;
        editLink = editLink.protocol + "//" + encodeURIComponent(editLink.hostname) + "/wp-admin/comment.php?action=editcomment&c=" + encodeURIComponent(this.props.note.meta.ids.comment);
        var linkTitle = i18n.translate({original: "Edit comment", context: "verb: imperative"});
        return React.createElement("div", {className: "action-link"}, React.createElement("a", {href: editLink, target: "_blank", title: linkTitle, className: "inactive-action"}, React.createElement("span", {className: "action-link noticon noticon-edit"}), " ", React.createElement("p", null, edit_text)))
    }})
}, {i18n: 6}], 17: [function (require, module, exports) {
    var wpcom = require("wp");
    var i18n = require("i18n");
    module.exports = React.createClass({displayName: "exports", propTypes: {hasLiked: React.PropTypes.bool}, getInitialState: function () {
        return{hasLiked: this.props.hasLiked}
    }, componentDidMount: function () {
        window.addEventListener("keydown", this.handleKeyDown, false)
    }, componentWillUnmount: function () {
        window.removeEventListener("keydown", this.handleKeyDown)
    }, handleKeyDown: function (event) {
        if (!this.props.global.keyboardShortcutsAreEnabled) {
            return
        }
        if (this.props.global.input.modifierKeyIsActive(event)) {
            return
        }
        if (76 == event.keyCode) {
            this.toggleLikeStatus()
        }
    }, isComment: function () {
        return"undefined" != typeof this.props.note.meta.ids.comment
    }, commentHasBeenLiked: function () {
        return this.props.note.body[this.props.note.body.length - 1].actions["like-comment"]
    }, postHasBeenLiked: function () {
        return this.props.note.body[this.props.note.body.length - 1].actions["like-post"]
    }, hasBeenLiked: function () {
        return this.isComment() ? this.commentHasBeenLiked() : this.postHasBeenLiked()
    }, toggleLikeStatus: function (event) {
        var hasLiked = this.hasBeenLiked();
        var component = this;
        var client = this.props.global.client;
        var liker;
        for (var i = 0; i < client.notes.length; i++) {
            if (this.props.note.id == client.notes[i].id) {
                var actionName = this.isComment() ? "like-comment" : "like-post";
                client.notes[i].body[client.notes[i].body.length - 1].actions[actionName] = !hasLiked;
                client.is_ready = true;
                client.emit("ready");
                break
            }
        }
        var updateState = function (error, data) {
            if (error)throw error;
            component.props.global.client.getNote(component.props.note.id)
        };
        if (this.isComment()) {
            liker = wpcom.site(this.props.note.meta.ids.site).comment(this.props.note.meta.ids.comment).like()
        } else {
            liker = wpcom.site(this.props.note.meta.ids.site).post(this.props.note.meta.ids.post).like()
        }
        if (hasLiked) {
            liker.del(updateState);
            wpcom.bumpStat("notes-click-action", "unlike-" + this.isComment() ? "comment" : "post")
        } else {
            liker.add(updateState);
            wpcom.bumpStat("notes-click-action", "like-" + this.isComment() ? "comment" : "post")
        }
    }, render: function () {
        var link_class;
        var link_text;
        if (this.hasBeenLiked()) {
            link_text = i18n.translate({original: "Liked", context: "verb: past-tense"});
            link_class = "active-action"
        } else {
            link_text = i18n.translate({original: "Like", context: "verb: imperative"});
            link_class = "inactive-action"
        }
        var linkTitle;
        if (this.isComment()) {
            if (this.hasBeenLiked()) {
                linkTitle = i18n.translate({original: "Remove like from comment", context: "verb: imperative"})
            } else {
                linkTitle = i18n.translate({original: "Like comment", context: "verb: imperative"})
            }
        } else {
            if (this.hasBeenLiked()) {
                linkTitle = i18n.translate({original: "Remove like from post", context: "verb: imperative"})
            } else {
                linkTitle = i18n.translate({original: "Like post", context: "verb: imperative"})
            }
        }
        return React.createElement("div", {className: "action-link"}, React.createElement("a", {href: "#", className: link_class, title: linkTitle, onClick: this.toggleLikeStatus}, React.createElement("span", {className: "action-link noticon noticon-star"}), " ", React.createElement("p", null, link_text)))
    }})
}, {i18n: 6, wp: 34}], 18: [function (require, module, exports) {
    var wpcom = require("wp");
    var i18n = require("i18n");
    module.exports = React.createClass({displayName: "exports", componentDidMount: function () {
        window.addEventListener("keydown", this.handleKeyDown, false)
    }, componentWillUnmount: function () {
        window.removeEventListener("keydown", this.handleKeyDown)
    }, handleKeyDown: function (event) {
        if (!this.props.global.keyboardShortcutsAreEnabled) {
            return
        }
        if (this.props.global.input.modifierKeyIsActive(event)) {
            return
        }
        if (83 == event.keyCode) {
            this.spamComment()
        }
    }, spamComment: function (event) {
        this.props.global.client.router("/");
        this.props.global.updateUndoBar("spam", this.props.note);
        wpcom.bumpStat("notes-click-action", "spam-comment")
    }, render: function () {
        var link_text = i18n.translate({original: "Spam", context: "verb: Mark as Spam"});
        var linkTitle = i18n.translate({original: "Mark comment as spam", context: "verb: imperative"});
        return React.createElement("div", {className: "action-link"}, React.createElement("a", {href: "#", className: "inactive-action", title: linkTitle, onClick: this.spamComment}, React.createElement("span", {className: "action-link noticon noticon-spam"}), " ", React.createElement("p", null, link_text)))
    }})
}, {i18n: 6, wp: 34}], 19: [function (require, module, exports) {
    var wpcom = require("wp");
    var i18n = require("i18n");
    module.exports = React.createClass({displayName: "exports", componentDidMount: function () {
        window.addEventListener("keydown", this.handleKeyDown, false)
    }, componentWillUnmount: function () {
        window.removeEventListener("keydown", this.handleKeyDown)
    }, handleKeyDown: function (event) {
        if (!this.props.global.keyboardShortcutsAreEnabled) {
            return
        }
        if (this.props.global.input.modifierKeyIsActive(event)) {
            return
        }
        if (84 == event.keyCode) {
            this.trashComment()
        }
    }, trashComment: function (event) {
        this.props.global.client.router("/");
        this.props.global.updateUndoBar("trash", this.props.note);
        wpcom.bumpStat("notes-click-action", "trash-comment")
    }, render: function () {
        var link_text = i18n.translate({original: "Trash", context: "verb: imperative"});
        var linkTitle = i18n.translate({original: "Trash comment", context: "verb: imperative"});
        return React.createElement("div", {className: "action-link"}, React.createElement("a", {href: "#", className: "inactive-action", title: linkTitle, onClick: this.trashComment}, React.createElement("span", {className: "action-link noticon noticon-trash"}), " ", React.createElement("p", null, link_text)))
    }})
}, {i18n: 6, wp: 34}], 20: [function (require, module, exports) {
    var functions = require("./functions");
    var i18n = require("i18n");
    var wpcom = require("wp");
    var repliesCache = require("comment-replies-cache");
    var Suggestions = require("suggestions");
    var browser = require("browser");
    var debug = require("debug")("notifications:reply");
    module.exports = React.createClass({displayName: "exports", mixins: [repliesCache.LocalStorageMixin, Suggestions], getInitialState: function () {
        var getSavedReply = function () {
            var savedReply = this.localStorage.getItem(this.savedReplyKey);
            return savedReply ? savedReply[0] : ""
        };
        this.savedReplyKey = "reply_" + this.props.note.id;
        return{value: getSavedReply.apply(this), hasClicked: false, isSubmitting: false, rowCount: 1, retryCount: 0}
    }, componentDidMount: function () {
        window.addEventListener("keydown", this.handleKeyDown, false);
        window.addEventListener("keydown", this.handleCtrlEnter, false)
    }, componentWillUnmount: function () {
        window.removeEventListener("keydown", this.handleKeyDown);
        window.removeEventListener("keydown", this.handleCtrlEnter);
        this.props.global.toggleKeyboardShortcuts(true)
    }, handleKeyDown: function (event) {
        if (!this.props.global.keyboardShortcutsAreEnabled) {
            return
        }
        if (this.props.global.input.modifierKeyIsActive(event)) {
            return
        }
        var stopEvent = function () {
            event.stopPropagation();
            event.preventDefault()
        };
        if (82 == event.keyCode) {
            this.refs.replyTextArea.getDOMNode().focus();
            stopEvent()
        }
    }, handleCtrlEnter: function (event) {
        var stopEvent = function () {
            event.stopPropagation();
            event.preventDefault()
        };
        if (this.state.isSubmitting) {
            return
        }
        if ((event.ctrlKey || event.metaKey) && (10 == event.keyCode || 13 == event.keyCode)) {
            stopEvent();
            this.handleSubmit()
        }
    }, handleChange: function (event) {
        var textarea = this.refs.replyTextArea.getDOMNode();
        this.props.global.toggleKeyboardShortcuts(false);
        this.setState({value: event.target.value, rowCount: Math.min(4, Math.ceil(textarea.scrollHeight * this.state.rowCount / textarea.clientHeight))});
        if (this.savedReplyKey) {
            this.localStorage.setItem(this.savedReplyKey, [event.target.value, Date.now()])
        }
    }, handleClick: function (event) {
        this.props.global.toggleKeyboardShortcuts(false);
        if (!this.state.hasClicked) {
            this.setState({hasClicked: true})
        }
    }, handleFocus: function (event) {
        this.props.global.toggleKeyboardShortcuts(false)
    }, handleBlur: function (event) {
        this.props.global.toggleKeyboardShortcuts(true);
        if ("" == this.state.value.replace(/^\s+|\s+$/g, "")) {
            this.setState({value: "", hasClicked: false, rowCount: 1})
        }
        if (window.parent && browser.hasTouch()) {
            window.parent.scrollTo(0, 0)
        }
    }, handleSubmit: function (event) {
        var wpObject, submitComment, component = this, statusMessage, successMessage = i18n.translate({original: "Reply posted!"}), linkMessage = i18n.translate({original: "View your comment."});
        if (event) {
            event.preventDefault()
        }
        if ("" == this.state.value)return;
        this.props.global.toggleNavigation(false);
        this.setState({isSubmitting: true});
        if (this.state.retryCount == 0) {
            wpcom.bumpStat("notes-click-action", "replyto-comment")
        }
        if (this.props.note.meta.ids.comment) {
            wpObject = wpcom.site(this.props.note.meta.ids.site).comment(this.props.note.meta.ids.comment);
            submitComment = wpObject.reply
        } else {
            wpObject = wpcom.site(this.props.note.meta.ids.site).post(this.props.note.meta.ids.post).comment();
            submitComment = wpObject.add
        }
        submitComment.call(wpObject, this.state.value, function (error, data) {
            if (error) {
                if (component.state.retryCount < 3) {
                    component.setState({retryCount: component.state.retryCount + 1});
                    window.setTimeout(function () {
                        component.handleSubmit()
                    }, 2e3 * component.state.retryCount)
                } else {
                    component.setState({isSubmitting: false, retryCount: 0});
                    var errorMessage = i18n.translate({original: "Reply Failed: Please, try again."});
                    component.props.global.updateStatusBar(errorMessage, ["fail"], 6e3);
                    component.props.global.toggleKeyboardShortcuts(true);
                    component.props.global.toggleNavigation(true)
                }
                throw error;
                return
            }
            if (component.props.note.meta.ids.comment) {
                component.props.global.client.approveNoteLocal(component.props.note.id)
            }
            component.refs.replyTextArea.getDOMNode().blur();
            if (data.URL && functions.validURL.test(data.URL)) {
                statusMessage = functions.formatString('{0} <a target="_blank" href="{1}">{2}</a>', successMessage, data.URL, linkMessage)
            } else {
                statusMessage = successMessage
            }
            component.props.global.updateStatusBar(statusMessage, ["success"], 12e3);
            component.props.global.toggleKeyboardShortcuts(true);
            component.props.global.toggleNavigation(true);
            component.setState({value: "", isSubmitting: false, hasClicked: false, rowCount: 1, retryCount: 0});
            component.localStorage.removeItem(component.savedReplyKey);
            component.props.global.client.router("/")
        })
    }, render: function () {
        var value = this.state.value;
        var submitLink = "";
        var sendText = i18n.translate({original: "Send"});
        if (this.state.isSubmitting) {
            submitLink = React.createElement("div", {className: "spinner animated"}, React.createElement("span", {className: "side left"}), React.createElement("span", {className: "side right"}))
        } else {
            if (value.length) {
                var submitLinkTitle = i18n.translate({original: "Submit reply", context: "verb: imperative"});
                submitLink = React.createElement("a", {href: "#", title: submitLinkTitle, className: "active", onClick: this.handleSubmit}, sendText)
            } else {
                var submitLinkTitle = i18n.translate({original: "Write your response in order to submit", context: "verb: imperative"});
                submitLink = React.createElement("a", {href: "#", title: submitLinkTitle, className: "inactive"}, sendText)
            }
        }
        return React.createElement("div", {className: "replyBox"}, React.createElement("textarea", {ref: "replyTextArea", rows: this.state.rowCount, value: value, placeholder: this.props.defaultValue, onClick: this.handleClick, onFocus: this.handleFocus, onBlur: this.handleBlur, onChange: this.handleChange}), submitLink, this.renderSuggestions())
    }})
}, {"./functions": 23, browser: 272, "comment-replies-cache": 274, debug: 48, i18n: 6, suggestions: 283, wp: 34}], 21: [function (require, module, exports) {
    module.exports = React.createClass({displayName: "exports", render: function () {
        console.log(this.props);
        return React.createElement("div", {className: "error"}, this.props.error)
    }})
}, {}], 22: [function (require, module, exports) {
    var wpcom = require("wp");
    var i18n = require("i18n");
    module.exports = React.createClass({displayName: "exports", propTypes: {site: React.PropTypes.number, isFollowing: React.PropTypes.bool}, followStatTypes: {comment: "note_commented_post", comment_like: "note_liked_comment", like: "note_liked_post", follow: "note_followed", reblog: "note_reblog_post"}, getInitialState: function () {
        return{isFollowing: this.props.isFollowing}
    }, toggleFollowStatus: function (event) {
        var isFollowing = this.state.isFollowing;
        var follower = wpcom.site(this.props.site).follow();
        var component = this;
        var updateState = function (error, data) {
            if (error)throw error;
            component.setState({isFollowing: data.is_following})
        };
        if (isFollowing) {
            follower.del(updateState);
            wpcom.bumpStat("notes-click-action", "unfollow")
        } else {
            follower.add(updateState);
            var stats = {"notes-click-action": "follow"};
            stats["follow_source"] = this.followStatTypes[this.props.noteType];
            wpcom.bumpStat(stats)
        }
        this.setState({isFollowing: !isFollowing})
    }, render: function () {
        var noticon_class, link_text;
        if (this.state.isFollowing) {
            noticon_class = "noticon-following";
            link_text = i18n.translate({original: "Following", context: "you are following"})
        } else {
            noticon_class = "noticon-follow";
            link_text = i18n.translate({original: "Follow", context: "verb: imperative"})
        }
        return React.createElement("a", {className: "follow-link", onClick: this.toggleFollowStatus, href: "#"}, React.createElement("span", {className: "noticon " + noticon_class}), link_text)
    }})
}, {i18n: 6, wp: 34}], 23: [function (require, module, exports) {
    var indices = require("indices-to-html");

    function p(html) {
        return html.split("\n\n").map(function (chunk) {
            var somewhatRandomKey = "block-text-" + chunk.length + "-" + Date.now() + "-" + Math.random() * 1e4;
            return React.createElement("div", {key: somewhatRandomKey, dangerouslySetInnerHTML: {__html: chunk.replace(/\n/g, "<br/>")}})
        })
    }

    function div(html) {
        return html.split("\n\n").map(function (chunk) {
            var somewhatRandomKey = "block-text-" + chunk.length + "-" + Date.now() + "-" + Math.random() * 1e4;
            var className = "paragraph";
            return React.createElement("div", {className: className, key: somewhatRandomKey, dangerouslySetInnerHTML: {__html: chunk.replace(/\n/g, "<br/>")}})
        })
    }

    module.exports.p = div;
    module.exports.pSoup = function (items) {
        return items.map(function (item) {
            return indices.html(item)
        }).map(p)
    };
    function getSignature(blocks) {
        if (!blocks || !blocks.length) {
            return[]
        }
        return blocks.map(function (block) {
            var type = "text";
            var id = null;
            if ("undefined" !== typeof block.type) {
                type = block.type
            }
            if ("undefined" == typeof block.meta || "undefined" == typeof block.meta.ids || Object.keys(block.meta.ids).length < 1) {
                return{type: type, id: id}
            }
            if ("undefined" !== typeof block.meta.ids.comment) {
                type = "comment";
                id = block.meta.ids.comment
            } else if ("undefined" !== typeof block.meta.ids.post) {
                type = "post";
                id = block.meta.ids.post
            } else if ("undefined" !== typeof block.meta.ids.user) {
                type = "user";
                id = block.meta.ids.user
            }
            return{type: type, id: id}
        })
    }

    module.exports.getSignature = getSignature;
    function formatString() {
        var args = [].slice.apply(arguments);
        var str = args.shift();
        return str.replace(/{(\d+)}/g, function (match, number) {
            return typeof args[number] != "undefined" ? args[number] : match
        })
    }

    module.exports.formatString = formatString;
    function zipWithSignature(blocks) {
        var signature = getSignature(blocks);
        return blocks.map(function (block, i) {
            return{block: block, signature: signature[i]}
        })
    }

    module.exports.zipWithSignature = zipWithSignature;
    module.exports.validURL = /^(?:http(?:s?)\:\/\/|~\/|\/)?(?:\w+:\w+@)?((?:(?:[-\w\d{1-3}]+\.)+(?:com|org|net|gov|mil|biz|info|mobi|name|aero|jobs|edu|co\.uk|ac\.uk|it|fr|tv|museum|asia|local|travel|blog|[a-z]{2}))|((\b25[0-5]\b|\b[2][0-4][0-9]\b|\b[0-1]?[0-9]?[0-9]\b)(\.(\b25[0-5]\b|\b[2][0-4][0-9]\b|\b[0-1]?[0-9]?[0-9]\b)){3}))(?::[\d]{1,5})?(?:(?:(?:\/(?:[-\w~!$+|.,=]|%[a-f\d]{2})+)+|\/)+|\?|#)?(?:(?:\?(?:[-\w~!$+|.,*:]|%[a-f\d{2}])+=?(?:[-\w~!$+|.,*:=]|%[a-f\d]{2})*)(?:&(?:[-\w~!$+|.,*:]|%[a-f\d{2}])+=?(?:[-\w~!$+|.,*:=]|%[a-f\d]{2})*)*)*(?:#(?:[-\w~!$ |\/.,*:;=]|%[a-f\d]{2})*)?$/i
}, {"indices-to-html": 277}], 24: [function (require, module, exports) {
    var i18n = require("i18n");
    var debug = require("debug")("notifications:list");
    var TITLE_BAR_HEIGHT = 38;
    var HEADER_HEIGHT = 34;
    module.exports = React.createClass({displayName: "exports", getDefaultProps: function () {
        return{title: "None", index: -1, offset: -1, nextOffset: -1}
    }, componentDidUpdate: function () {
        var node = this.getDOMNode();
        if (node.offsetTop != this.props.offset) {
            this.props.setOffset(this.props.index, node.offsetTop)
        }
    }, render: function () {
        var title = this.props.title, classNames = ["timeGroupTitle"], style = {};
        if (this.props.offset != -1 && this.props.nextOffset != -1) {
            if (this.props.scroll >= this.props.offset - TITLE_BAR_HEIGHT && this.props.scroll < this.props.nextOffset - (HEADER_HEIGHT + TITLE_BAR_HEIGHT)) {
                classNames.push("fixed")
            }
            if (this.props.scroll >= this.props.nextOffset - (HEADER_HEIGHT + TITLE_BAR_HEIGHT) && this.props.scroll < this.props.nextOffset - TITLE_BAR_HEIGHT) {
                classNames.push("fixed");
                style = {position: "absolute", top: this.props.nextOffset - HEADER_HEIGHT + "px"}
            }
        } else if (this.props.offset != -1) {
            if (this.props.scroll >= this.props.offset - TITLE_BAR_HEIGHT && this.props.offset >= TITLE_BAR_HEIGHT) {
                classNames.push("fixed")
            }
        }
        classNames = classNames.join(" ");
        return React.createElement("li", {className: "timeGroupWrap"}, React.createElement("div", {className: classNames, style: style}, React.createElement("span", {className: "noticon noticon-time"}), title))
    }})
}, {debug: 48, i18n: 6}], 25: [function (require, module, exports) {
    var Note = require("./note");
    var ListHeader = require("./list-header");
    var StatusBar = require("./status-bar");
    var UndoBar = require("./undo-list-item");
    var i18n = require("i18n");
    var throttle = require("per-frame");
    var debug = require("debug")("notifications:list");
    var DAY_MILLISECONDS = 24 * 60 * 60 * 1e3;
    var TITLE_BAR_HEIGHT = 38;
    var ScrollMixin = {getDefaultProps: function () {
        return{scrollTimeout: 200}
    }, getInitialState: function () {
        return{scrollY: 0, scrolling: false, statusMessage: ""}
    }, componentDidMount: function () {
        window.addEventListener("scroll", this.onScroll)
    }, componentWillUnmount: function () {
        window.removeEventListener("scroll", this.onScroll)
    }, onScrollEnd: function () {
        this.setState({scrolling: false})
    }, onScroll: throttle(function () {
        if (this.props.current)return;
        if (!this.state.scrolling || this.state.scrollY !== window.pageYOffset) {
            this.setState({scrolling: true, scrollY: window.pageYOffset})
        }
        window.clearTimeout(this.scrollTimeout);
        this.scrollTimeout = window.setTimeout(this.onScrollEnd, this.props.scrollTimeout)
    })};
    module.exports = React.createClass({displayName: "exports", mixins: [ScrollMixin], getInitialState: function () {
        return{undoAction: null, undoNote: null, loading: true}
    }, componentWillMount: function () {
        this.groupTitles = [i18n.translate({original: "Today", context: "heading for a list of notifications from today"}), i18n.translate({original: "Yesterday", context: "heading for a list of notifications from yesterday"}), i18n.translate({original: "Older than 2 days", context: "heading for a list of notifications that are more than 2 days old"}), i18n.translate({original: "Older than a week", context: "heading for a list of notifications that are more than a week old"}), i18n.translate({original: "Older than a month", context: "heading for a list of notifications that are more than a month old"})];
        this.offsets = [-1, -1, -1, -1, -1];
        this.props.global.hideNote = this.hideNote;
        this.props.global.updateStatusBar = this.updateStatusBar;
        this.props.global.resetStatusBar = this.resetStatusBar;
        this.props.global.updateUndoBar = this.updateUndoBar;
        this.props.global.resetUndoBar = this.resetUndoBar;
        this.props.global.hiddenNotes = new Array;
        this.props.client.on("loading", this.setLoadingState);
        this.props.client.on("loadingDone", this.unsetLoadingState)
    }, componentWillUnmount: function () {
        this.props.client.removeListener("loading", this.setLoadingState);
        this.props.client.removeListener("loadingDone", this.unsetLoadingState)
    }, componentWillReceiveProps: function (nextProps) {
        if (nextProps.resetView) {
            window.scrollTo(0, 0);
            this.setState({scrollY: 0}, this.props.resetViewComplete)
        } else if (this.props.current && !nextProps.current) {
            window.scrollTo(0, this.state.scrollY);
            this.ensureSelectedNoteVisibility()
        } else if (nextProps.current && !this.props.current) {
            window.scrollTo(0, 0);
            if ("undefined" != typeof this.refs.undoBar) {
                this.refs.undoBar.actImmediately()
            }
        }
    }, componentDidUpdate: function (prevProps, prevState) {
        if (!this.props.current && !this.state.loading) {
            if (window.pageYOffset + window.innerHeight >= document.body.clientHeight - 100) {
                this.props.client.loadMore()
            }
        }
    }, setLoadingState: function () {
        if (!this.state.loading) {
            this.setState({loading: true})
        }
    }, unsetLoadingState: function () {
        if (this.state.loading) {
            this.setState({loading: false})
        }
    }, setOffset: function (index, offset) {
        if (index < 0 || index >= this.offsets.length)return;
        this.offsets[index] = offset
    }, hideNote: function (id) {
        var idList = this.props.global.hiddenNotes;
        if (idList.indexOf(id) > -1) {
            return
        }
        idList.push(id)
    }, updateStatusBar: function (message, classList, delay) {
        this.setState({statusClasses: classList, statusMessage: message, statusTimeout: delay})
    }, resetStatusBar: function () {
        this.setState({statusClasses: [], statusMessage: ""})
    }, updateUndoBar: function (action, note) {
        var component = this;
        this.setState({undoAction: action, undoNote: note}, function () {
            if ("undefined" != component.refs.undoBar) {
                component.refs.undoBar.startUndoSequence()
            }
        })
    }, resetUndoBar: function () {
        this.setState({undoAction: null, undoNote: null})
    }, ensureSelectedNoteVisibility: function () {
        var scrollTarget = null, selectedNote = this.props.global.navigation.selectedNote, noteElement = this.refs["note-node-" + selectedNote], listElement, topPadding;
        if (null == selectedNote) {
            scrollTarget = this.state.scrollY + 1
        } else if ("undefined" === typeof noteElement) {
            scrollTarget = this.state.scrollY + 1
        } else {
            noteElement = noteElement.getDOMNode();
            listElement = this.refs["note-list-ol"].getDOMNode();
            topPadding = listElement.offsetTop + TITLE_BAR_HEIGHT;
            if (noteElement.offsetTop - window.pageYOffset <= topPadding) {
                scrollTarget = noteElement.offsetTop - topPadding
            } else if (window.pageYOffset + window.innerHeight <= noteElement.offsetTop + topPadding) {
                scrollTarget = noteElement.offsetTop + noteElement.offsetHeight - window.innerHeight
            }
        }
        if (scrollTarget !== null) {
            window.scrollTo(0, scrollTarget)
        }
    }, render: function () {
        var _this = this;
        var now = new Date;
        now.setHours(0, 0, 0, 0);
        var timeBoundaries = [new Date, now, new Date(now - DAY_MILLISECONDS * 1), new Date(now - DAY_MILLISECONDS * 6), new Date(now - DAY_MILLISECONDS * 30)];
        this.emptyNotesMessage = i18n.translate({original: "No activity yet."});
        this.emptyNotesLink = i18n.translate({original: "Look for inspiration."});
        var noteIsBetween = function (note, from, to) {
            var noteTime = new Date(note.timestamp);
            from = from || new Date(noteTime.getFullYear(), noteTime.getMonth(), noteTime.getDate() - 1);
            to = to || new Date(noteTime.getFullYear(), noteTime.getMonth(), noteTime.getDate() + 1);
            if (from < noteTime && noteTime <= to)return true; else return false
        };
        var createNoteComponent = function (note) {
            if (_this.state.undoNote && note.id == _this.state.undoNote.id) {
                return React.createElement(UndoBar, {ref: "undoBar", key: "undo-" + _this.state.undoAction + "-" + note.id, action: _this.state.undoAction, note: _this.state.undoNote, global: _this.props.global})
            }
            if (_this.props.global.hiddenNotes.indexOf(note.id) == -1) {
                return React.createElement(Note, {note: note, ref: "note-node-" + note.id, key: "note-" + note.id, current: _this.props.current == note.id, client: _this.props.client, global: _this.props.global})
            }
        };
        var noteGroups = timeBoundaries.map(function (time, i) {
            return _this.props.notes.filter(function (note) {
                return noteIsBetween(note, timeBoundaries[i + 1], timeBoundaries[i])
            }).map(createNoteComponent)
        });
        var header;
        var nextOffset;
        var offset_i;
        var scroll;
        var notes = noteGroups.reduce(function (notes, group, i) {
            if (0 < group.length) {
                if (_this.state && _this.state.scrollY) {
                    scroll = _this.state.scrollY
                } else {
                    scroll = 0
                }
                nextOffset = -1;
                offset_i = i + 1;
                while (_this.offsets[offset_i] == -1 && offset_i < _this.offsets.length) {
                    offset_i += 1
                }
                nextOffset = _this.offsets[offset_i];
                header = React.createElement(ListHeader, {key: "time-group-" + i, title: _this.groupTitles[i], scroll: scroll, index: i, offset: _this.offsets[i], nextOffset: nextOffset, setOffset: _this.setOffset});
                notes.push(header);
                notes.push.apply(notes, group)
            }
            return notes
        }, []);
        var loadingIndicatorVisibility = {display: "none"};
        if (this.state.loading) {
            loadingIndicatorVisibility.display = "block";
            if (notes.length == 0) {
                loadingIndicatorVisibility.height = window.innerHeight + "px"
            }
        } else if (notes.length == 0) {
            notes = React.createElement("div", {id: "empty-notes-container", style: {height: window.innerHeight + "px"}}, React.createElement("div", {id: "empty-notes"}, this.emptyNotesMessage, React.createElement("br", null), React.createElement("a", {href: "https://wordpress.com/fresh/", target: "_blank"}, this.emptyNotesLink)))
        }
        return React.createElement("ol", {ref: "note-list-ol", className: "notes"}, React.createElement(StatusBar, {statusClasses: this.state.statusClasses, statusMessage: this.state.statusMessage, statusTimeout: this.state.statusTimeout, statusReset: this.resetStatusBar}), notes, React.createElement("div", {style: loadingIndicatorVisibility, id: "loading-indicator"}, React.createElement("div", {className: "spinner animated"}, React.createElement("span", {className: "side left"}), React.createElement("span", {className: "side right"}))))
    }})
}, {"./list-header": 24, "./note": 26, "./status-bar": 28, "./undo-list-item": 31, debug: 48, i18n: 6, "per-frame": 57}], 26: [function (require, module, exports) {
    var indices = require("indices-to-html");
    var SummaryInList = require("./summary-in-list");
    var SummaryInSingle = require("./summary-in-single");
    var NoteBody = require("./body");
    var functions = require("./functions");
    var wpcom = require("wp");
    module.exports = React.createClass({displayName: "exports", markAsRead: function (status) {
        this.props.client.setReadStatus(this.props.note.id, status);
        wpcom.bumpStat("notes-read-type", this.props.note.type)
    }, componentWillReceiveProps: function (nextProps) {
        if (nextProps.current && !nextProps.note.read) {
            this.markAsRead()
        }
    }, render: function () {
        var summary;
        var classes = [this.props.client.noteIsRead(this.props.note) ? "read" : "unread", "note", this.props.note.type];
        var body;
        if (this.props.global.navigation.selectedNote == this.props.note.id) {
            if (this.props.global.input.lastInputWasKeyboard) {
                classes.push("selectedNote")
            }
        }
        for (var i = 0; i < this.props.note.body.length; i++) {
            var block = this.props.note.body[i];
            if ("undefined" != typeof block.media) {
                for (var j = 0; j < block.media.length; j++) {
                    if ("badge" == block.media[j].type) {
                        classes.push("badge");
                        i = this.props.note.body.length;
                        break
                    }
                }
            }
        }
        if ("comment" == this.props.note.type) {
            var noteBody = this.props.note.body;
            if (noteBody.length > 1 && noteBody[noteBody.length - 1].actions) {
                if ("undefined" != typeof noteBody[1] && "undefined" != typeof noteBody[1].nest_level) {
                    if (noteBody[1].nest_level > 0) {
                        classes.push("comment-reply")
                    }
                }
                var noteActions = noteBody[noteBody.length - 1].actions;
                if ("approve-comment"in noteActions && false == noteActions["approve-comment"]) {
                    classes.push("unapproved")
                }
            }
        }
        if (this.props.current) {
            classes.push("current");
            summary = this.props.note.header && this.props.note.header.length > 0 ? React.createElement(SummaryInSingle, {key: "note-summary-single-" + this.props.note.id, note: this.props.note}) : "";
            body = React.createElement(NoteBody, {key: "note-body-" + this.props.note.id, note: this.props.note, global: this.props.global})
        } else {
            summary = React.createElement(SummaryInList, {current: this.props.current, key: "note-summary-list" + this.props.note.id, note: this.props.note, global: this.props.global, router: this.props.global.client.router})
        }
        return React.createElement("li", {id: this.props.key, className: classes.join(" ")}, summary, body)
    }})
}, {"./body": 13, "./functions": 23, "./summary-in-list": 29, "./summary-in-single": 30, "indices-to-html": 277, wp: 34}], 27: [function (require, module, exports) {
    var functions = require("./functions");
    module.exports = React.createClass({displayName: "exports", render: function () {
        var ps = functions.pSoup(this.props.blocks);
        return React.createElement("div", {className: "preface"}, ps)
    }})
}, {"./functions": 23}], 28: [function (require, module, exports) {
    module.exports = React.createClass({displayName: "exports", getDefaultProps: function () {
        return{statusTimeout: 4e3}
    }, getInitialState: function () {
        return{isVisible: false, timeoutHandle: null}
    }, disappear: function () {
        this.setState({isVisible: false, timeoutHandle: null});
        this.props.statusReset()
    }, componentWillReceiveProps: function (nextProps) {
        if ("" == nextProps.statusMessage)return;
        if (nextProps.statusMessage == this.props.statusMessage)return;
        var component = this;
        var timeout = window.setTimeout(function () {
            component.disappear()
        }, nextProps.statusTimeout ? nextProps.statusTimeout : this.props.statusTimeout);
        this.setState({isVisible: true, timeoutHandle: timeout})
    }, render: function () {
        var visibility = this.state.isVisible ? {display: "block"} : {display: "none"};
        var classes = ["status-bar"];
        if ("undefined" != typeof this.props.statusClasses && this.props.statusClasses.length > 0) {
            classes.push.apply(classes, this.props.statusClasses)
        }
        return React.createElement("div", {className: classes.join(" "), style: visibility}, React.createElement("span", {dangerouslySetInnerHTML: {__html: this.props.statusMessage}}), React.createElement("span", {className: "close-link noticon", onClick: this.disappear}, ""))
    }})
}, {}], 29: [function (require, module, exports) {
    var indices = require("indices-to-html");
    var functions = require("./functions");
    var ImageLoader = require("react-imageloader");
    module.exports = React.createClass({displayName: "exports", handleClick: function (event) {
        this.props.global.input.lastInputWasKeyboard = false;
        this.props.router("/" + this.props.note.id.toString())
    }, render: function () {
        var subject = indices.html(this.props.note.subject[0], {links: false});
        var excerpt = null;
        if (1 < this.props.note.subject.length) {
            excerpt = React.createElement("div", {className: "excerpt"}, this.props.note.subject[1].text)
        }
        var mysteryman = function () {
            return React.createElement("img", {src: "https://www.gravatar.com/avatar/ad516503a11cd5ca435acc9bb6523536?s=128"})
        };
        return React.createElement("div", {className: "summary", onClick: this.handleClick}, React.createElement("div", {className: "icon"}, React.createElement(ImageLoader, {src: this.props.note.icon, preloader: mysteryman}), React.createElement("span", {className: "noticon"}, this.props.note.noticon)), React.createElement("div", {className: "text-summary"}, React.createElement("div", {className: "subject", dangerouslySetInnerHTML: {__html: subject}}), excerpt))
    }})
}, {"./functions": 23, "indices-to-html": 277, "react-imageloader": 64}], 30: [function (require, module, exports) {
    var indices = require("indices-to-html");
    var functions = require("./functions");
    var Snippet = React.createClass({displayName: "Snippet", render: function () {
        return React.createElement("a", {href: this.props.url, target: "_blank"}, React.createElement("span", {className: "excerpt"}, this.props.snippet.text))
    }});
    var UserHeader = React.createClass({displayName: "UserHeader", render: function () {
        var grav = this.props.user.media[0];
        var grav_tag = React.createElement("img", {src: grav.url, height: grav.height, width: grav.width});
        var home_url = this.props.user.ranges[0].url;
        var get_home_link = function (classNames, children) {
            if (home_url) {
                return React.createElement("a", {className: classNames, href: home_url, target: "_blank"}, children)
            } else {
                return React.createElement("a", {className: classNames + " disabled", href: "#", disabled: "disabled"}, children)
            }
        };
        return React.createElement("div", {className: "user header"}, get_home_link("site", grav_tag), React.createElement("div", null, React.createElement("span", {className: "username"}, get_home_link("home", this.props.user.text))), React.createElement(Snippet, {snippet: this.props.snippet, url: this.props.url}))
    }});
    var Header = React.createFactory(React.createClass({render: function () {
        var subject = React.createElement("div", {className: "subject", dangerouslySetInnerHTML: {__html: indices.html(this.props.subject)}});
        return React.createElement("div", {className: "summary"}, subject, React.createElement(Snippet, {snippet: this.props.snippet, url: this.props.url}))
    }}));
    module.exports = React.createClass({displayName: "exports", render: function () {
        var header_url, parser;
        if (!this.props.note.header || 0 === this.props.note.header.length) {
            return React.createElement("span", null)
        }
        if (this.props.note.header.length > 1) {
            if ("user" === this.props.note.header[0].ranges[0].type) {
                header_url = this.props.note.url;
                if (this.props.note.type === "comment") {
                    if (this.props.note.meta.ids.parent_comment) {
                        parser = document.createElement("a");
                        parser.href = this.props.note.url;
                        parser.hash = "#comment-" + this.props.note.meta.ids.parent_comment;
                        header_url = parser.href
                    }
                }
                return React.createElement(UserHeader, {user: this.props.note.header[0], snippet: this.props.note.header[1], url: header_url})
            }
            return React.createElement(Header, {subject: this.props.note.header[0], snippet: this.props.note.header[1], url: this.props.note.url})
        } else {
            return React.createElement(Header, {subject: this.props.note.header[0], snippet: "", url: this.props.note.url})
        }
    }})
}, {"./functions": 23, "indices-to-html": 277}], 31: [function (require, module, exports) {
    var i18n = require("i18n");
    var wpcom = require("wp");
    module.exports = React.createClass({displayName: "exports", getInitialState: function () {
        return{undoTimer: null, undoTimeout: 4500, isVisible: true}
    }, componentDidMount: function () {
        window.addEventListener("keydown", this.handleKeyDown, false)
    }, componentWillUnmount: function () {
        window.removeEventListener("keydown", this.handleKeyDown)
    }, handleKeyDown: function (event) {
        if (!this.props.global.keyboardShortcutsAreEnabled) {
            return
        }
        if (this.props.global.input.modifierKeyIsActive(event)) {
            return
        }
        if (null != this.state.undoTimer) {
            if (85 == event.keyCode || 84 == event.keyCode || 83 == event.keyCode) {
                this.cancelAction()
            }
        }
    }, componentDidUpdate: function (prevProps, prevState) {
        if (null == this.props.action || "" == this.props.action)return;
        if (null == this.state.undoTimer && prevProps.action != this.props.action)this.startUndoSequence()
    }, startUndoSequence: function () {
        var timerHandle = window.setTimeout(this.executor, this.state.undoTimeout);
        this.setState({undoTimer: timerHandle})
    }, executor: function () {
        var actionHandlers = {spam: this.spamComment, trash: this.deleteComment};
        if (!(this.props.action in actionHandlers)) {
            this.props.global.resetUndoBar();
            return
        }
        actionHandlers[this.props.action]()
    }, spamComment: function () {
        var comment = wpcom.site(this.props.note.meta.ids.site).comment(this.props.note.meta.ids.comment);
        var component = this;
        var updateSpamStatus = function (error, data) {
            if (error)throw error;
            if ("spam" != data.status) {
            }
        };
        comment.get(function (error, data) {
            if (error)throw error;
            data.status = "spam";
            comment.update(data, updateSpamStatus)
        });
        component.props.global.hideNote(component.props.note.id);
        component.finishExecution()
    }, deleteComment: function () {
        var comment = wpcom.site(this.props.note.meta.ids.site).comment(this.props.note.meta.ids.comment);
        var component = this;
        component.setState({isVisible: false});
        comment.del(function (error, data) {
            if (error)throw error
        });
        component.props.global.hideNote(component.props.note.id);
        component.finishExecution()
    }, actImmediately: function () {
        window.clearTimeout(this.state.undoTimer);
        this.setState({isVisible: false});
        this.executor()
    }, cancelAction: function () {
        window.clearTimeout(this.state.undoTimer);
        switch (this.props.action) {
            case"spam":
                wpcom.bumpStat("notes-click-action", "unspam-comment");
                break;
            case"trash":
                wpcom.bumpStat("notes-click-action", "untrash-comment");
                break
        }
        this.finishExecution()
    }, finishExecution: function () {
        this.setState({undoTimer: null});
        this.props.global.resetUndoBar()
    }, render: function () {
        var actionMessages = {spam: i18n.translate({original: "Comment marked as spam"}), trash: i18n.translate({original: "Comment trashed"})};
        var undo_text = i18n.translate({original: "Undo", context: "verb: imperative"});
        var message = actionMessages[this.props.action];
        var isVisible = this.state.isVisible ? {display: "block"} : {display: "none"};
        return React.createElement("div", {className: "summary undo-item", style: isVisible}, React.createElement("p", null, React.createElement("a", {href: "#", className: "undo-link", onClick: this.cancelAction}, undo_text), React.createElement("span", {className: "undo-message"}, message), React.createElement("span", {className: "close-link noticon", onClick: this.actImmediately}, "")))
    }})
}, {i18n: 6, wp: 34}], 32: [function (require, module, exports) {
    module.exports = {last_seen_time: "1415214033", number: 9, notes: [
        {id: 1487683993, type: "comment", read: 1, noticon: "", timestamp: "2014-11-05T19:00:33+00:00", icon: "https://1.gravatar.com/avatar/db127a496309f2717657d6f6167abd49?s=256&d=https%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D256&r=G", url: "http://datap2.wordpress.com/2014/11/05/i-had-a-funny-notification/#comment-15289", subject: [
            {text: "Aaron Douglas mentioned Simperium on I had a funny notification...", ranges: [
                {type: "user", indices: [0, 13], url: "http://astralbodiesnet.wordpress.com", site_id: 66592863, id: 67137},
                {type: "post", indices: [37, 66], url: "http://datap2.wordpress.com/2014/11/05/i-had-a-funny-notification/", site_id: 14838835, id: 10878}
            ]},
            {text: "+simperiump2 Would this have been affected by any changes made to the Simperium backing on notes?", ranges: [
                {type: "comment", indices: [0, 97], url: "http://datap2.wordpress.com/2014/11/05/i-had-a-funny-notification/#comment-15289", site_id: 14838835, post_id: 10878, id: 15289}
            ]}
        ], body: [
            {text: "Aaron Douglas", ranges: [
                {type: "user", indices: [0, 13], url: "http://astralbodiesnet.wordpress.com", site_id: 66592863, id: 67137}
            ], media: [
                {type: "image", indices: [0, 0], height: "256", width: "256", url: "https://1.gravatar.com/avatar/db127a496309f2717657d6f6167abd49?s=256&d=https%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D256&r=G"}
            ], actions: {follow: false}, meta: {ids: {user: 67137, site: 66592863}, links: {home: "http://astralbodiesnet.wordpress.com"}, titles: {home: "The Dangling Pointer", tagline: "Sh*t my brain says and forgets about"}}, type: "user"},
            {text: "+simperiump2 Would this have been affected by any changes made to the Simperium backing on notes?", actions: {"spam-comment": false, "trash-comment": false, "approve-comment": true, "replyto-comment": true, "like-comment": false}, meta: {ids: {comment: 15289, user: 67137, post: 10878, site: 14838835}, links: {comment: "https://public-api.wordpress.com/rest/v1/comments/15289", user: "https://public-api.wordpress.com/rest/v1/users/67137", post: "https://public-api.wordpress.com/rest/v1/posts/10878", site: "https://public-api.wordpress.com/rest/v1/sites/14838835"}}, type: "comment", nest_level: 0}
        ], meta: {ids: {user: 67137, comment: 15289, post: 10878, site: 14838835}, links: {user: "https://public-api.wordpress.com/rest/v1/users/67137", comment: "https://public-api.wordpress.com/rest/v1/comments/15289", post: "https://public-api.wordpress.com/rest/v1/posts/10878", site: "https://public-api.wordpress.com/rest/v1/sites/14838835"}}, title: "Mention", header: [
            {text: "Zandy Ring", ranges: [
                {type: "user", indices: [0, 10], url: "http://revelryreverie.wordpress.com", site_id: 34392579, id: 14756525}
            ], media: [
                {type: "image", indices: [0, 0], height: "256", width: "256", url: "https://0.gravatar.com/avatar/67d1d9ab212e32510b7444c6c791ebcb?s=256&d=https%3A%2F%2F0.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D256&r=G"}
            ]},
            {text: "I had a funny notification..."}
        ]},
        {id: 1486170266, type: "like", read: 1, noticon: "", timestamp: "2014-11-05T02:24:07+00:00", icon: "https://2.gravatar.com/avatar/e44d9c00c3af8037f203ca42207a99d7?s=256&d=https%3A%2F%2F2.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D256&r=G", url: "http://thursdayupdates.wordpress.com/2014/11/04/simperium-update-113/", subject: [
            {text: "Jorge Leandro Perez liked your post Simperium update 11/3:", ranges: [
                {type: "user", indices: [0, 19], url: "http://www.lantean.co", site_id: 46233804, id: 45413599},
                {type: "post", indices: [36, 58], url: "http://thursdayupdates.wordpress.com/2014/11/04/simperium-update-113/", site_id: 11438384, id: 10560}
            ]}
        ], body: [
            {text: "Jorge Leandro Perez", ranges: [
                {type: "user", indices: [0, 19], url: "http://www.lantean.co", site_id: 46233804, id: 45413599}
            ], media: [
                {type: "image", indices: [0, 0], height: "256", width: "256", url: "https://2.gravatar.com/avatar/e44d9c00c3af8037f203ca42207a99d7?s=256&d=https%3A%2F%2F2.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D256&r=G"}
            ], actions: {follow: false}, meta: {ids: {user: 45413599, site: 46233804}, links: {home: "http://www.lantean.co"}, titles: {home: "Lantean", tagline: "Thoughts"}}, type: "user"}
        ], meta: {ids: {site: 11438384, post: 10560}, links: {site: "https://public-api.wordpress.com/rest/v1/sites/11438384", post: "https://public-api.wordpress.com/rest/v1/posts/10560"}}, title: "1 Like", header: [
            {text: "Fred Cheng", ranges: [
                {type: "user", indices: [0, 10], url: "http://fredcheng.wordpress.com", site_id: 43599804, id: 42994782}
            ], media: [
                {type: "image", indices: [0, 0], height: "256", width: "256", url: "https://2.gravatar.com/avatar/b7946032c0cda1319221563b867d2ff8?s=256&d=https%3A%2F%2F2.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D256&r=G"}
            ]},
            {text: "Simperium update 11/3:"}
        ]},
        {id: 1486013954, type: "comment_like", read: 1, noticon: "", timestamp: "2014-11-05T00:37:18+00:00", icon: "https://1.gravatar.com/avatar/d30bee96f3769826fca389e15d81c51d?s=256&d=https%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D256&r=G", url: "http://simperiump2.wordpress.com/2014/11/04/im-interested-in-sending-a-web-notification-to-a-particular-list-of-about-5000-to-10000-wp/#comment-1608", subject: [
            {text: "Jeff Bowen liked your comment on I'm interested in sending a web notification to a particular list of about 5,000 to 10,000 wp", ranges: [
                {type: "user", indices: [0, 10], url: "http://get2see.wordpress.com", site_id: 23922450, id: 20416304},
                {type: "post", indices: [33, 126], url: "http://simperiump2.wordpress.com/2014/11/04/im-interested-in-sending-a-web-notification-to-a-particular-list-of-about-5000-to-10000-wp/", site_id: 43797438, id: 1941}
            ]}
        ], body: [
            {text: "Jeff Bowen", ranges: [
                {type: "user", indices: [0, 10], url: "http://get2see.wordpress.com", site_id: 23922450, id: 20416304}
            ], media: [
                {type: "image", indices: [0, 0], height: "256", width: "256", url: "https://1.gravatar.com/avatar/d30bee96f3769826fca389e15d81c51d?s=256&d=https%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D256&r=G"}
            ], actions: {follow: false}, meta: {ids: {user: 20416304, site: 23922450}, links: {home: "http://get2see.wordpress.com"}, titles: {home: "Get 2 See", tagline: "Follow along as we see the sights, eat the noms, and have the funs!"}}, type: "user"}
        ], meta: {ids: {site: 43797438, post: 1941, comment: 1608}, links: {site: "https://public-api.wordpress.com/rest/v1/sites/43797438", post: "https://public-api.wordpress.com/rest/v1/posts/1941", comment: "https://public-api.wordpress.com/rest/v1/comments/1608"}}, title: "1 Like", header: [
            {text: "Fred Cheng", ranges: [
                {type: "user", indices: [0, 10], url: "http://fredcheng.wordpress.com", site_id: 43599804, id: 42994782}
            ], media: [
                {type: "image", indices: [0, 0], height: "256", width: "256", url: "https://2.gravatar.com/avatar/b7946032c0cda1319221563b867d2ff8?s=256&d=https%3A%2F%2F2.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D256&r=G"}
            ]},
            {text: "Not now if it must be web only - I don't think we have a way of using notifications as-is. Probably before December, we could potentially: A. introduce a flag that would 1. suppress push notification from being sent, and 2. apps from displaying it. B. Or an out of"}
        ]},
        {id: 1485615454, type: "comment_like", read: 1, noticon: "", timestamp: "2014-11-04T20:24:40+00:00", icon: "https://2.gravatar.com/avatar/b98556e212716a671bbd3800386e735a?s=256&d=https%3A%2F%2F2.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D256&r=G", url: "http://simperiump2.wordpress.com/2014/11/04/im-interested-in-sending-a-web-notification-to-a-particular-list-of-about-5000-to-10000-wp/#comment-1610", subject: [
            {text: "mikejohnstn liked your comment on I'm interested in sending a web notification to a particular list of about 5,000 to 10,000 wp", ranges: [
                {type: "user", indices: [0, 11], id: 14195971},
                {type: "post", indices: [34, 127], url: "http://simperiump2.wordpress.com/2014/11/04/im-interested-in-sending-a-web-notification-to-a-particular-list-of-about-5000-to-10000-wp/", site_id: 43797438, id: 1941}
            ]}
        ], body: [
            {text: "mikejohnstn", ranges: [
                {type: "user", indices: [0, 11], id: 14195971}
            ], media: [
                {type: "image", indices: [0, 0], height: "256", width: "256", url: "https://2.gravatar.com/avatar/b98556e212716a671bbd3800386e735a?s=256&d=https%3A%2F%2F2.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D256&r=G"}
            ], actions: {follow: false}, meta: {ids: {user: 14195971, site: 13792536}, links: {home: "http://kineticpoet.wordpress.com"}, titles: {home: "Mike Johnston's Blog"}}, type: "user"}
        ], meta: {ids: {site: 43797438, post: 1941, comment: 1610}, links: {site: "https://public-api.wordpress.com/rest/v1/sites/43797438", post: "https://public-api.wordpress.com/rest/v1/posts/1941", comment: "https://public-api.wordpress.com/rest/v1/comments/1610"}}, title: "1 Like", header: [
            {text: "Fred Cheng", ranges: [
                {type: "user", indices: [0, 10], url: "http://fredcheng.wordpress.com", site_id: 43599804, id: 42994782}
            ], media: [
                {type: "image", indices: [0, 0], height: "256", width: "256", url: "https://2.gravatar.com/avatar/b7946032c0cda1319221563b867d2ff8?s=256&d=https%3A%2F%2F2.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D256&r=G"}
            ]},
            {text: "Sure"}
        ]},
        {id: 1485462653, type: "comment", read: 1, noticon: "", timestamp: "2014-11-04T19:01:01+00:00", icon: "https://2.gravatar.com/avatar/b98556e212716a671bbd3800386e735a?s=256&d=https%3A%2F%2F2.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D256&r=G", url: "http://simperiump2.wordpress.com/2014/11/04/im-interested-in-sending-a-web-notification-to-a-particular-list-of-about-5000-to-10000-wp/#comment-1609", subject: [
            {text: "mikejohnstn replied to your comment Not now if it must be web only - I don't think we have a way of using notifications as-is.", ranges: [
                {type: "user", indices: [0, 11], id: 14195971},
                {type: "comment", indices: [36, 127], url: "http://simperiump2.wordpress.com/2014/11/04/im-interested-in-sending-a-web-notification-to-a-particular-list-of-about-5000-to-10000-wp/#comment-1608", site_id: 43797438, post_id: 1941, id: 1608}
            ]},
            {text: "Ah, and what if all the people on the list aren't app users already, so we can safely broadcast knowing pushes won't get sent to the apps? That doable now?", ranges: [
                {type: "comment", indices: [0, 155], url: "http://simperiump2.wordpress.com/2014/11/04/im-interested-in-sending-a-web-notification-to-a-particular-list-of-about-5000-to-10000-wp/#comment-1609", site_id: 43797438, post_id: 1941, id: 1609}
            ]}
        ], body: [
            {text: "mikejohnstn", ranges: [
                {type: "user", indices: [0, 11], id: 14195971}
            ], media: [
                {type: "image", indices: [0, 0], height: "256", width: "256", url: "https://2.gravatar.com/avatar/b98556e212716a671bbd3800386e735a?s=256&d=https%3A%2F%2F2.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D256&r=G"}
            ], actions: {follow: false}, meta: {ids: {user: 14195971, site: 13792536}, links: {home: "http://kineticpoet.wordpress.com"}, titles: {home: "Mike Johnston's Blog"}}, type: "user"},
            {text: "Ah, and what if all the people on the list aren't app users already, so we can safely broadcast knowing pushes won't get sent to the apps? That doable now?", actions: {"spam-comment": false, "trash-comment": false, "approve-comment": true, "replyto-comment": true, "like-comment": false}, meta: {ids: {comment: 1609, user: 14195971, post: 1941, site: 43797438}, links: {comment: "https://public-api.wordpress.com/rest/v1/comments/1609", user: "https://public-api.wordpress.com/rest/v1/users/14195971", post: "https://public-api.wordpress.com/rest/v1/posts/1941", site: "https://public-api.wordpress.com/rest/v1/sites/43797438"}}, type: "comment", nest_level: 1}
        ], meta: {ids: {user: 14195971, parent_comment: 1608, comment: 1609, post: 1941, site: 43797438}, links: {user: "https://public-api.wordpress.com/rest/v1/users/14195971", parent_comment: "https://public-api.wordpress.com/rest/v1/comments/1608", comment: "https://public-api.wordpress.com/rest/v1/comments/1609", post: "https://public-api.wordpress.com/rest/v1/posts/1941", site: "https://public-api.wordpress.com/rest/v1/sites/43797438"}}, title: "Reply", header: [
            {text: "Fred Cheng", ranges: [
                {type: "user", indices: [0, 10], url: "http://fredcheng.wordpress.com", site_id: 43599804, id: 42994782}
            ], media: [
                {type: "image", indices: [0, 0], height: "256", width: "256", url: "https://2.gravatar.com/avatar/b7946032c0cda1319221563b867d2ff8?s=256&d=https%3A%2F%2F2.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D256&r=G"}
            ]},
            {text: "Not now if it must be web only - I don't think we have a way of using notifications as-is. Probably before December, we could potentially: A. introduce a flag that would 1. suppress push notification from being sent, and 2. apps from displaying it. B. Or an out of"}
        ]},
        {id: 1485386557, type: "comment", read: 1, noticon: "", timestamp: "2014-11-04T18:17:57+00:00", icon: "https://2.gravatar.com/avatar/b98556e212716a671bbd3800386e735a?s=256&d=https%3A%2F%2F2.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D256&r=G", url: "http://teamtinker.wordpress.com/2014/11/04/photobot-mockups/#comment-2134", subject: [
            {text: "mikejohnstn mentioned Simplenote on #photobot #mockups Just a couple", ranges: [
                {type: "user", indices: [0, 11], id: 14195971},
                {type: "post", indices: [36, 69], url: "http://teamtinker.wordpress.com/2014/11/04/photobot-mockups/", site_id: 63216473, id: 1402}
            ]},
            {text: "Whoa, that was fast. I was hoping after mesh! In any case, if it helps, here's what I think would be good to learn about the current state of hybrid dev: * What are the best tools? * How quickly can we learn them? * How efficiently can we ship a good, minimal, cross-platform product? * To what degree is the user experience compromised (compared to full native)? * To what degree can these shortcomings be smoothed over with some custom (native) work? * Is the time cost of this custom work worth the benefits of hybrid dev in the", ranges: [
                {type: "comment", indices: [0, 532], url: "http://teamtinker.wordpress.com/2014/11/04/photobot-mockups/#comment-2134", site_id: 63216473, post_id: 1402, id: 2134}
            ]}
        ], body: [
            {text: "mikejohnstn", ranges: [
                {type: "user", indices: [0, 11], id: 14195971}
            ], media: [
                {type: "image", indices: [0, 0], height: "256", width: "256", url: "https://2.gravatar.com/avatar/b98556e212716a671bbd3800386e735a?s=256&d=https%3A%2F%2F2.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D256&r=G"}
            ], actions: {follow: false}, meta: {ids: {user: 14195971, site: 13792536}, links: {home: "http://kineticpoet.wordpress.com"}, titles: {home: "Mike Johnston's Blog"}}, type: "user"},
            {text: "Whoa, that was fast. I was hoping after mesh! In any case, if it helps, here's what I think would be good to learn about the current state of hybrid dev:\n\n* What are the best tools?\n* How quickly can we learn them?\n* How efficiently can we ship a good, minimal, cross-platform product?\n* To what degree is the user experience compromised (compared to full native)?\n* To what degree can these shortcomings be smoothed over with some custom (native) work?\n* Is the time cost of this custom work worth the benefits of hybrid dev in the first place?\n* How does the joyfulness of hybrid dev compare to native dev?\n\nIt'd help to compare these findings vs. past experience:\n\n* How does it compare to our experience shipping Selfies? Which approach was faster, more efficient, best for our users, most joyful, etc?\n* How does it compare to any past experience the team has with hybrid dev? How far has it come in the past year or two, and where might it be 6-12 months from now?\n\nFinally, some concrete, strategic questions we'd be better equipped to answer when we're on the other side:\n\n* Would Tinker consider hybrid dev for their next big project?\n* Should we consider hybrid dev for part (or even all) of the WordPress apps in 2015? If so, which parts?\n* Should we consider hybrid dev for other apps, like future versions of Simplenote, Cloudup, an Automattic app, etc?\n* How should we balance internal training among mobile web, native, and hybrid?", actions: {"spam-comment": false, "trash-comment": false, "approve-comment": true, "replyto-comment": true, "like-comment": false}, meta: {ids: {comment: 2134, user: 14195971, post: 1402, site: 63216473}, links: {comment: "https://public-api.wordpress.com/rest/v1/comments/2134", user: "https://public-api.wordpress.com/rest/v1/users/14195971", post: "https://public-api.wordpress.com/rest/v1/posts/1402", site: "https://public-api.wordpress.com/rest/v1/sites/63216473"}}, type: "comment", nest_level: 0}
        ], meta: {ids: {user: 14195971, comment: 2134, post: 1402, site: 63216473}, links: {user: "https://public-api.wordpress.com/rest/v1/users/14195971", comment: "https://public-api.wordpress.com/rest/v1/comments/2134", post: "https://public-api.wordpress.com/rest/v1/posts/1402", site: "https://public-api.wordpress.com/rest/v1/sites/63216473"}}, title: "Mention", header: [
            {text: "Joen A.", ranges: [
                {type: "user", indices: [0, 7], url: "http://joen.wordpress.com", site_id: 230, id: 232}
            ], media: [
                {type: "image", indices: [0, 0], height: "256", width: "256", url: "https://1.gravatar.com/avatar/7fda1da9c34e978d5990afd7f58ca0f4?s=256&d=https%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D256&r=G"}
            ]},
            {text: "#photobot #mockups Just a couple"}
        ]},
        {id: 1472712478, type: "like", read: 1, noticon: "", timestamp: "2014-11-04T17:42:30+00:00", icon: "https://2.gravatar.com/avatar/b98556e212716a671bbd3800386e735a?s=256&d=https%3A%2F%2F2.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D256&r=G", url: "http://simperiump2.wordpress.com/2014/10/28/great-a-hrefhttpsstripe/", subject: [
            {text: "mikejohnstn and Jorge Leandro Perez liked your post Great", ranges: [
                {type: "user", indices: [0, 11], id: 14195971},
                {type: "user", indices: [16, 35], url: "http://www.lantean.co", site_id: 46233804, id: 45413599},
                {type: "post", indices: [52, 57], url: "http://simperiump2.wordpress.com/2014/10/28/great-a-hrefhttpsstripe/", site_id: 43797438, id: 1931}
            ]}
        ], body: [
            {text: "mikejohnstn", ranges: [
                {type: "user", indices: [0, 11], id: 14195971}
            ], media: [
                {type: "image", indices: [0, 0], height: "256", width: "256", url: "https://2.gravatar.com/avatar/b98556e212716a671bbd3800386e735a?s=256&d=https%3A%2F%2F2.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D256&r=G"}
            ], actions: {follow: false}, meta: {ids: {user: 14195971, site: 13792536}, links: {home: "http://kineticpoet.wordpress.com"}, titles: {home: "Mike Johnston's Blog"}}, type: "user"},
            {text: "Jorge Leandro Perez", ranges: [
                {type: "user", indices: [0, 19], url: "http://www.lantean.co", site_id: 46233804, id: 45413599}
            ], media: [
                {type: "image", indices: [0, 0], height: "256", width: "256", url: "https://2.gravatar.com/avatar/e44d9c00c3af8037f203ca42207a99d7?s=256&d=https%3A%2F%2F2.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D256&r=G"}
            ], actions: {follow: false}, meta: {ids: {user: 45413599, site: 46233804}, links: {home: "http://www.lantean.co"}, titles: {home: "Lantean", tagline: "Thoughts"}}, type: "user"}
        ], meta: {ids: {site: 43797438, post: 1931}, links: {site: "https://public-api.wordpress.com/rest/v1/sites/43797438", post: "https://public-api.wordpress.com/rest/v1/posts/1931"}}, title: "2 Likes", header: [
            {text: "Fred Cheng", ranges: [
                {type: "user", indices: [0, 10], url: "http://fredcheng.wordpress.com", site_id: 43599804, id: 42994782}
            ], media: [
                {type: "image", indices: [0, 0], height: "256", width: "256", url: "https://2.gravatar.com/avatar/b7946032c0cda1319221563b867d2ff8?s=256&d=https%3A%2F%2F2.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D256&r=G"}
            ]},
            {text: "Great"}
        ]},
        {id: 1485066474, type: "comment", read: 1, noticon: "", timestamp: "2014-11-04T15:15:11+00:00", icon: "https://1.gravatar.com/avatar/af3da6d144dc8c540521537bd6e16e37?s=256&d=https%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D256&r=G", url: "http://simperiump2.wordpress.com/meetups/barcelona-meetup-2014/#comment-1606", subject: [
            {text: "Pam Kocke commented on Barcelona Meetup 2014", ranges: [
                {type: "user", indices: [0, 9], id: 54617131},
                {type: "post", indices: [23, 44], url: "http://simperiump2.wordpress.com/meetups/barcelona-meetup-2014/", site_id: 43797438, id: 1702}
            ]},
            {text: "Oh yes. I will go if Zandy doesn't want to. And if she does, I'll capture the moment.", ranges: [
                {type: "comment", indices: [0, 85], url: "http://simperiump2.wordpress.com/meetups/barcelona-meetup-2014/#comment-1606", site_id: 43797438, post_id: 1702, id: 1606}
            ]}
        ], body: [
            {text: "Pam Kocke", ranges: [
                {type: "user", indices: [0, 9], id: 54617131}
            ], media: [
                {type: "image", indices: [0, 0], height: "256", width: "256", url: "https://1.gravatar.com/avatar/af3da6d144dc8c540521537bd6e16e37?s=256&d=https%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D256&r=G"}
            ], actions: {follow: false}, meta: {ids: {user: 54617131, site: 60865755}, links: {home: "http://pamelakocke.wordpress.com"}, titles: {home: "pyjammy.org", tagline: "my WordPress.com test blog"}}, type: "user"},
            {text: "Oh yes. I will go if Zandy doesn't want to. And if she does, I'll capture the moment.", actions: {"spam-comment": false, "trash-comment": false, "approve-comment": true, "replyto-comment": true, "like-comment": false}, meta: {ids: {comment: 1606, user: 54617131, post: 1702, site: 43797438}, links: {comment: "https://public-api.wordpress.com/rest/v1/comments/1606", user: "https://public-api.wordpress.com/rest/v1/users/54617131", post: "https://public-api.wordpress.com/rest/v1/posts/1702", site: "https://public-api.wordpress.com/rest/v1/sites/43797438"}}, type: "comment", nest_level: 4}
        ], meta: {ids: {user: 54617131, parent_comment: 1600, comment: 1606, post: 1702, site: 43797438}, links: {user: "https://public-api.wordpress.com/rest/v1/users/54617131", parent_comment: "https://public-api.wordpress.com/rest/v1/comments/1600", comment: "https://public-api.wordpress.com/rest/v1/comments/1606", post: "https://public-api.wordpress.com/rest/v1/posts/1702", site: "https://public-api.wordpress.com/rest/v1/sites/43797438"}}, title: "Reply", header: [
            {text: "Mike Adams (mdawaffe)", ranges: [
                {type: "user", indices: [0, 21], url: "http://mdawaffe.wordpress.com", site_id: 90, id: 91}
            ], media: [
                {type: "image", indices: [0, 0], height: "256", width: "256", url: "https://1.gravatar.com/avatar/4d346581a3340e32cf93703c9ce46bd4?s=256&d=https%3A%2F%2F1.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D256&r=G"}
            ]},
            {text: "If you go to Sagrada Familia (I hope you do), consider getting the tickets that let you go up to the top and tell us what it was like :)"}
        ]},
        {id: 1483690128, type: "comment", read: 1, noticon: "", timestamp: "2014-11-03T23:01:01+00:00", icon: "https://2.gravatar.com/avatar/509e5d0202ed66b36363a1fc36a741b8?s=256&d=https%3A%2F%2F2.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D256&r=G", url: "http://totallyp2dude.wordpress.com/2014/10/29/howdy-socoolenos-liked-i-mentioned/#comment-334", subject: [
            {text: "Derek Springer mentioned you on Howdy SoCooleos, liked I mentioned...", ranges: [
                {type: "user", indices: [0, 14], url: "http://www.fivebladesbrewing.com", site_id: 37790885, id: 249119},
                {type: "post", indices: [32, 70], url: "http://totallyp2dude.wordpress.com/2014/10/29/howdy-socoolenos-liked-i-mentioned/", site_id: 64251742, id: 162}
            ]},
            {text: "Sorry @fredcheng I'm removing you from the list so it's easier for me to figure out optimal dates. If you're in town when we have the event you're welcome to come :)", ranges: [
                {type: "comment", indices: [0, 165], url: "http://totallyp2dude.wordpress.com/2014/10/29/howdy-socoolenos-liked-i-mentioned/#comment-334", site_id: 64251742, post_id: 162, id: 334}
            ]}
        ], body: [
            {text: "Derek Springer", ranges: [
                {type: "user", indices: [0, 14], url: "http://www.fivebladesbrewing.com", site_id: 37790885, id: 249119}
            ], media: [
                {type: "image", indices: [0, 0], height: "256", width: "256", url: "https://2.gravatar.com/avatar/509e5d0202ed66b36363a1fc36a741b8?s=256&d=https%3A%2F%2F2.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D256&r=G"}
            ], actions: {follow: false}, meta: {ids: {user: 249119, site: 37790885}, links: {home: "http://www.fivebladesbrewing.com"}, titles: {home: "Five Blades Brewing", tagline: "F' Everything, We're Doing Five Blades"}}, type: "user"},
            {text: "Sorry @fredcheng I'm removing you from the list so it's easier for me to figure out optimal dates. If you're in town when we have the event you're welcome to come :)", actions: {"spam-comment": false, "trash-comment": false, "approve-comment": true, "replyto-comment": true, "like-comment": true}, meta: {ids: {comment: 334, user: 249119, post: 162, site: 64251742}, links: {comment: "https://public-api.wordpress.com/rest/v1/comments/334", user: "https://public-api.wordpress.com/rest/v1/users/249119", post: "https://public-api.wordpress.com/rest/v1/posts/162", site: "https://public-api.wordpress.com/rest/v1/sites/64251742"}}, type: "comment", nest_level: 0}
        ], meta: {ids: {user: 249119, comment: 334, post: 162, site: 64251742}, links: {user: "https://public-api.wordpress.com/rest/v1/users/249119", comment: "https://public-api.wordpress.com/rest/v1/comments/334", post: "https://public-api.wordpress.com/rest/v1/posts/162", site: "https://public-api.wordpress.com/rest/v1/sites/64251742"}}, title: "Mention", header: [
            {text: "Derek Springer", ranges: [
                {type: "user", indices: [0, 14], url: "http://www.fivebladesbrewing.com", site_id: 37790885, id: 249119}
            ], media: [
                {type: "image", indices: [0, 0], height: "256", width: "256", url: "https://2.gravatar.com/avatar/509e5d0202ed66b36363a1fc36a741b8?s=256&d=https%3A%2F%2F2.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D256&r=G"}
            ]},
            {text: "Howdy SoCooleos, liked I mentioned..."}
        ]},
        {id: 1372076233, type: "comment", read: 1, noticon: "", timestamp: "2014-09-01T20:54:36+00:00", icon: "https://0.gravatar.com/avatar/ad516503a11cd5ca435acc9bb6523536?s=256&r=G", url: "http://fredcheng.org/2014/06/03/58/#comment-49", subject: [
            {text: 'Someone commented on Cool pic [gallery caption="#selfie" ids="56,57"] What? ? !', ranges: [
                {type: "user", indices: [0, 7]},
                {type: "post", indices: [21, 79], url: "http://fredcheng.org/2014/06/03/58/", site_id: 43599804, id: 58}
            ]},
            {text: "A reply to anonymous? From the web", ranges: [
                {type: "comment", indices: [0, 34], url: "http://fredcheng.org/2014/06/03/58/#comment-49", site_id: 43599804, post_id: 58, id: 49}
            ]}
        ], body: [
            {text: "Someone", ranges: [
                {type: "user", indices: [0, 7]}
            ], media: [
                {type: "image", indices: [0, 0], height: "256", width: "256", url: "https://0.gravatar.com/avatar/ad516503a11cd5ca435acc9bb6523536?s=256&r=G"}
            ], type: "user"},
            {text: "A reply to anonymous? From the web", actions: {"spam-comment": false, "trash-comment": false, "approve-comment": true, "replyto-comment": true, "like-comment": true}, meta: {ids: {comment: 49, post: 58, site: 43599804}, links: {comment: "https://public-api.wordpress.com/rest/v1/comments/49", post: "https://public-api.wordpress.com/rest/v1/posts/58", site: "https://public-api.wordpress.com/rest/v1/sites/43599804"}}, type: "comment", nest_level: 2}
        ], meta: {ids: {user: 0, parent_comment: 43, comment: 49, post: 58, site: 43599804}, links: {user: "https://public-api.wordpress.com/rest/v1/users/0", parent_comment: "https://public-api.wordpress.com/rest/v1/comments/43", comment: "https://public-api.wordpress.com/rest/v1/comments/49", post: "https://public-api.wordpress.com/rest/v1/posts/58", site: "https://public-api.wordpress.com/rest/v1/sites/43599804"}}, title: "Reply", header: [
            {text: "Someone", ranges: [
                {type: "user", indices: [0, 7]}
            ], media: [
                {type: "image", indices: [0, 0], height: "256", width: "256", url: "https://0.gravatar.com/avatar/ad516503a11cd5ca435acc9bb6523536?s=256&r=G"}
            ]},
            {text: "A new comment, will the avatar update? Will it?"}
        ]}
    ]}
}, {}], 33: [function (require, module, exports) {
    var cookie = require("cookie-stripped-of-signatures");
    var cookies = cookie.parse(document.cookie);
    module.exports = cookies.auth
}, {"cookie-stripped-of-signatures": 276}], 34: [function (require, module, exports) {
    var WPCOM = require("wpcom"), debug = require("debug")("notifications:wp"), config = require("config");
    WPCOM = require("wpcom-undocumented")(WPCOM);
    if ("xhr+cors" === config("api_transport")) {
        var token = require("token");
        var wpcom = WPCOM(token)
    } else {
        var wpcom = WPCOM();
        wpcom.request = require("wpcom-proxy-request");
        wpcom.request({metaAPI: {accessAllUsersBlogs: true}}, function (error) {
            if (error) {
                throw error
            }
            debug('Proxy now running in "access all user\'s blogs" mode')
        })
    }
    module.exports = wpcom
}, {config: 275, debug: 48, token: 33, wpcom: 270, "wpcom-proxy-request": 241, "wpcom-undocumented": 35}], 35: [function (require, module, exports) {
    var debug = require("debug")("notifications:wpcom-undocumented");
    var Undocumented = require("./lib/undocumented");
    module.exports = function (WPCOM) {
        debug("Extending wpcom with undocumented endpoints.");
        WPCOM.prototype.undocumented = function () {
            return new Undocumented(this)
        };
        WPCOM.prototype.bumpStat = function (group, name) {
            var uriComponent = "";
            if (typeof group === undefined) {
                return
            }
            if (typeof group === "object") {
                for (var key in group) {
                    if (typeof group[key] === "string") {
                        uriComponent += "&x_" + encodeURIComponent(key) + "=" + encodeURIComponent(group[key])
                    }
                }
                debug("Bumping stats %o", group)
            } else if (typeof group === "string" && typeof name === "string") {
                uriComponent = "&x_" + encodeURIComponent(group) + "=" + encodeURIComponent(name);
                debug("Bumping stat %s/%s", group, name)
            }
            if (uriComponent.length) {
                (new Image).src = document.location.protocol + "//pixel.wp.com/g.gif?v=wpcom-no-pv" + uriComponent + "&baba=" + Math.random()
            }
        };
        return WPCOM
    }
}, {"./lib/undocumented": 38, debug: 48}], 36: [function (require, module, exports) {
    var debug = require("debug")("notifications:wpcom-undocumented:notifications");

    function UndocumentedNotifications(wpcom) {
        if (!(this instanceof UndocumentedNotifications)) {
            return new UndocumentedNotifications(wpcom)
        }
        this.wpcom = wpcom
    }

    UndocumentedNotifications.prototype.list = function (query, fn) {
        var path = "/notifications/";
        debug(path, query, "query");
        this.wpcom.sendRequest({path: path, apiVersion: "1.1"}, query, null, fn)
    };
    UndocumentedNotifications.prototype.get = function (note_id, query, fn) {
        var path = "/notifications/" + note_id;
        debug(path, query, "query");
        this.wpcom.sendRequest({path: path, apiVersion: "1.1"}, query, null, fn)
    };
    UndocumentedNotifications.prototype.seen = function (timestamp, fn) {
        var path = "/notifications/seen";
        debug(path, timestamp, "query");
        this.wpcom.sendRequest({path: path, method: "POST"}, null, {time: timestamp}, fn)
    };
    UndocumentedNotifications.prototype.read = function (id, status, fn) {
        var path = "/notifications/read";
        debug(path, id, status, "query");
        var body = {counts: {}};
        body.counts[id] = status ? 9999 : -1;
        this.wpcom.sendRequest({path: path, method: "POST"}, null, body, fn)
    };
    module.exports = UndocumentedNotifications
}, {debug: 48}], 37: [function (require, module, exports) {
    var debug = require("debug")("notifications:wpcom-undocumented:simperium-token");

    function UndocumentedSimperiumToken(wpcom) {
        if (!(this instanceof UndocumentedSimperiumToken)) {
            return new UndocumentedSimperiumToken(wpcom)
        }
        this.wpcom = wpcom
    }

    UndocumentedSimperiumToken.prototype.add = function (body, fn) {
        var path = "/me/simperium-tokens/new";
        body = "string" == typeof body ? {api_key: body} : body;
        debug(path, "query");
        this.wpcom.sendRequest({path: path, method: "post"}, null, body, fn)
    };
    module.exports = UndocumentedSimperiumToken
}, {debug: 48}], 38: [function (require, module, exports) {
    var debug = require("debug")("notifications:wpcom-undocumented:undocumented");
    var SimperiumToken = require("./simperium-token");
    var Notifications = require("./notifications");
    var UserSuggestions = require("./user-suggestions");

    function Undocumented(wpcom) {
        if (!(this instanceof Undocumented)) {
            return new Undocumented(wpcom)
        }
        this.wpcom = wpcom
    }

    Undocumented.prototype.simperiumToken = function () {
        return new SimperiumToken(this.wpcom)
    };
    Undocumented.prototype.notifications = function () {
        return new Notifications(this.wpcom)
    };
    Undocumented.prototype.userSuggestions = function () {
        return new UserSuggestions(this.wpcom)
    };
    module.exports = Undocumented
}, {"./notifications": 36, "./simperium-token": 37, "./user-suggestions": 39, debug: 48}], 39: [function (require, module, exports) {
    var debug = require("debug")("notifications:wpcom-undocumented:user-suggestions");

    function UndocumentedUserSuggestions(wpcom) {
        if (!(this instanceof UndocumentedUserSuggestions)) {
            return new UndocumentedUserSuggestions(wpcom)
        }
        this.wpcom = wpcom
    }

    UndocumentedUserSuggestions.prototype.get = function (query, fn) {
        var path = "/users/suggest";
        debug(path, query, "query");
        this.wpcom.sendRequest({path: path, apiVersion: "1"}, query, null, fn)
    };
    module.exports = UndocumentedUserSuggestions
}, {debug: 48}], 40: [function (require, module, exports) {
    var base64 = require("base64-js");
    var ieee754 = require("ieee754");
    var isArray = require("is-array");
    exports.Buffer = Buffer;
    exports.SlowBuffer = Buffer;
    exports.INSPECT_MAX_BYTES = 50;
    Buffer.poolSize = 8192;
    var kMaxLength = 1073741823;
    Buffer.TYPED_ARRAY_SUPPORT = function () {
        try {
            var buf = new ArrayBuffer(0);
            var arr = new Uint8Array(buf);
            arr.foo = function () {
                return 42
            };
            return 42 === arr.foo() && typeof arr.subarray === "function" && new Uint8Array(1).subarray(1, 1).byteLength === 0
        } catch (e) {
            return false
        }
    }();
    function Buffer(subject, encoding, noZero) {
        if (!(this instanceof Buffer))return new Buffer(subject, encoding, noZero);
        var type = typeof subject;
        var length;
        if (type === "number")length = subject > 0 ? subject >>> 0 : 0; else if (type === "string") {
            if (encoding === "base64")subject = base64clean(subject);
            length = Buffer.byteLength(subject, encoding)
        } else if (type === "object" && subject !== null) {
            if (subject.type === "Buffer" && isArray(subject.data))subject = subject.data;
            length = +subject.length > 0 ? Math.floor(+subject.length) : 0
        } else throw new TypeError("must start with number, buffer, array or string");
        if (this.length > kMaxLength)throw new RangeError("Attempt to allocate Buffer larger than maximum " + "size: 0x" + kMaxLength.toString(16) + " bytes");
        var buf;
        if (Buffer.TYPED_ARRAY_SUPPORT) {
            buf = Buffer._augment(new Uint8Array(length))
        } else {
            buf = this;
            buf.length = length;
            buf._isBuffer = true
        }
        var i;
        if (Buffer.TYPED_ARRAY_SUPPORT && typeof subject.byteLength === "number") {
            buf._set(subject)
        } else if (isArrayish(subject)) {
            if (Buffer.isBuffer(subject)) {
                for (i = 0; i < length; i++)buf[i] = subject.readUInt8(i)
            } else {
                for (i = 0; i < length; i++)buf[i] = (subject[i] % 256 + 256) % 256
            }
        } else if (type === "string") {
            buf.write(subject, 0, encoding)
        } else if (type === "number" && !Buffer.TYPED_ARRAY_SUPPORT && !noZero) {
            for (i = 0; i < length; i++) {
                buf[i] = 0
            }
        }
        return buf
    }

    Buffer.isBuffer = function (b) {
        return!!(b != null && b._isBuffer)
    };
    Buffer.compare = function (a, b) {
        if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b))throw new TypeError("Arguments must be Buffers");
        var x = a.length;
        var y = b.length;
        for (var i = 0, len = Math.min(x, y); i < len && a[i] === b[i]; i++) {
        }
        if (i !== len) {
            x = a[i];
            y = b[i]
        }
        if (x < y)return-1;
        if (y < x)return 1;
        return 0
    };
    Buffer.isEncoding = function (encoding) {
        switch (String(encoding).toLowerCase()) {
            case"hex":
            case"utf8":
            case"utf-8":
            case"ascii":
            case"binary":
            case"base64":
            case"raw":
            case"ucs2":
            case"ucs-2":
            case"utf16le":
            case"utf-16le":
                return true;
            default:
                return false
        }
    };
    Buffer.concat = function (list, totalLength) {
        if (!isArray(list))throw new TypeError("Usage: Buffer.concat(list[, length])");
        if (list.length === 0) {
            return new Buffer(0)
        } else if (list.length === 1) {
            return list[0]
        }
        var i;
        if (totalLength === undefined) {
            totalLength = 0;
            for (i = 0; i < list.length; i++) {
                totalLength += list[i].length
            }
        }
        var buf = new Buffer(totalLength);
        var pos = 0;
        for (i = 0; i < list.length; i++) {
            var item = list[i];
            item.copy(buf, pos);
            pos += item.length
        }
        return buf
    };
    Buffer.byteLength = function (str, encoding) {
        var ret;
        str = str + "";
        switch (encoding || "utf8") {
            case"ascii":
            case"binary":
            case"raw":
                ret = str.length;
                break;
            case"ucs2":
            case"ucs-2":
            case"utf16le":
            case"utf-16le":
                ret = str.length * 2;
                break;
            case"hex":
                ret = str.length >>> 1;
                break;
            case"utf8":
            case"utf-8":
                ret = utf8ToBytes(str).length;
                break;
            case"base64":
                ret = base64ToBytes(str).length;
                break;
            default:
                ret = str.length
        }
        return ret
    };
    Buffer.prototype.length = undefined;
    Buffer.prototype.parent = undefined;
    Buffer.prototype.toString = function (encoding, start, end) {
        var loweredCase = false;
        start = start >>> 0;
        end = end === undefined || end === Infinity ? this.length : end >>> 0;
        if (!encoding)encoding = "utf8";
        if (start < 0)start = 0;
        if (end > this.length)end = this.length;
        if (end <= start)return"";
        while (true) {
            switch (encoding) {
                case"hex":
                    return hexSlice(this, start, end);
                case"utf8":
                case"utf-8":
                    return utf8Slice(this, start, end);
                case"ascii":
                    return asciiSlice(this, start, end);
                case"binary":
                    return binarySlice(this, start, end);
                case"base64":
                    return base64Slice(this, start, end);
                case"ucs2":
                case"ucs-2":
                case"utf16le":
                case"utf-16le":
                    return utf16leSlice(this, start, end);
                default:
                    if (loweredCase)throw new TypeError("Unknown encoding: " + encoding);
                    encoding = (encoding + "").toLowerCase();
                    loweredCase = true
            }
        }
    };
    Buffer.prototype.equals = function (b) {
        if (!Buffer.isBuffer(b))throw new TypeError("Argument must be a Buffer");
        return Buffer.compare(this, b) === 0
    };
    Buffer.prototype.inspect = function () {
        var str = "";
        var max = exports.INSPECT_MAX_BYTES;
        if (this.length > 0) {
            str = this.toString("hex", 0, max).match(/.{2}/g).join(" ");
            if (this.length > max)str += " ... "
        }
        return"<Buffer " + str + ">"
    };
    Buffer.prototype.compare = function (b) {
        if (!Buffer.isBuffer(b))throw new TypeError("Argument must be a Buffer");
        return Buffer.compare(this, b)
    };
    Buffer.prototype.get = function (offset) {
        console.log(".get() is deprecated. Access using array indexes instead.");
        return this.readUInt8(offset)
    };
    Buffer.prototype.set = function (v, offset) {
        console.log(".set() is deprecated. Access using array indexes instead.");
        return this.writeUInt8(v, offset)
    };
    function hexWrite(buf, string, offset, length) {
        offset = Number(offset) || 0;
        var remaining = buf.length - offset;
        if (!length) {
            length = remaining
        } else {
            length = Number(length);
            if (length > remaining) {
                length = remaining
            }
        }
        var strLen = string.length;
        if (strLen % 2 !== 0)throw new Error("Invalid hex string");
        if (length > strLen / 2) {
            length = strLen / 2
        }
        for (var i = 0; i < length; i++) {
            var byte = parseInt(string.substr(i * 2, 2), 16);
            if (isNaN(byte))throw new Error("Invalid hex string");
            buf[offset + i] = byte
        }
        return i
    }

    function utf8Write(buf, string, offset, length) {
        var charsWritten = blitBuffer(utf8ToBytes(string), buf, offset, length);
        return charsWritten
    }

    function asciiWrite(buf, string, offset, length) {
        var charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length);
        return charsWritten
    }

    function binaryWrite(buf, string, offset, length) {
        return asciiWrite(buf, string, offset, length)
    }

    function base64Write(buf, string, offset, length) {
        var charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length);
        return charsWritten
    }

    function utf16leWrite(buf, string, offset, length) {
        var charsWritten = blitBuffer(utf16leToBytes(string), buf, offset, length);
        return charsWritten
    }

    Buffer.prototype.write = function (string, offset, length, encoding) {
        if (isFinite(offset)) {
            if (!isFinite(length)) {
                encoding = length;
                length = undefined
            }
        } else {
            var swap = encoding;
            encoding = offset;
            offset = length;
            length = swap
        }
        offset = Number(offset) || 0;
        var remaining = this.length - offset;
        if (!length) {
            length = remaining
        } else {
            length = Number(length);
            if (length > remaining) {
                length = remaining
            }
        }
        encoding = String(encoding || "utf8").toLowerCase();
        var ret;
        switch (encoding) {
            case"hex":
                ret = hexWrite(this, string, offset, length);
                break;
            case"utf8":
            case"utf-8":
                ret = utf8Write(this, string, offset, length);
                break;
            case"ascii":
                ret = asciiWrite(this, string, offset, length);
                break;
            case"binary":
                ret = binaryWrite(this, string, offset, length);
                break;
            case"base64":
                ret = base64Write(this, string, offset, length);
                break;
            case"ucs2":
            case"ucs-2":
            case"utf16le":
            case"utf-16le":
                ret = utf16leWrite(this, string, offset, length);
                break;
            default:
                throw new TypeError("Unknown encoding: " + encoding)
        }
        return ret
    };
    Buffer.prototype.toJSON = function () {
        return{type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0)}
    };
    function base64Slice(buf, start, end) {
        if (start === 0 && end === buf.length) {
            return base64.fromByteArray(buf)
        } else {
            return base64.fromByteArray(buf.slice(start, end))
        }
    }

    function utf8Slice(buf, start, end) {
        var res = "";
        var tmp = "";
        end = Math.min(buf.length, end);
        for (var i = start; i < end; i++) {
            if (buf[i] <= 127) {
                res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i]);
                tmp = ""
            } else {
                tmp += "%" + buf[i].toString(16)
            }
        }
        return res + decodeUtf8Char(tmp)
    }

    function asciiSlice(buf, start, end) {
        var ret = "";
        end = Math.min(buf.length, end);
        for (var i = start; i < end; i++) {
            ret += String.fromCharCode(buf[i])
        }
        return ret
    }

    function binarySlice(buf, start, end) {
        return asciiSlice(buf, start, end)
    }

    function hexSlice(buf, start, end) {
        var len = buf.length;
        if (!start || start < 0)start = 0;
        if (!end || end < 0 || end > len)end = len;
        var out = "";
        for (var i = start; i < end; i++) {
            out += toHex(buf[i])
        }
        return out
    }

    function utf16leSlice(buf, start, end) {
        var bytes = buf.slice(start, end);
        var res = "";
        for (var i = 0; i < bytes.length; i += 2) {
            res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
        }
        return res
    }

    Buffer.prototype.slice = function (start, end) {
        var len = this.length;
        start = ~~start;
        end = end === undefined ? len : ~~end;
        if (start < 0) {
            start += len;
            if (start < 0)start = 0
        } else if (start > len) {
            start = len
        }
        if (end < 0) {
            end += len;
            if (end < 0)end = 0
        } else if (end > len) {
            end = len
        }
        if (end < start)end = start;
        if (Buffer.TYPED_ARRAY_SUPPORT) {
            return Buffer._augment(this.subarray(start, end))
        } else {
            var sliceLen = end - start;
            var newBuf = new Buffer(sliceLen, undefined, true);
            for (var i = 0; i < sliceLen; i++) {
                newBuf[i] = this[i + start]
            }
            return newBuf
        }
    };
    function checkOffset(offset, ext, length) {
        if (offset % 1 !== 0 || offset < 0)throw new RangeError("offset is not uint");
        if (offset + ext > length)throw new RangeError("Trying to access beyond buffer length")
    }

    Buffer.prototype.readUInt8 = function (offset, noAssert) {
        if (!noAssert)checkOffset(offset, 1, this.length);
        return this[offset]
    };
    Buffer.prototype.readUInt16LE = function (offset, noAssert) {
        if (!noAssert)checkOffset(offset, 2, this.length);
        return this[offset] | this[offset + 1] << 8
    };
    Buffer.prototype.readUInt16BE = function (offset, noAssert) {
        if (!noAssert)checkOffset(offset, 2, this.length);
        return this[offset] << 8 | this[offset + 1]
    };
    Buffer.prototype.readUInt32LE = function (offset, noAssert) {
        if (!noAssert)checkOffset(offset, 4, this.length);
        return(this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216
    };
    Buffer.prototype.readUInt32BE = function (offset, noAssert) {
        if (!noAssert)checkOffset(offset, 4, this.length);
        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3])
    };
    Buffer.prototype.readInt8 = function (offset, noAssert) {
        if (!noAssert)checkOffset(offset, 1, this.length);
        if (!(this[offset] & 128))return this[offset];
        return(255 - this[offset] + 1) * -1
    };
    Buffer.prototype.readInt16LE = function (offset, noAssert) {
        if (!noAssert)checkOffset(offset, 2, this.length);
        var val = this[offset] | this[offset + 1] << 8;
        return val & 32768 ? val | 4294901760 : val
    };
    Buffer.prototype.readInt16BE = function (offset, noAssert) {
        if (!noAssert)checkOffset(offset, 2, this.length);
        var val = this[offset + 1] | this[offset] << 8;
        return val & 32768 ? val | 4294901760 : val
    };
    Buffer.prototype.readInt32LE = function (offset, noAssert) {
        if (!noAssert)checkOffset(offset, 4, this.length);
        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24
    };
    Buffer.prototype.readInt32BE = function (offset, noAssert) {
        if (!noAssert)checkOffset(offset, 4, this.length);
        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]
    };
    Buffer.prototype.readFloatLE = function (offset, noAssert) {
        if (!noAssert)checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, true, 23, 4)
    };
    Buffer.prototype.readFloatBE = function (offset, noAssert) {
        if (!noAssert)checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, false, 23, 4)
    };
    Buffer.prototype.readDoubleLE = function (offset, noAssert) {
        if (!noAssert)checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, true, 52, 8)
    };
    Buffer.prototype.readDoubleBE = function (offset, noAssert) {
        if (!noAssert)checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, false, 52, 8)
    };
    function checkInt(buf, value, offset, ext, max, min) {
        if (!Buffer.isBuffer(buf))throw new TypeError("buffer must be a Buffer instance");
        if (value > max || value < min)throw new TypeError("value is out of bounds");
        if (offset + ext > buf.length)throw new TypeError("index out of range")
    }

    Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)checkInt(this, value, offset, 1, 255, 0);
        if (!Buffer.TYPED_ARRAY_SUPPORT)value = Math.floor(value);
        this[offset] = value;
        return offset + 1
    };
    function objectWriteUInt16(buf, value, offset, littleEndian) {
        if (value < 0)value = 65535 + value + 1;
        for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
            buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8
        }
    }

    Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)checkInt(this, value, offset, 2, 65535, 0);
        if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value;
            this[offset + 1] = value >>> 8
        } else objectWriteUInt16(this, value, offset, true);
        return offset + 2
    };
    Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)checkInt(this, value, offset, 2, 65535, 0);
        if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value >>> 8;
            this[offset + 1] = value
        } else objectWriteUInt16(this, value, offset, false);
        return offset + 2
    };
    function objectWriteUInt32(buf, value, offset, littleEndian) {
        if (value < 0)value = 4294967295 + value + 1;
        for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
            buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 255
        }
    }

    Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)checkInt(this, value, offset, 4, 4294967295, 0);
        if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset + 3] = value >>> 24;
            this[offset + 2] = value >>> 16;
            this[offset + 1] = value >>> 8;
            this[offset] = value
        } else objectWriteUInt32(this, value, offset, true);
        return offset + 4
    };
    Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)checkInt(this, value, offset, 4, 4294967295, 0);
        if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value >>> 24;
            this[offset + 1] = value >>> 16;
            this[offset + 2] = value >>> 8;
            this[offset + 3] = value
        } else objectWriteUInt32(this, value, offset, false);
        return offset + 4
    };
    Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)checkInt(this, value, offset, 1, 127, -128);
        if (!Buffer.TYPED_ARRAY_SUPPORT)value = Math.floor(value);
        if (value < 0)value = 255 + value + 1;
        this[offset] = value;
        return offset + 1
    };
    Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)checkInt(this, value, offset, 2, 32767, -32768);
        if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value;
            this[offset + 1] = value >>> 8
        } else objectWriteUInt16(this, value, offset, true);
        return offset + 2
    };
    Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)checkInt(this, value, offset, 2, 32767, -32768);
        if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value >>> 8;
            this[offset + 1] = value
        } else objectWriteUInt16(this, value, offset, false);
        return offset + 2
    };
    Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value;
            this[offset + 1] = value >>> 8;
            this[offset + 2] = value >>> 16;
            this[offset + 3] = value >>> 24
        } else objectWriteUInt32(this, value, offset, true);
        return offset + 4
    };
    Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (value < 0)value = 4294967295 + value + 1;
        if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value >>> 24;
            this[offset + 1] = value >>> 16;
            this[offset + 2] = value >>> 8;
            this[offset + 3] = value
        } else objectWriteUInt32(this, value, offset, false);
        return offset + 4
    };
    function checkIEEE754(buf, value, offset, ext, max, min) {
        if (value > max || value < min)throw new TypeError("value is out of bounds");
        if (offset + ext > buf.length)throw new TypeError("index out of range")
    }

    function writeFloat(buf, value, offset, littleEndian, noAssert) {
        if (!noAssert)checkIEEE754(buf, value, offset, 4, 3.4028234663852886e38, -3.4028234663852886e38);
        ieee754.write(buf, value, offset, littleEndian, 23, 4);
        return offset + 4
    }

    Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert)
    };
    Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert)
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
        if (!noAssert)checkIEEE754(buf, value, offset, 8, 1.7976931348623157e308, -1.7976931348623157e308);
        ieee754.write(buf, value, offset, littleEndian, 52, 8);
        return offset + 8
    }

    Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert)
    };
    Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert)
    };
    Buffer.prototype.copy = function (target, target_start, start, end) {
        var source = this;
        if (!start)start = 0;
        if (!end && end !== 0)end = this.length;
        if (!target_start)target_start = 0;
        if (end === start)return;
        if (target.length === 0 || source.length === 0)return;
        if (end < start)throw new TypeError("sourceEnd < sourceStart");
        if (target_start < 0 || target_start >= target.length)throw new TypeError("targetStart out of bounds");
        if (start < 0 || start >= source.length)throw new TypeError("sourceStart out of bounds");
        if (end < 0 || end > source.length)throw new TypeError("sourceEnd out of bounds");
        if (end > this.length)end = this.length;
        if (target.length - target_start < end - start)end = target.length - target_start + start;
        var len = end - start;
        if (len < 1e3 || !Buffer.TYPED_ARRAY_SUPPORT) {
            for (var i = 0; i < len; i++) {
                target[i + target_start] = this[i + start]
            }
        } else {
            target._set(this.subarray(start, start + len), target_start)
        }
    };
    Buffer.prototype.fill = function (value, start, end) {
        if (!value)value = 0;
        if (!start)start = 0;
        if (!end)end = this.length;
        if (end < start)throw new TypeError("end < start");
        if (end === start)return;
        if (this.length === 0)return;
        if (start < 0 || start >= this.length)throw new TypeError("start out of bounds");
        if (end < 0 || end > this.length)throw new TypeError("end out of bounds");
        var i;
        if (typeof value === "number") {
            for (i = start; i < end; i++) {
                this[i] = value
            }
        } else {
            var bytes = utf8ToBytes(value.toString());
            var len = bytes.length;
            for (i = start; i < end; i++) {
                this[i] = bytes[i % len]
            }
        }
        return this
    };
    Buffer.prototype.toArrayBuffer = function () {
        if (typeof Uint8Array !== "undefined") {
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                return new Buffer(this).buffer
            } else {
                var buf = new Uint8Array(this.length);
                for (var i = 0, len = buf.length; i < len; i += 1) {
                    buf[i] = this[i]
                }
                return buf.buffer
            }
        } else {
            throw new TypeError("Buffer.toArrayBuffer not supported in this browser")
        }
    };
    var BP = Buffer.prototype;
    Buffer._augment = function (arr) {
        arr.constructor = Buffer;
        arr._isBuffer = true;
        arr._get = arr.get;
        arr._set = arr.set;
        arr.get = BP.get;
        arr.set = BP.set;
        arr.write = BP.write;
        arr.toString = BP.toString;
        arr.toLocaleString = BP.toString;
        arr.toJSON = BP.toJSON;
        arr.equals = BP.equals;
        arr.compare = BP.compare;
        arr.copy = BP.copy;
        arr.slice = BP.slice;
        arr.readUInt8 = BP.readUInt8;
        arr.readUInt16LE = BP.readUInt16LE;
        arr.readUInt16BE = BP.readUInt16BE;
        arr.readUInt32LE = BP.readUInt32LE;
        arr.readUInt32BE = BP.readUInt32BE;
        arr.readInt8 = BP.readInt8;
        arr.readInt16LE = BP.readInt16LE;
        arr.readInt16BE = BP.readInt16BE;
        arr.readInt32LE = BP.readInt32LE;
        arr.readInt32BE = BP.readInt32BE;
        arr.readFloatLE = BP.readFloatLE;
        arr.readFloatBE = BP.readFloatBE;
        arr.readDoubleLE = BP.readDoubleLE;
        arr.readDoubleBE = BP.readDoubleBE;
        arr.writeUInt8 = BP.writeUInt8;
        arr.writeUInt16LE = BP.writeUInt16LE;
        arr.writeUInt16BE = BP.writeUInt16BE;
        arr.writeUInt32LE = BP.writeUInt32LE;
        arr.writeUInt32BE = BP.writeUInt32BE;
        arr.writeInt8 = BP.writeInt8;
        arr.writeInt16LE = BP.writeInt16LE;
        arr.writeInt16BE = BP.writeInt16BE;
        arr.writeInt32LE = BP.writeInt32LE;
        arr.writeInt32BE = BP.writeInt32BE;
        arr.writeFloatLE = BP.writeFloatLE;
        arr.writeFloatBE = BP.writeFloatBE;
        arr.writeDoubleLE = BP.writeDoubleLE;
        arr.writeDoubleBE = BP.writeDoubleBE;
        arr.fill = BP.fill;
        arr.inspect = BP.inspect;
        arr.toArrayBuffer = BP.toArrayBuffer;
        return arr
    };
    var INVALID_BASE64_RE = /[^+\/0-9A-z]/g;

    function base64clean(str) {
        str = stringtrim(str).replace(INVALID_BASE64_RE, "");
        while (str.length % 4 !== 0) {
            str = str + "="
        }
        return str
    }

    function stringtrim(str) {
        if (str.trim)return str.trim();
        return str.replace(/^\s+|\s+$/g, "")
    }

    function isArrayish(subject) {
        return isArray(subject) || Buffer.isBuffer(subject) || subject && typeof subject === "object" && typeof subject.length === "number"
    }

    function toHex(n) {
        if (n < 16)return"0" + n.toString(16);
        return n.toString(16)
    }

    function utf8ToBytes(str) {
        var byteArray = [];
        for (var i = 0; i < str.length; i++) {
            var b = str.charCodeAt(i);
            if (b <= 127) {
                byteArray.push(b)
            } else {
                var start = i;
                if (b >= 55296 && b <= 57343)i++;
                var h = encodeURIComponent(str.slice(start, i + 1)).substr(1).split("%");
                for (var j = 0; j < h.length; j++) {
                    byteArray.push(parseInt(h[j], 16))
                }
            }
        }
        return byteArray
    }

    function asciiToBytes(str) {
        var byteArray = [];
        for (var i = 0; i < str.length; i++) {
            byteArray.push(str.charCodeAt(i) & 255)
        }
        return byteArray
    }

    function utf16leToBytes(str) {
        var c, hi, lo;
        var byteArray = [];
        for (var i = 0; i < str.length; i++) {
            c = str.charCodeAt(i);
            hi = c >> 8;
            lo = c % 256;
            byteArray.push(lo);
            byteArray.push(hi)
        }
        return byteArray
    }

    function base64ToBytes(str) {
        return base64.toByteArray(str)
    }

    function blitBuffer(src, dst, offset, length) {
        for (var i = 0; i < length; i++) {
            if (i + offset >= dst.length || i >= src.length)break;
            dst[i + offset] = src[i]
        }
        return i
    }

    function decodeUtf8Char(str) {
        try {
            return decodeURIComponent(str)
        } catch (err) {
            return String.fromCharCode(65533)
        }
    }
}, {"base64-js": 41, ieee754: 42, "is-array": 43}], 41: [function (require, module, exports) {
    var lookup = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    (function (exports) {
        "use strict";
        var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
        var PLUS = "+".charCodeAt(0);
        var SLASH = "/".charCodeAt(0);
        var NUMBER = "0".charCodeAt(0);
        var LOWER = "a".charCodeAt(0);
        var UPPER = "A".charCodeAt(0);

        function decode(elt) {
            var code = elt.charCodeAt(0);
            if (code === PLUS)return 62;
            if (code === SLASH)return 63;
            if (code < NUMBER)return-1;
            if (code < NUMBER + 10)return code - NUMBER + 26 + 26;
            if (code < UPPER + 26)return code - UPPER;
            if (code < LOWER + 26)return code - LOWER + 26
        }

        function b64ToByteArray(b64) {
            var i, j, l, tmp, placeHolders, arr;
            if (b64.length % 4 > 0) {
                throw new Error("Invalid string. Length must be a multiple of 4")
            }
            var len = b64.length;
            placeHolders = "=" === b64.charAt(len - 2) ? 2 : "=" === b64.charAt(len - 1) ? 1 : 0;
            arr = new Arr(b64.length * 3 / 4 - placeHolders);
            l = placeHolders > 0 ? b64.length - 4 : b64.length;
            var L = 0;

            function push(v) {
                arr[L++] = v
            }

            for (i = 0, j = 0; i < l; i += 4, j += 3) {
                tmp = decode(b64.charAt(i)) << 18 | decode(b64.charAt(i + 1)) << 12 | decode(b64.charAt(i + 2)) << 6 | decode(b64.charAt(i + 3));
                push((tmp & 16711680) >> 16);
                push((tmp & 65280) >> 8);
                push(tmp & 255)
            }
            if (placeHolders === 2) {
                tmp = decode(b64.charAt(i)) << 2 | decode(b64.charAt(i + 1)) >> 4;
                push(tmp & 255)
            } else if (placeHolders === 1) {
                tmp = decode(b64.charAt(i)) << 10 | decode(b64.charAt(i + 1)) << 4 | decode(b64.charAt(i + 2)) >> 2;
                push(tmp >> 8 & 255);
                push(tmp & 255)
            }
            return arr
        }

        function uint8ToBase64(uint8) {
            var i, extraBytes = uint8.length % 3, output = "", temp, length;

            function encode(num) {
                return lookup.charAt(num)
            }

            function tripletToBase64(num) {
                return encode(num >> 18 & 63) + encode(num >> 12 & 63) + encode(num >> 6 & 63) + encode(num & 63)
            }

            for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
                temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
                output += tripletToBase64(temp)
            }
            switch (extraBytes) {
                case 1:
                    temp = uint8[uint8.length - 1];
                    output += encode(temp >> 2);
                    output += encode(temp << 4 & 63);
                    output += "==";
                    break;
                case 2:
                    temp = (uint8[uint8.length - 2] << 8) + uint8[uint8.length - 1];
                    output += encode(temp >> 10);
                    output += encode(temp >> 4 & 63);
                    output += encode(temp << 2 & 63);
                    output += "=";
                    break
            }
            return output
        }

        exports.toByteArray = b64ToByteArray;
        exports.fromByteArray = uint8ToBase64
    })(typeof exports === "undefined" ? this.base64js = {} : exports)
}, {}], 42: [function (require, module, exports) {
    exports.read = function (buffer, offset, isLE, mLen, nBytes) {
        var e, m, eLen = nBytes * 8 - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, nBits = -7, i = isLE ? nBytes - 1 : 0, d = isLE ? -1 : 1, s = buffer[offset + i];
        i += d;
        e = s & (1 << -nBits) - 1;
        s >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);
        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);
        if (e === 0) {
            e = 1 - eBias
        } else if (e === eMax) {
            return m ? NaN : (s ? -1 : 1) * Infinity
        } else {
            m = m + Math.pow(2, mLen);
            e = e - eBias
        }
        return(s ? -1 : 1) * m * Math.pow(2, e - mLen)
    };
    exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c, eLen = nBytes * 8 - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, i = isLE ? 0 : nBytes - 1, d = isLE ? 1 : -1, s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
            m = isNaN(value) ? 1 : 0;
            e = eMax
        } else {
            e = Math.floor(Math.log(value) / Math.LN2);
            if (value * (c = Math.pow(2, -e)) < 1) {
                e--;
                c *= 2
            }
            if (e + eBias >= 1) {
                value += rt / c
            } else {
                value += rt * Math.pow(2, 1 - eBias)
            }
            if (value * c >= 2) {
                e++;
                c /= 2
            }
            if (e + eBias >= eMax) {
                m = 0;
                e = eMax
            } else if (e + eBias >= 1) {
                m = (value * c - 1) * Math.pow(2, mLen);
                e = e + eBias
            } else {
                m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                e = 0
            }
        }
        for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8);
        e = e << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8);
        buffer[offset + i - d] |= s * 128
    }
}, {}], 43: [function (require, module, exports) {
    var isArray = Array.isArray;
    var str = Object.prototype.toString;
    module.exports = isArray || function (val) {
        return!!val && "[object Array]" == str.call(val)
    }
}, {}], 44: [function (require, module, exports) {
    function EventEmitter() {
        this._events = this._events || {};
        this._maxListeners = this._maxListeners || undefined
    }

    module.exports = EventEmitter;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.prototype._events = undefined;
    EventEmitter.prototype._maxListeners = undefined;
    EventEmitter.defaultMaxListeners = 10;
    EventEmitter.prototype.setMaxListeners = function (n) {
        if (!isNumber(n) || n < 0 || isNaN(n))throw TypeError("n must be a positive number");
        this._maxListeners = n;
        return this
    };
    EventEmitter.prototype.emit = function (type) {
        var er, handler, len, args, i, listeners;
        if (!this._events)this._events = {};
        if (type === "error") {
            if (!this._events.error || isObject(this._events.error) && !this._events.error.length) {
                er = arguments[1];
                if (er instanceof Error) {
                    throw er
                }
                throw TypeError('Uncaught, unspecified "error" event.')
            }
        }
        handler = this._events[type];
        if (isUndefined(handler))return false;
        if (isFunction(handler)) {
            switch (arguments.length) {
                case 1:
                    handler.call(this);
                    break;
                case 2:
                    handler.call(this, arguments[1]);
                    break;
                case 3:
                    handler.call(this, arguments[1], arguments[2]);
                    break;
                default:
                    len = arguments.length;
                    args = new Array(len - 1);
                    for (i = 1; i < len; i++)args[i - 1] = arguments[i];
                    handler.apply(this, args)
            }
        } else if (isObject(handler)) {
            len = arguments.length;
            args = new Array(len - 1);
            for (i = 1; i < len; i++)args[i - 1] = arguments[i];
            listeners = handler.slice();
            len = listeners.length;
            for (i = 0; i < len; i++)listeners[i].apply(this, args)
        }
        return true
    };
    EventEmitter.prototype.addListener = function (type, listener) {
        var m;
        if (!isFunction(listener))throw TypeError("listener must be a function");
        if (!this._events)this._events = {};
        if (this._events.newListener)this.emit("newListener", type, isFunction(listener.listener) ? listener.listener : listener);
        if (!this._events[type])this._events[type] = listener; else if (isObject(this._events[type]))this._events[type].push(listener); else this._events[type] = [this._events[type], listener];
        if (isObject(this._events[type]) && !this._events[type].warned) {
            var m;
            if (!isUndefined(this._maxListeners)) {
                m = this._maxListeners
            } else {
                m = EventEmitter.defaultMaxListeners
            }
            if (m && m > 0 && this._events[type].length > m) {
                this._events[type].warned = true;
                console.error("(node) warning: possible EventEmitter memory " + "leak detected. %d listeners added. " + "Use emitter.setMaxListeners() to increase limit.", this._events[type].length);
                if (typeof console.trace === "function") {
                    console.trace()
                }
            }
        }
        return this
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.once = function (type, listener) {
        if (!isFunction(listener))throw TypeError("listener must be a function");
        var fired = false;

        function g() {
            this.removeListener(type, g);
            if (!fired) {
                fired = true;
                listener.apply(this, arguments)
            }
        }

        g.listener = listener;
        this.on(type, g);
        return this
    };
    EventEmitter.prototype.removeListener = function (type, listener) {
        var list, position, length, i;
        if (!isFunction(listener))throw TypeError("listener must be a function");
        if (!this._events || !this._events[type])return this;
        list = this._events[type];
        length = list.length;
        position = -1;
        if (list === listener || isFunction(list.listener) && list.listener === listener) {
            delete this._events[type];
            if (this._events.removeListener)this.emit("removeListener", type, listener)
        } else if (isObject(list)) {
            for (i = length; i-- > 0;) {
                if (list[i] === listener || list[i].listener && list[i].listener === listener) {
                    position = i;
                    break
                }
            }
            if (position < 0)return this;
            if (list.length === 1) {
                list.length = 0;
                delete this._events[type]
            } else {
                list.splice(position, 1)
            }
            if (this._events.removeListener)this.emit("removeListener", type, listener)
        }
        return this
    };
    EventEmitter.prototype.removeAllListeners = function (type) {
        var key, listeners;
        if (!this._events)return this;
        if (!this._events.removeListener) {
            if (arguments.length === 0)this._events = {}; else if (this._events[type])delete this._events[type];
            return this
        }
        if (arguments.length === 0) {
            for (key in this._events) {
                if (key === "removeListener")continue;
                this.removeAllListeners(key)
            }
            this.removeAllListeners("removeListener");
            this._events = {};
            return this
        }
        listeners = this._events[type];
        if (isFunction(listeners)) {
            this.removeListener(type, listeners)
        } else {
            while (listeners.length)this.removeListener(type, listeners[listeners.length - 1])
        }
        delete this._events[type];
        return this
    };
    EventEmitter.prototype.listeners = function (type) {
        var ret;
        if (!this._events || !this._events[type])ret = []; else if (isFunction(this._events[type]))ret = [this._events[type]]; else ret = this._events[type].slice();
        return ret
    };
    EventEmitter.listenerCount = function (emitter, type) {
        var ret;
        if (!emitter._events || !emitter._events[type])ret = 0; else if (isFunction(emitter._events[type]))ret = 1; else ret = emitter._events[type].length;
        return ret
    };
    function isFunction(arg) {
        return typeof arg === "function"
    }

    function isNumber(arg) {
        return typeof arg === "number"
    }

    function isObject(arg) {
        return typeof arg === "object" && arg !== null
    }

    function isUndefined(arg) {
        return arg === void 0
    }
}, {}], 45: [function (require, module, exports) {
    (function (process) {
        function normalizeArray(parts, allowAboveRoot) {
            var up = 0;
            for (var i = parts.length - 1; i >= 0; i--) {
                var last = parts[i];
                if (last === ".") {
                    parts.splice(i, 1)
                } else if (last === "..") {
                    parts.splice(i, 1);
                    up++
                } else if (up) {
                    parts.splice(i, 1);
                    up--
                }
            }
            if (allowAboveRoot) {
                for (; up--; up) {
                    parts.unshift("..")
                }
            }
            return parts
        }

        var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
        var splitPath = function (filename) {
            return splitPathRe.exec(filename).slice(1)
        };
        exports.resolve = function () {
            var resolvedPath = "", resolvedAbsolute = false;
            for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
                var path = i >= 0 ? arguments[i] : process.cwd();
                if (typeof path !== "string") {
                    throw new TypeError("Arguments to path.resolve must be strings")
                } else if (!path) {
                    continue
                }
                resolvedPath = path + "/" + resolvedPath;
                resolvedAbsolute = path.charAt(0) === "/"
            }
            resolvedPath = normalizeArray(filter(resolvedPath.split("/"), function (p) {
                return!!p
            }), !resolvedAbsolute).join("/");
            return(resolvedAbsolute ? "/" : "") + resolvedPath || "."
        };
        exports.normalize = function (path) {
            var isAbsolute = exports.isAbsolute(path), trailingSlash = substr(path, -1) === "/";
            path = normalizeArray(filter(path.split("/"), function (p) {
                return!!p
            }), !isAbsolute).join("/");
            if (!path && !isAbsolute) {
                path = "."
            }
            if (path && trailingSlash) {
                path += "/"
            }
            return(isAbsolute ? "/" : "") + path
        };
        exports.isAbsolute = function (path) {
            return path.charAt(0) === "/"
        };
        exports.join = function () {
            var paths = Array.prototype.slice.call(arguments, 0);
            return exports.normalize(filter(paths, function (p, index) {
                if (typeof p !== "string") {
                    throw new TypeError("Arguments to path.join must be strings")
                }
                return p
            }).join("/"))
        };
        exports.relative = function (from, to) {
            from = exports.resolve(from).substr(1);
            to = exports.resolve(to).substr(1);
            function trim(arr) {
                var start = 0;
                for (; start < arr.length; start++) {
                    if (arr[start] !== "")break
                }
                var end = arr.length - 1;
                for (; end >= 0; end--) {
                    if (arr[end] !== "")break
                }
                if (start > end)return[];
                return arr.slice(start, end - start + 1)
            }

            var fromParts = trim(from.split("/"));
            var toParts = trim(to.split("/"));
            var length = Math.min(fromParts.length, toParts.length);
            var samePartsLength = length;
            for (var i = 0; i < length; i++) {
                if (fromParts[i] !== toParts[i]) {
                    samePartsLength = i;
                    break
                }
            }
            var outputParts = [];
            for (var i = samePartsLength; i < fromParts.length; i++) {
                outputParts.push("..")
            }
            outputParts = outputParts.concat(toParts.slice(samePartsLength));
            return outputParts.join("/")
        };
        exports.sep = "/";
        exports.delimiter = ":";
        exports.dirname = function (path) {
            var result = splitPath(path), root = result[0], dir = result[1];
            if (!root && !dir) {
                return"."
            }
            if (dir) {
                dir = dir.substr(0, dir.length - 1)
            }
            return root + dir
        };
        exports.basename = function (path, ext) {
            var f = splitPath(path)[2];
            if (ext && f.substr(-1 * ext.length) === ext) {
                f = f.substr(0, f.length - ext.length)
            }
            return f
        };
        exports.extname = function (path) {
            return splitPath(path)[3]
        };
        function filter(xs, f) {
            if (xs.filter)return xs.filter(f);
            var res = [];
            for (var i = 0; i < xs.length; i++) {
                if (f(xs[i], i, xs))res.push(xs[i])
            }
            return res
        }

        var substr = "ab".substr(-1) === "b" ? function (str, start, len) {
            return str.substr(start, len)
        } : function (str, start, len) {
            if (start < 0)start = str.length + start;
            return str.substr(start, len)
        }
    }).call(this, require("FWaASH"))
}, {FWaASH: 46}], 46: [function (require, module, exports) {
    var process = module.exports = {};
    process.nextTick = function () {
        var canSetImmediate = typeof window !== "undefined" && window.setImmediate;
        var canPost = typeof window !== "undefined" && window.postMessage && window.addEventListener;
        if (canSetImmediate) {
            return function (f) {
                return window.setImmediate(f)
            }
        }
        if (canPost) {
            var queue = [];
            window.addEventListener("message", function (ev) {
                var source = ev.source;
                if ((source === window || source === null) && ev.data === "process-tick") {
                    ev.stopPropagation();
                    if (queue.length > 0) {
                        var fn = queue.shift();
                        fn()
                    }
                }
            }, true);
            return function nextTick(fn) {
                queue.push(fn);
                window.postMessage("process-tick", "*")
            }
        }
        return function nextTick(fn) {
            setTimeout(fn, 0)
        }
    }();
    process.title = "browser";
    process.browser = true;
    process.env = {};
    process.argv = [];
    function noop() {
    }

    process.on = noop;
    process.addListener = noop;
    process.once = noop;
    process.off = noop;
    process.removeListener = noop;
    process.removeAllListeners = noop;
    process.emit = noop;
    process.binding = function (name) {
        throw new Error("process.binding is not supported")
    };
    process.cwd = function () {
        return"/"
    };
    process.chdir = function (dir) {
        throw new Error("process.chdir is not supported")
    }
}, {}], 47: [function (require, module, exports) {
    var serialize = function (name, val, opt) {
        opt = opt || {};
        var enc = opt.encode || encode;
        var pairs = [name + "=" + enc(val)];
        if (null != opt.maxAge) {
            var maxAge = opt.maxAge - 0;
            if (isNaN(maxAge))throw new Error("maxAge should be a Number");
            pairs.push("Max-Age=" + maxAge)
        }
        if (opt.domain)pairs.push("Domain=" + opt.domain);
        if (opt.path)pairs.push("Path=" + opt.path);
        if (opt.expires)pairs.push("Expires=" + opt.expires.toUTCString());
        if (opt.httpOnly)pairs.push("HttpOnly");
        if (opt.secure)pairs.push("Secure");
        return pairs.join("; ")
    };
    var parse = function (str, opt) {
        opt = opt || {};
        var obj = {};
        var pairs = str.split(/; */);
        var dec = opt.decode || decode;
        pairs.forEach(function (pair) {
            var eq_idx = pair.indexOf("=");
            if (eq_idx < 0) {
                return
            }
            var key = pair.substr(0, eq_idx).trim();
            var val = pair.substr(++eq_idx, pair.length).trim();
            if ('"' == val[0]) {
                val = val.slice(1, -1)
            }
            if (undefined == obj[key]) {
                try {
                    obj[key] = dec(val)
                } catch (e) {
                    obj[key] = val
                }
            }
        });
        return obj
    };
    var encode = encodeURIComponent;
    var decode = decodeURIComponent;
    module.exports.serialize = serialize;
    module.exports.parse = parse
}, {}], 48: [function (require, module, exports) {
    exports = module.exports = require("./debug");
    exports.log = log;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.colors = ["cyan", "green", "goldenrod", "blue", "purple", "red"];
    function useColors() {
        return"WebkitAppearance"in document.documentElement.style || window.console && (console.firebug || console.exception && console.table)
    }

    exports.formatters.j = function (v) {
        return JSON.stringify(v)
    };
    function log() {
        var args = arguments;
        var useColors = this.useColors;
        args[0] = (useColors ? "%c" : "") + this.namespace + (useColors ? "%c " : " ") + args[0] + (useColors ? "%c " : " ") + "+" + exports.humanize(this.diff);
        if (useColors) {
            var c = "color: " + this.color;
            args = [args[0], c, ""].concat(Array.prototype.slice.call(args, 1));
            var index = 0;
            var lastC = 0;
            args[0].replace(/%[a-z%]/g, function (match) {
                if ("%%" === match)return;
                index++;
                if ("%c" === match) {
                    lastC = index
                }
            });
            args.splice(lastC, 0, c)
        }
        return"object" == typeof console && "function" == typeof console.log && Function.prototype.apply.call(console.log, console, args)
    }

    function save(namespaces) {
        try {
            if (null == namespaces) {
                localStorage.removeItem("debug")
            } else {
                localStorage.debug = namespaces
            }
        } catch (e) {
        }
    }

    function load() {
        var r;
        try {
            r = localStorage.debug
        } catch (e) {
        }
        return r
    }

    exports.enable(load())
}, {"./debug": 49}], 49: [function (require, module, exports) {
    exports = module.exports = debug;
    exports.coerce = coerce;
    exports.disable = disable;
    exports.enable = enable;
    exports.enabled = enabled;
    exports.humanize = require("ms");
    exports.names = [];
    exports.skips = [];
    exports.formatters = {};
    var prevColor = 0;
    var prevTime;

    function selectColor() {
        return exports.colors[prevColor++ % exports.colors.length]
    }

    function debug(namespace) {
        function disabled() {
        }

        disabled.enabled = false;
        function enabled() {
            var self = enabled;
            var curr = +new Date;
            var ms = curr - (prevTime || curr);
            self.diff = ms;
            self.prev = prevTime;
            self.curr = curr;
            prevTime = curr;
            if (null == self.useColors)self.useColors = exports.useColors();
            if (null == self.color && self.useColors)self.color = selectColor();
            var args = Array.prototype.slice.call(arguments);
            args[0] = exports.coerce(args[0]);
            if ("string" !== typeof args[0]) {
                args = ["%o"].concat(args)
            }
            var index = 0;
            args[0] = args[0].replace(/%([a-z%])/g, function (match, format) {
                if (match === "%%")return match;
                index++;
                var formatter = exports.formatters[format];
                if ("function" === typeof formatter) {
                    var val = args[index];
                    match = formatter.call(self, val);
                    args.splice(index, 1);
                    index--
                }
                return match
            });
            exports.log.apply(self, args)
        }

        enabled.enabled = true;
        var fn = exports.enabled(namespace) ? enabled : disabled;
        fn.namespace = namespace;
        return fn
    }

    function enable(namespaces) {
        exports.save(namespaces);
        var split = (namespaces || "").split(/[\s,]+/);
        var len = split.length;
        for (var i = 0; i < len; i++) {
            if (!split[i])continue;
            namespaces = split[i].replace("*", ".*?");
            if (namespaces[0] === "-") {
                exports.skips.push(new RegExp("^" + namespaces.substr(1) + "$"))
            } else {
                exports.names.push(new RegExp("^" + namespaces + "$"))
            }
        }
    }

    function disable() {
        exports.enable("")
    }

    function enabled(name) {
        var i, len;
        for (i = 0, len = exports.skips.length; i < len; i++) {
            if (exports.skips[i].test(name)) {
                return false
            }
        }
        for (i = 0, len = exports.names.length; i < len; i++) {
            if (exports.names[i].test(name)) {
                return true
            }
        }
        return false
    }

    function coerce(val) {
        if (val instanceof Error)return val.stack || val.message;
        return val
    }
}, {ms: 50}], 50: [function (require, module, exports) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var y = d * 365.25;
    module.exports = function (val, options) {
        options = options || {};
        if ("string" == typeof val)return parse(val);
        return options.long ? long(val) : short(val)
    };
    function parse(str) {
        var match = /^((?:\d+)?\.?\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i.exec(str);
        if (!match)return;
        var n = parseFloat(match[1]);
        var type = (match[2] || "ms").toLowerCase();
        switch (type) {
            case"years":
            case"year":
            case"y":
                return n * y;
            case"days":
            case"day":
            case"d":
                return n * d;
            case"hours":
            case"hour":
            case"h":
                return n * h;
            case"minutes":
            case"minute":
            case"m":
                return n * m;
            case"seconds":
            case"second":
            case"s":
                return n * s;
            case"ms":
                return n
        }
    }

    function short(ms) {
        if (ms >= d)return Math.round(ms / d) + "d";
        if (ms >= h)return Math.round(ms / h) + "h";
        if (ms >= m)return Math.round(ms / m) + "m";
        if (ms >= s)return Math.round(ms / s) + "s";
        return ms + "ms"
    }

    function long(ms) {
        return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms"
    }

    function plural(ms, n, name) {
        if (ms < n)return;
        if (ms < n * 1.5)return Math.floor(ms / n) + " " + name;
        return Math.ceil(ms / n) + " " + name + "s"
    }
}, {}], 51: [function (require, module, exports) {
    (function (factory) {
        if (typeof define === "function" && define["amd"]) {
            define(typeof document !== "object" || document.readyState !== "loading" ? [] : "html5-history-api", factory)
        } else {
            factory()
        }
    })(function () {
        var global = (typeof window === "object" ? window : this) || {};
        if (!global.history || "emulate"in global.history)return global.history;
        var document = global.document;
        var documentElement = document.documentElement;
        var Object = global["Object"];
        var JSON = global["JSON"];
        var windowLocation = global.location;
        var windowHistory = global.history;
        var historyObject = windowHistory;
        var historyPushState = windowHistory.pushState;
        var historyReplaceState = windowHistory.replaceState;
        var isSupportHistoryAPI = !!historyPushState;
        var isSupportStateObjectInHistory = "state"in windowHistory;
        var defineProperty = Object.defineProperty;
        var locationObject = redefineProperty({}, "t") ? {} : document.createElement("a");
        var eventNamePrefix = "";
        var addEventListenerName = global.addEventListener ? "addEventListener" : (eventNamePrefix = "on") && "attachEvent";
        var removeEventListenerName = global.removeEventListener ? "removeEventListener" : "detachEvent";
        var dispatchEventName = global.dispatchEvent ? "dispatchEvent" : "fireEvent";
        var addEvent = global[addEventListenerName];
        var removeEvent = global[removeEventListenerName];
        var dispatch = global[dispatchEventName];
        var settings = {basepath: "/", redirect: 0, type: "/", init: 0};
        var sessionStorageKey = "__historyAPI__";
        var anchorElement = document.createElement("a");
        var lastURL = windowLocation.href;
        var checkUrlForPopState = "";
        var triggerEventsInWindowAttributes = 1;
        var isFireInitialState = false;
        var isUsedHistoryLocationFlag = 0;
        var stateStorage = {};
        var eventsList = {};
        var lastTitle = document.title;
        var eventsDescriptors = {onhashchange: null, onpopstate: null};
        var fastFixChrome = function (method, args) {
            var isNeedFix = global.history !== windowHistory;
            if (isNeedFix) {
                global.history = windowHistory
            }
            method.apply(windowHistory, args);
            if (isNeedFix) {
                global.history = historyObject
            }
        };
        var historyDescriptors = {setup: function (basepath, type, redirect) {
            settings["basepath"] = ("" + (basepath == null ? settings["basepath"] : basepath)).replace(/(?:^|\/)[^\/]*$/, "/");
            settings["type"] = type == null ? settings["type"] : type;
            settings["redirect"] = redirect == null ? settings["redirect"] : !!redirect
        }, redirect: function (type, basepath) {
            historyObject["setup"](basepath, type);
            basepath = settings["basepath"];
            if (global.top == global.self) {
                var relative = parseURL(null, false, true)._relative;
                var path = windowLocation.pathname + windowLocation.search;
                if (isSupportHistoryAPI) {
                    path = path.replace(/([^\/])$/, "$1/");
                    if (relative != basepath && new RegExp("^" + basepath + "$", "i").test(path)) {
                        windowLocation.replace(relative)
                    }
                } else if (path != basepath) {
                    path = path.replace(/([^\/])\?/, "$1/?");
                    if (new RegExp("^" + basepath, "i").test(path)) {
                        windowLocation.replace(basepath + "#" + path.replace(new RegExp("^" + basepath, "i"), settings["type"]) + windowLocation.hash)
                    }
                }
            }
        }, pushState: function (state, title, url) {
            var t = document.title;
            if (lastTitle != null) {
                document.title = lastTitle
            }
            historyPushState && fastFixChrome(historyPushState, arguments);
            changeState(state, url);
            document.title = t;
            lastTitle = title
        }, replaceState: function (state, title, url) {
            var t = document.title;
            if (lastTitle != null) {
                document.title = lastTitle
            }
            delete stateStorage[windowLocation.href];
            historyReplaceState && fastFixChrome(historyReplaceState, arguments);
            changeState(state, url, true);
            document.title = t;
            lastTitle = title
        }, location: {set: function (value) {
            if (isUsedHistoryLocationFlag === 0)isUsedHistoryLocationFlag = 1;
            global.location = value
        }, get: function () {
            if (isUsedHistoryLocationFlag === 0)isUsedHistoryLocationFlag = 1;
            return isSupportHistoryAPI ? windowLocation : locationObject
        }}, state: {get: function () {
            return stateStorage[windowLocation.href] || null
        }}};
        var locationDescriptors = {assign: function (url) {
            if (("" + url).indexOf("#") === 0) {
                changeState(null, url)
            } else {
                windowLocation.assign(url)
            }
        }, reload: function () {
            windowLocation.reload()
        }, replace: function (url) {
            if (("" + url).indexOf("#") === 0) {
                changeState(null, url, true)
            } else {
                windowLocation.replace(url)
            }
        }, toString: function () {
            return this.href
        }, href: {get: function () {
            return parseURL()._href
        }}, protocol: null, host: null, hostname: null, port: null, pathname: {get: function () {
            return parseURL()._pathname
        }}, search: {get: function () {
            return parseURL()._search
        }}, hash: {set: function (value) {
            changeState(null, ("" + value).replace(/^(#|)/, "#"), false, lastURL)
        }, get: function () {
            return parseURL()._hash
        }}};

        function emptyFunction() {
        }

        function parseURL(href, isWindowLocation, isNotAPI) {
            var re = /(?:(\w+\:))?(?:\/\/(?:[^@]*@)?([^\/:\?#]+)(?::([0-9]+))?)?([^\?#]*)(?:(\?[^#]+)|\?)?(?:(#.*))?/;
            if (href != null && href !== "" && !isWindowLocation) {
                var current = parseURL(), base = document.getElementsByTagName("base")[0];
                if (!isNotAPI && base && base.getAttribute("href")) {
                    base.href = base.href;
                    current = parseURL(base.href, null, true)
                }
                var _pathname = current._pathname, _protocol = current._protocol;
                href = "" + href;
                href = /^(?:\w+\:)?\/\//.test(href) ? href.indexOf("/") === 0 ? _protocol + href : href : _protocol + "//" + current._host + (href.indexOf("/") === 0 ? href : href.indexOf("?") === 0 ? _pathname + href : href.indexOf("#") === 0 ? _pathname + current._search + href : _pathname.replace(/[^\/]+$/g, "") + href)
            } else {
                href = isWindowLocation ? href : windowLocation.href;
                if (!isSupportHistoryAPI || isNotAPI) {
                    href = href.replace(/^[^#]*/, "") || "#";
                    href = windowLocation.protocol.replace(/:.*$|$/, ":") + "//" + windowLocation.host + settings["basepath"] + href.replace(new RegExp("^#[/]?(?:" + settings["type"] + ")?"), "")
                }
            }
            anchorElement.href = href;
            var result = re.exec(anchorElement.href);
            var host = result[2] + (result[3] ? ":" + result[3] : "");
            var pathname = result[4] || "/";
            var search = result[5] || "";
            var hash = result[6] === "#" ? "" : result[6] || "";
            var relative = pathname + search + hash;
            var nohash = pathname.replace(new RegExp("^" + settings["basepath"], "i"), settings["type"]) + search;
            return{_href: result[1] + "//" + host + relative, _protocol: result[1], _host: host, _hostname: result[2], _port: result[3] || "", _pathname: pathname, _search: search, _hash: hash, _relative: relative, _nohash: nohash, _special: nohash + hash}
        }

        function storageInitialize() {
            var sessionStorage;
            try {
                sessionStorage = global["sessionStorage"];
                sessionStorage.setItem(sessionStorageKey + "t", "1");
                sessionStorage.removeItem(sessionStorageKey + "t")
            } catch (_e_) {
                sessionStorage = {getItem: function (key) {
                    var cookie = document.cookie.split(key + "=");
                    return cookie.length > 1 && cookie.pop().split(";").shift() || "null"
                }, setItem: function (key, value) {
                    var state = {};
                    if (state[windowLocation.href] = historyObject.state) {
                        document.cookie = key + "=" + JSON.stringify(state)
                    }
                }}
            }
            try {
                stateStorage = JSON.parse(sessionStorage.getItem(sessionStorageKey)) || {}
            } catch (_e_) {
                stateStorage = {}
            }
            addEvent(eventNamePrefix + "unload", function () {
                sessionStorage.setItem(sessionStorageKey, JSON.stringify(stateStorage))
            }, false)
        }

        function redefineProperty(object, prop, descriptor, onWrapped) {
            var testOnly = 0;
            if (!descriptor) {
                descriptor = {set: emptyFunction};
                testOnly = 1
            }
            var isDefinedSetter = !descriptor.set;
            var isDefinedGetter = !descriptor.get;
            var test = {configurable: true, set: function () {
                isDefinedSetter = 1
            }, get: function () {
                isDefinedGetter = 1
            }};
            try {
                defineProperty(object, prop, test);
                object[prop] = object[prop];
                defineProperty(object, prop, descriptor)
            } catch (_e_) {
            }
            if (!isDefinedSetter || !isDefinedGetter) {
                if (object.__defineGetter__) {
                    object.__defineGetter__(prop, test.get);
                    object.__defineSetter__(prop, test.set);
                    object[prop] = object[prop];
                    descriptor.get && object.__defineGetter__(prop, descriptor.get);
                    descriptor.set && object.__defineSetter__(prop, descriptor.set)
                }
                if (!isDefinedSetter || !isDefinedGetter) {
                    if (testOnly) {
                        return false
                    } else if (object === global) {
                        try {
                            var originalValue = object[prop];
                            object[prop] = null
                        } catch (_e_) {
                        }
                        if ("execScript"in global) {
                            global["execScript"]("Public " + prop, "VBScript");
                            global["execScript"]("var " + prop + ";", "JavaScript")
                        } else {
                            try {
                                defineProperty(object, prop, {value: emptyFunction})
                            } catch (_e_) {
                                if (prop === "onpopstate") {
                                    addEvent("popstate", descriptor = function () {
                                        removeEvent("popstate", descriptor, false);
                                        var onpopstate = object.onpopstate;
                                        object.onpopstate = null;
                                        setTimeout(function () {
                                            object.onpopstate = onpopstate
                                        }, 1)
                                    }, false);
                                    triggerEventsInWindowAttributes = 0
                                }
                            }
                        }
                        object[prop] = originalValue
                    } else {
                        try {
                            try {
                                var temp = Object.create(object);
                                defineProperty(Object.getPrototypeOf(temp) === object ? temp : object, prop, descriptor);
                                for (var key in object) {
                                    if (typeof object[key] === "function") {
                                        temp[key] = object[key].bind(object)
                                    }
                                }
                                try {
                                    onWrapped.call(temp, temp, object)
                                } catch (_e_) {
                                }
                                object = temp
                            } catch (_e_) {
                                defineProperty(object.constructor.prototype, prop, descriptor)
                            }
                        } catch (_e_) {
                            return false
                        }
                    }
                }
            }
            return object
        }

        function prepareDescriptorsForObject(object, prop, descriptor) {
            descriptor = descriptor || {};
            object = object === locationDescriptors ? windowLocation : object;
            descriptor.set = descriptor.set || function (value) {
                object[prop] = value
            };
            descriptor.get = descriptor.get || function () {
                return object[prop]
            };
            return descriptor
        }

        function addEventListener(event, listener, capture) {
            if (event in eventsList) {
                eventsList[event].push(listener)
            } else {
                if (arguments.length > 3) {
                    addEvent(event, listener, capture, arguments[3])
                } else {
                    addEvent(event, listener, capture)
                }
            }
        }

        function removeEventListener(event, listener, capture) {
            var list = eventsList[event];
            if (list) {
                for (var i = list.length; i--;) {
                    if (list[i] === listener) {
                        list.splice(i, 1);
                        break
                    }
                }
            } else {
                removeEvent(event, listener, capture)
            }
        }

        function dispatchEvent(event, eventObject) {
            var eventType = ("" + (typeof event === "string" ? event : event.type)).replace(/^on/, "");
            var list = eventsList[eventType];
            if (list) {
                eventObject = typeof event === "string" ? eventObject : event;
                if (eventObject.target == null) {
                    for (var props = ["target", "currentTarget", "srcElement", "type"]; event = props.pop();) {
                        eventObject = redefineProperty(eventObject, event, {get: event === "type" ? function () {
                            return eventType
                        } : function () {
                            return global
                        }})
                    }
                }
                if (triggerEventsInWindowAttributes) {
                    ((eventType === "popstate" ? global.onpopstate : global.onhashchange) || emptyFunction).call(global, eventObject)
                }
                for (var i = 0, len = list.length; i < len; i++) {
                    list[i].call(global, eventObject)
                }
                return true
            } else {
                return dispatch(event, eventObject)
            }
        }

        function firePopState() {
            var o = document.createEvent ? document.createEvent("Event") : document.createEventObject();
            if (o.initEvent) {
                o.initEvent("popstate", false, false)
            } else {
                o.type = "popstate"
            }
            o.state = historyObject.state;
            dispatchEvent(o)
        }

        function fireInitialState() {
            if (isFireInitialState) {
                isFireInitialState = false;
                firePopState()
            }
        }

        function changeState(state, url, replace, lastURLValue) {
            if (!isSupportHistoryAPI) {
                if (isUsedHistoryLocationFlag === 0)isUsedHistoryLocationFlag = 2;
                var urlObject = parseURL(url, isUsedHistoryLocationFlag === 2 && ("" + url).indexOf("#") !== -1);
                if (urlObject._relative !== parseURL()._relative) {
                    lastURL = lastURLValue;
                    if (replace) {
                        windowLocation.replace("#" + urlObject._special)
                    } else {
                        windowLocation.hash = urlObject._special
                    }
                }
            } else {
                lastURL = windowLocation.href
            }
            if (!isSupportStateObjectInHistory && state) {
                stateStorage[windowLocation.href] = state
            }
            isFireInitialState = false
        }

        function onHashChange(event) {
            var fireNow = lastURL;
            lastURL = windowLocation.href;
            if (fireNow) {
                if (checkUrlForPopState !== windowLocation.href) {
                    firePopState()
                }
                event = event || global.event;
                var oldURLObject = parseURL(fireNow, true);
                var newURLObject = parseURL();
                if (!event.oldURL) {
                    event.oldURL = oldURLObject._href;
                    event.newURL = newURLObject._href
                }
                if (oldURLObject._hash !== newURLObject._hash) {
                    dispatchEvent(event)
                }
            }
        }

        function onLoad(noScroll) {
            setTimeout(function () {
                addEvent("popstate", function (e) {
                    checkUrlForPopState = windowLocation.href;
                    if (!isSupportStateObjectInHistory) {
                        e = redefineProperty(e, "state", {get: function () {
                            return historyObject.state
                        }})
                    }
                    dispatchEvent(e)
                }, false)
            }, 0);
            if (!isSupportHistoryAPI && noScroll !== true && "location"in historyObject) {
                scrollToAnchorId(locationObject.hash);
                fireInitialState()
            }
        }

        function anchorTarget(target) {
            while (target) {
                if (target.nodeName === "A")return target;
                target = target.parentNode
            }
        }

        function onAnchorClick(e) {
            var event = e || global.event;
            var target = anchorTarget(event.target || event.srcElement);
            var defaultPrevented = "defaultPrevented"in event ? event["defaultPrevented"] : event.returnValue === false;
            if (target && target.nodeName === "A" && !defaultPrevented) {
                var current = parseURL();
                var expect = parseURL(target.getAttribute("href", 2));
                var isEqualBaseURL = current._href.split("#").shift() === expect._href.split("#").shift();
                if (isEqualBaseURL && expect._hash) {
                    if (current._hash !== expect._hash) {
                        locationObject.hash = expect._hash
                    }
                    scrollToAnchorId(expect._hash);
                    if (event.preventDefault) {
                        event.preventDefault()
                    } else {
                        event.returnValue = false
                    }
                }
            }
        }

        function scrollToAnchorId(hash) {
            var target = document.getElementById(hash = (hash || "").replace(/^#/, ""));
            if (target && target.id === hash && target.nodeName === "A") {
                var rect = target.getBoundingClientRect();
                global.scrollTo(documentElement.scrollLeft || 0, rect.top + (documentElement.scrollTop || 0) - (documentElement.clientTop || 0))
            }
        }

        function initialize() {
            var scripts = document.getElementsByTagName("script");
            var src = (scripts[scripts.length - 1] || {}).src || "";
            var arg = src.indexOf("?") !== -1 ? src.split("?").pop() : "";
            arg.replace(/(\w+)(?:=([^&]*))?/g, function (a, key, value) {
                settings[key] = (value || "").replace(/^(0|false)$/, "")
            });
            addEvent(eventNamePrefix + "hashchange", onHashChange, false);
            var data = [locationDescriptors, locationObject, eventsDescriptors, global, historyDescriptors, historyObject];
            if (isSupportStateObjectInHistory) {
                delete historyDescriptors["state"]
            }
            for (var i = 0; i < data.length; i += 2) {
                for (var prop in data[i]) {
                    if (data[i].hasOwnProperty(prop)) {
                        if (typeof data[i][prop] === "function") {
                            data[i + 1][prop] = data[i][prop]
                        } else {
                            var descriptor = prepareDescriptorsForObject(data[i], prop, data[i][prop]);
                            if (!redefineProperty(data[i + 1], prop, descriptor, function (n, o) {
                                if (o === historyObject) {
                                    global.history = historyObject = data[i + 1] = n
                                }
                            })) {
                                removeEvent(eventNamePrefix + "hashchange", onHashChange, false);
                                return false
                            }
                            if (data[i + 1] === global) {
                                eventsList[prop] = eventsList[prop.substr(2)] = []
                            }
                        }
                    }
                }
            }
            historyObject["setup"]();
            if (settings["redirect"]) {
                historyObject["redirect"]()
            }
            if (settings["init"]) {
                isUsedHistoryLocationFlag = 1
            }
            if (!isSupportStateObjectInHistory && JSON) {
                storageInitialize()
            }
            if (!isSupportHistoryAPI) {
                document[addEventListenerName](eventNamePrefix + "click", onAnchorClick, false)
            }
            if (document.readyState === "complete") {
                onLoad(true)
            } else {
                if (!isSupportHistoryAPI && parseURL()._relative !== settings["basepath"]) {
                    isFireInitialState = true
                }
                addEvent(eventNamePrefix + "load", onLoad, false)
            }
            return true
        }

        if (!initialize()) {
            return
        }
        historyObject["emulate"] = !isSupportHistoryAPI;
        global[addEventListenerName] = addEventListener;
        global[removeEventListenerName] = removeEventListener;
        global[dispatchEventName] = dispatchEvent;
        return historyObject
    })
}, {}], 52: [function (require, module, exports) {
    if (typeof Object.create === "function") {
        module.exports = function inherits(ctor, superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {constructor: {value: ctor, enumerable: false, writable: true, configurable: true}})
        }
    } else {
        module.exports = function inherits(ctor, superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function () {
            };
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor;
            ctor.prototype.constructor = ctor
        }
    }
}, {}], 53: [function (require, module, exports) {
    (function (root, undef) {
        var ArrayProto = Array.prototype, ObjProto = Object.prototype, slice = ArrayProto.slice, hasOwnProp = ObjProto.hasOwnProperty, nativeForEach = ArrayProto.forEach, breaker = {};
        var _ = {forEach: function (obj, iterator, context) {
            var i, l, key;
            if (obj === null) {
                return
            }
            if (nativeForEach && obj.forEach === nativeForEach) {
                obj.forEach(iterator, context)
            } else if (obj.length === +obj.length) {
                for (i = 0, l = obj.length; i < l; i++) {
                    if (i in obj && iterator.call(context, obj[i], i, obj) === breaker) {
                        return
                    }
                }
            } else {
                for (key in obj) {
                    if (hasOwnProp.call(obj, key)) {
                        if (iterator.call(context, obj[key], key, obj) === breaker) {
                            return
                        }
                    }
                }
            }
        }, extend: function (obj) {
            this.forEach(slice.call(arguments, 1), function (source) {
                for (var prop in source) {
                    obj[prop] = source[prop]
                }
            });
            return obj
        }};
        var Jed = function (options) {
            this.defaults = {locale_data: {messages: {"": {domain: "messages", lang: "en", plural_forms: "nplurals=2; plural=(n != 1);"}}}, domain: "messages"};
            this.options = _.extend({}, this.defaults, options);
            this.textdomain(this.options.domain);
            if (options.domain && !this.options.locale_data[this.options.domain]) {
                throw new Error("Text domain set to non-existent domain: `" + options.domain + "`")
            }
        };
        Jed.context_delimiter = String.fromCharCode(4);
        function getPluralFormFunc(plural_form_string) {
            return Jed.PF.compile(plural_form_string || "nplurals=2; plural=(n != 1);")
        }

        function Chain(key, i18n) {
            this._key = key;
            this._i18n = i18n
        }

        _.extend(Chain.prototype, {onDomain: function (domain) {
            this._domain = domain;
            return this
        }, withContext: function (context) {
            this._context = context;
            return this
        }, ifPlural: function (num, pkey) {
            this._val = num;
            this._pkey = pkey;
            return this
        }, fetch: function (sArr) {
            if ({}.toString.call(sArr) != "[object Array]") {
                sArr = [].slice.call(arguments)
            }
            return(sArr && sArr.length ? Jed.sprintf : function (x) {
                return x
            })(this._i18n.dcnpgettext(this._domain, this._context, this._key, this._pkey, this._val), sArr)
        }});
        _.extend(Jed.prototype, {translate: function (key) {
            return new Chain(key, this)
        }, textdomain: function (domain) {
            if (!domain) {
                return this._textdomain
            }
            this._textdomain = domain
        }, gettext: function (key) {
            return this.dcnpgettext.call(this, undef, undef, key)
        }, dgettext: function (domain, key) {
            return this.dcnpgettext.call(this, domain, undef, key)
        }, dcgettext: function (domain, key) {
            return this.dcnpgettext.call(this, domain, undef, key)
        }, ngettext: function (skey, pkey, val) {
            return this.dcnpgettext.call(this, undef, undef, skey, pkey, val)
        }, dngettext: function (domain, skey, pkey, val) {
            return this.dcnpgettext.call(this, domain, undef, skey, pkey, val)
        }, dcngettext: function (domain, skey, pkey, val) {
            return this.dcnpgettext.call(this, domain, undef, skey, pkey, val)
        }, pgettext: function (context, key) {
            return this.dcnpgettext.call(this, undef, context, key)
        }, dpgettext: function (domain, context, key) {
            return this.dcnpgettext.call(this, domain, context, key)
        }, dcpgettext: function (domain, context, key) {
            return this.dcnpgettext.call(this, domain, context, key)
        }, npgettext: function (context, skey, pkey, val) {
            return this.dcnpgettext.call(this, undef, context, skey, pkey, val)
        }, dnpgettext: function (domain, context, skey, pkey, val) {
            return this.dcnpgettext.call(this, domain, context, skey, pkey, val)
        }, dcnpgettext: function (domain, context, singular_key, plural_key, val) {
            plural_key = plural_key || singular_key;
            domain = domain || this._textdomain;
            val = typeof val == "undefined" ? 1 : val;
            var fallback;
            if (!this.options) {
                fallback = new Jed;
                return fallback.dcnpgettext.call(fallback, undefined, undefined, singular_key, plural_key, val)
            }
            if (!this.options.locale_data) {
                throw new Error("No locale data provided.")
            }
            if (!this.options.locale_data[domain]) {
                throw new Error("Domain `" + domain + "` was not found.")
            }
            if (!this.options.locale_data[domain][""]) {
                throw new Error("No locale meta information provided.")
            }
            if (!singular_key) {
                throw new Error("No translation key found.")
            }
            if (typeof val != "number") {
                val = parseInt(val, 10);
                if (isNaN(val)) {
                    throw new Error("The number that was passed in is not a number.")
                }
            }
            var key = context ? context + Jed.context_delimiter + singular_key : singular_key, locale_data = this.options.locale_data, dict = locale_data[domain], pluralForms = dict[""].plural_forms || (locale_data.messages || this.defaults.locale_data.messages)[""].plural_forms, val_idx = getPluralFormFunc(pluralForms)(val) + 1, val_list, res;
            if (!dict) {
                throw new Error("No domain named `" + domain + "` could be found.")
            }
            val_list = dict[key];
            if (!val_list || val_idx >= val_list.length) {
                if (this.options.missing_key_callback) {
                    this.options.missing_key_callback(key)
                }
                res = [null, singular_key, plural_key];
                return res[getPluralFormFunc(pluralForms)(val) + 1]
            }
            res = val_list[val_idx];
            if (!res) {
                res = [null, singular_key, plural_key];
                return res[getPluralFormFunc(pluralForms)(val) + 1]
            }
            return res
        }});
        var sprintf = function () {
            function get_type(variable) {
                return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase()
            }

            function str_repeat(input, multiplier) {
                for (var output = []; multiplier > 0; output[--multiplier] = input) {
                }
                return output.join("")
            }

            var str_format = function () {
                if (!str_format.cache.hasOwnProperty(arguments[0])) {
                    str_format.cache[arguments[0]] = str_format.parse(arguments[0])
                }
                return str_format.format.call(null, str_format.cache[arguments[0]], arguments)
            };
            str_format.format = function (parse_tree, argv) {
                var cursor = 1, tree_length = parse_tree.length, node_type = "", arg, output = [], i, k, match, pad, pad_character, pad_length;
                for (i = 0; i < tree_length; i++) {
                    node_type = get_type(parse_tree[i]);
                    if (node_type === "string") {
                        output.push(parse_tree[i])
                    } else if (node_type === "array") {
                        match = parse_tree[i];
                        if (match[2]) {
                            arg = argv[cursor];
                            for (k = 0; k < match[2].length; k++) {
                                if (!arg.hasOwnProperty(match[2][k])) {
                                    throw sprintf('[sprintf] property "%s" does not exist', match[2][k])
                                }
                                arg = arg[match[2][k]]
                            }
                        } else if (match[1]) {
                            arg = argv[match[1]]
                        } else {
                            arg = argv[cursor++]
                        }
                        if (/[^s]/.test(match[8]) && get_type(arg) != "number") {
                            throw sprintf("[sprintf] expecting number but found %s", get_type(arg))
                        }
                        if (typeof arg == "undefined" || arg === null) {
                            arg = ""
                        }
                        switch (match[8]) {
                            case"b":
                                arg = arg.toString(2);
                                break;
                            case"c":
                                arg = String.fromCharCode(arg);
                                break;
                            case"d":
                                arg = parseInt(arg, 10);
                                break;
                            case"e":
                                arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential();
                                break;
                            case"f":
                                arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg);
                                break;
                            case"o":
                                arg = arg.toString(8);
                                break;
                            case"s":
                                arg = (arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg;
                                break;
                            case"u":
                                arg = Math.abs(arg);
                                break;
                            case"x":
                                arg = arg.toString(16);
                                break;
                            case"X":
                                arg = arg.toString(16).toUpperCase();
                                break
                        }
                        arg = /[def]/.test(match[8]) && match[3] && arg >= 0 ? "+" + arg : arg;
                        pad_character = match[4] ? match[4] == "0" ? "0" : match[4].charAt(1) : " ";
                        pad_length = match[6] - String(arg).length;
                        pad = match[6] ? str_repeat(pad_character, pad_length) : "";
                        output.push(match[5] ? arg + pad : pad + arg)
                    }
                }
                return output.join("")
            };
            str_format.cache = {};
            str_format.parse = function (fmt) {
                var _fmt = fmt, match = [], parse_tree = [], arg_names = 0;
                while (_fmt) {
                    if ((match = /^[^\x25]+/.exec(_fmt)) !== null) {
                        parse_tree.push(match[0])
                    } else if ((match = /^\x25{2}/.exec(_fmt)) !== null) {
                        parse_tree.push("%")
                    } else if ((match = /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(_fmt)) !== null) {
                        if (match[2]) {
                            arg_names |= 1;
                            var field_list = [], replacement_field = match[2], field_match = [];
                            if ((field_match = /^([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                                field_list.push(field_match[1]);
                                while ((replacement_field = replacement_field.substring(field_match[0].length)) !== "") {
                                    if ((field_match = /^\.([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                                        field_list.push(field_match[1])
                                    } else if ((field_match = /^\[(\d+)\]/.exec(replacement_field)) !== null) {
                                        field_list.push(field_match[1])
                                    } else {
                                        throw"[sprintf] huh?"
                                    }
                                }
                            } else {
                                throw"[sprintf] huh?"
                            }
                            match[2] = field_list
                        } else {
                            arg_names |= 2
                        }
                        if (arg_names === 3) {
                            throw"[sprintf] mixing positional and named placeholders is not (yet) supported"
                        }
                        parse_tree.push(match)
                    } else {
                        throw"[sprintf] huh?"
                    }
                    _fmt = _fmt.substring(match[0].length)
                }
                return parse_tree
            };
            return str_format
        }();
        var vsprintf = function (fmt, argv) {
            argv.unshift(fmt);
            return sprintf.apply(null, argv)
        };
        Jed.parse_plural = function (plural_forms, n) {
            plural_forms = plural_forms.replace(/n/g, n);
            return Jed.parse_expression(plural_forms)
        };
        Jed.sprintf = function (fmt, args) {
            if ({}.toString.call(args) == "[object Array]") {
                return vsprintf(fmt, [].slice.call(args))
            }
            return sprintf.apply(this, [].slice.call(arguments))
        };
        Jed.prototype.sprintf = function () {
            return Jed.sprintf.apply(this, arguments)
        };
        Jed.PF = {};
        Jed.PF.parse = function (p) {
            var plural_str = Jed.PF.extractPluralExpr(p);
            return Jed.PF.parser.parse.call(Jed.PF.parser, plural_str)
        };
        Jed.PF.compile = function (p) {
            function imply(val) {
                return val === true ? 1 : val ? val : 0
            }

            var ast = Jed.PF.parse(p);
            return function (n) {
                return imply(Jed.PF.interpreter(ast)(n))
            }
        };
        Jed.PF.interpreter = function (ast) {
            return function (n) {
                var res;
                switch (ast.type) {
                    case"GROUP":
                        return Jed.PF.interpreter(ast.expr)(n);
                    case"TERNARY":
                        if (Jed.PF.interpreter(ast.expr)(n)) {
                            return Jed.PF.interpreter(ast.truthy)(n)
                        }
                        return Jed.PF.interpreter(ast.falsey)(n);
                    case"OR":
                        return Jed.PF.interpreter(ast.left)(n) || Jed.PF.interpreter(ast.right)(n);
                    case"AND":
                        return Jed.PF.interpreter(ast.left)(n) && Jed.PF.interpreter(ast.right)(n);
                    case"LT":
                        return Jed.PF.interpreter(ast.left)(n) < Jed.PF.interpreter(ast.right)(n);
                    case"GT":
                        return Jed.PF.interpreter(ast.left)(n) > Jed.PF.interpreter(ast.right)(n);
                    case"LTE":
                        return Jed.PF.interpreter(ast.left)(n) <= Jed.PF.interpreter(ast.right)(n);
                    case"GTE":
                        return Jed.PF.interpreter(ast.left)(n) >= Jed.PF.interpreter(ast.right)(n);
                    case"EQ":
                        return Jed.PF.interpreter(ast.left)(n) == Jed.PF.interpreter(ast.right)(n);
                    case"NEQ":
                        return Jed.PF.interpreter(ast.left)(n) != Jed.PF.interpreter(ast.right)(n);
                    case"MOD":
                        return Jed.PF.interpreter(ast.left)(n) % Jed.PF.interpreter(ast.right)(n);
                    case"VAR":
                        return n;
                    case"NUM":
                        return ast.val;
                    default:
                        throw new Error("Invalid Token found.")
                }
            }
        };
        Jed.PF.extractPluralExpr = function (p) {
            p = p.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
            if (!/;\s*$/.test(p)) {
                p = p.concat(";")
            }
            var nplurals_re = /nplurals\=(\d+);/, plural_re = /plural\=(.*);/, nplurals_matches = p.match(nplurals_re), res = {}, plural_matches;
            if (nplurals_matches.length > 1) {
                res.nplurals = nplurals_matches[1]
            } else {
                throw new Error("nplurals not found in plural_forms string: " + p)
            }
            p = p.replace(nplurals_re, "");
            plural_matches = p.match(plural_re);
            if (!(plural_matches && plural_matches.length > 1)) {
                throw new Error("`plural` expression not found: " + p)
            }
            return plural_matches[1]
        };
        Jed.PF.parser = function () {
            var parser = {trace: function trace() {
            }, yy: {}, symbols_: {error: 2, expressions: 3, e: 4, EOF: 5, "?": 6, ":": 7, "||": 8, "&&": 9, "<": 10, "<=": 11, ">": 12, ">=": 13, "!=": 14, "==": 15, "%": 16, "(": 17, ")": 18, n: 19, NUMBER: 20, $accept: 0, $end: 1}, terminals_: {2: "error", 5: "EOF", 6: "?", 7: ":", 8: "||", 9: "&&", 10: "<", 11: "<=", 12: ">", 13: ">=", 14: "!=", 15: "==", 16: "%", 17: "(", 18: ")", 19: "n", 20: "NUMBER"}, productions_: [0, [3, 2], [4, 5], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 1], [4, 1]], performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
                var $0 = $$.length - 1;
                switch (yystate) {
                    case 1:
                        return{type: "GROUP", expr: $$[$0 - 1]};
                        break;
                    case 2:
                        this.$ = {type: "TERNARY", expr: $$[$0 - 4], truthy: $$[$0 - 2], falsey: $$[$0]};
                        break;
                    case 3:
                        this.$ = {type: "OR", left: $$[$0 - 2], right: $$[$0]};
                        break;
                    case 4:
                        this.$ = {type: "AND", left: $$[$0 - 2], right: $$[$0]};
                        break;
                    case 5:
                        this.$ = {type: "LT", left: $$[$0 - 2], right: $$[$0]};
                        break;
                    case 6:
                        this.$ = {type: "LTE", left: $$[$0 - 2], right: $$[$0]};
                        break;
                    case 7:
                        this.$ = {type: "GT", left: $$[$0 - 2], right: $$[$0]};
                        break;
                    case 8:
                        this.$ = {type: "GTE", left: $$[$0 - 2], right: $$[$0]};
                        break;
                    case 9:
                        this.$ = {type: "NEQ", left: $$[$0 - 2], right: $$[$0]};
                        break;
                    case 10:
                        this.$ = {type: "EQ", left: $$[$0 - 2], right: $$[$0]};
                        break;
                    case 11:
                        this.$ = {type: "MOD", left: $$[$0 - 2], right: $$[$0]};
                        break;
                    case 12:
                        this.$ = {type: "GROUP", expr: $$[$0 - 1]};
                        break;
                    case 13:
                        this.$ = {type: "VAR"};
                        break;
                    case 14:
                        this.$ = {type: "NUM", val: Number(yytext)};
                        break
                }
            }, table: [
                {3: 1, 4: 2, 17: [1, 3], 19: [1, 4], 20: [1, 5]},
                {1: [3]},
                {5: [1, 6], 6: [1, 7], 8: [1, 8], 9: [1, 9], 10: [1, 10], 11: [1, 11], 12: [1, 12], 13: [1, 13], 14: [1, 14], 15: [1, 15], 16: [1, 16]},
                {4: 17, 17: [1, 3], 19: [1, 4], 20: [1, 5]},
                {5: [2, 13], 6: [2, 13], 7: [2, 13], 8: [2, 13], 9: [2, 13], 10: [2, 13], 11: [2, 13], 12: [2, 13], 13: [2, 13], 14: [2, 13], 15: [2, 13], 16: [2, 13], 18: [2, 13]},
                {5: [2, 14], 6: [2, 14], 7: [2, 14], 8: [2, 14], 9: [2, 14], 10: [2, 14], 11: [2, 14], 12: [2, 14], 13: [2, 14], 14: [2, 14], 15: [2, 14], 16: [2, 14], 18: [2, 14]},
                {1: [2, 1]},
                {4: 18, 17: [1, 3], 19: [1, 4], 20: [1, 5]},
                {4: 19, 17: [1, 3], 19: [1, 4], 20: [1, 5]},
                {4: 20, 17: [1, 3], 19: [1, 4], 20: [1, 5]},
                {4: 21, 17: [1, 3], 19: [1, 4], 20: [1, 5]},
                {4: 22, 17: [1, 3], 19: [1, 4], 20: [1, 5]},
                {4: 23, 17: [1, 3], 19: [1, 4], 20: [1, 5]},
                {4: 24, 17: [1, 3], 19: [1, 4], 20: [1, 5]},
                {4: 25, 17: [1, 3], 19: [1, 4], 20: [1, 5]},
                {4: 26, 17: [1, 3], 19: [1, 4], 20: [1, 5]},
                {4: 27, 17: [1, 3], 19: [1, 4], 20: [1, 5]},
                {6: [1, 7], 8: [1, 8], 9: [1, 9], 10: [1, 10], 11: [1, 11], 12: [1, 12], 13: [1, 13], 14: [1, 14], 15: [1, 15], 16: [1, 16], 18: [1, 28]},
                {6: [1, 7], 7: [1, 29], 8: [1, 8], 9: [1, 9], 10: [1, 10], 11: [1, 11], 12: [1, 12], 13: [1, 13], 14: [1, 14], 15: [1, 15], 16: [1, 16]},
                {5: [2, 3], 6: [2, 3], 7: [2, 3], 8: [2, 3], 9: [1, 9], 10: [1, 10], 11: [1, 11], 12: [1, 12], 13: [1, 13], 14: [1, 14], 15: [1, 15], 16: [1, 16], 18: [2, 3]},
                {5: [2, 4], 6: [2, 4], 7: [2, 4], 8: [2, 4], 9: [2, 4], 10: [1, 10], 11: [1, 11], 12: [1, 12], 13: [1, 13], 14: [1, 14], 15: [1, 15], 16: [1, 16], 18: [2, 4]},
                {5: [2, 5], 6: [2, 5], 7: [2, 5], 8: [2, 5], 9: [2, 5], 10: [2, 5], 11: [2, 5], 12: [2, 5], 13: [2, 5], 14: [2, 5], 15: [2, 5], 16: [1, 16], 18: [2, 5]},
                {5: [2, 6], 6: [2, 6], 7: [2, 6], 8: [2, 6], 9: [2, 6], 10: [2, 6], 11: [2, 6], 12: [2, 6], 13: [2, 6], 14: [2, 6], 15: [2, 6], 16: [1, 16], 18: [2, 6]},
                {5: [2, 7], 6: [2, 7], 7: [2, 7], 8: [2, 7], 9: [2, 7], 10: [2, 7], 11: [2, 7], 12: [2, 7], 13: [2, 7], 14: [2, 7], 15: [2, 7], 16: [1, 16], 18: [2, 7]},
                {5: [2, 8], 6: [2, 8], 7: [2, 8], 8: [2, 8], 9: [2, 8], 10: [2, 8], 11: [2, 8], 12: [2, 8], 13: [2, 8], 14: [2, 8], 15: [2, 8], 16: [1, 16], 18: [2, 8]},
                {5: [2, 9], 6: [2, 9], 7: [2, 9], 8: [2, 9], 9: [2, 9], 10: [2, 9], 11: [2, 9], 12: [2, 9], 13: [2, 9], 14: [2, 9], 15: [2, 9], 16: [1, 16], 18: [2, 9]},
                {5: [2, 10], 6: [2, 10], 7: [2, 10], 8: [2, 10], 9: [2, 10], 10: [2, 10], 11: [2, 10], 12: [2, 10], 13: [2, 10], 14: [2, 10], 15: [2, 10], 16: [1, 16], 18: [2, 10]},
                {5: [2, 11], 6: [2, 11], 7: [2, 11], 8: [2, 11], 9: [2, 11], 10: [2, 11], 11: [2, 11], 12: [2, 11], 13: [2, 11], 14: [2, 11], 15: [2, 11], 16: [2, 11], 18: [2, 11]},
                {5: [2, 12], 6: [2, 12], 7: [2, 12], 8: [2, 12], 9: [2, 12], 10: [2, 12], 11: [2, 12], 12: [2, 12], 13: [2, 12], 14: [2, 12], 15: [2, 12], 16: [2, 12], 18: [2, 12]},
                {4: 30, 17: [1, 3], 19: [1, 4], 20: [1, 5]},
                {5: [2, 2], 6: [1, 7], 7: [2, 2], 8: [1, 8], 9: [1, 9], 10: [1, 10], 11: [1, 11], 12: [1, 12], 13: [1, 13], 14: [1, 14], 15: [1, 15], 16: [1, 16], 18: [2, 2]}
            ], defaultActions: {6: [2, 1]}, parseError: function parseError(str, hash) {
                throw new Error(str)
            }, parse: function parse(input) {
                var self = this, stack = [0], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
                this.lexer.setInput(input);
                this.lexer.yy = this.yy;
                this.yy.lexer = this.lexer;
                if (typeof this.lexer.yylloc == "undefined")this.lexer.yylloc = {};
                var yyloc = this.lexer.yylloc;
                lstack.push(yyloc);
                if (typeof this.yy.parseError === "function")this.parseError = this.yy.parseError;
                function popStack(n) {
                    stack.length = stack.length - 2 * n;
                    vstack.length = vstack.length - n;
                    lstack.length = lstack.length - n
                }

                function lex() {
                    var token;
                    token = self.lexer.lex() || 1;
                    if (typeof token !== "number") {
                        token = self.symbols_[token] || token
                    }
                    return token
                }

                var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
                while (true) {
                    state = stack[stack.length - 1];
                    if (this.defaultActions[state]) {
                        action = this.defaultActions[state]
                    } else {
                        if (symbol == null)symbol = lex();
                        action = table[state] && table[state][symbol]
                    }
                    _handle_error:if (typeof action === "undefined" || !action.length || !action[0]) {
                        if (!recovering) {
                            expected = [];
                            for (p in table[state])if (this.terminals_[p] && p > 2) {
                                expected.push("'" + this.terminals_[p] + "'")
                            }
                            var errStr = "";
                            if (this.lexer.showPosition) {
                                errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + this.terminals_[symbol] + "'"
                            } else {
                                errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == 1 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'")
                            }
                            this.parseError(errStr, {text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected: expected})
                        }
                        if (recovering == 3) {
                            if (symbol == EOF) {
                                throw new Error(errStr || "Parsing halted.")
                            }
                            yyleng = this.lexer.yyleng;
                            yytext = this.lexer.yytext;
                            yylineno = this.lexer.yylineno;
                            yyloc = this.lexer.yylloc;
                            symbol = lex()
                        }
                        while (1) {
                            if (TERROR.toString()in table[state]) {
                                break
                            }
                            if (state == 0) {
                                throw new Error(errStr || "Parsing halted.")
                            }
                            popStack(1);
                            state = stack[stack.length - 1]
                        }
                        preErrorSymbol = symbol;
                        symbol = TERROR;
                        state = stack[stack.length - 1];
                        action = table[state] && table[state][TERROR];
                        recovering = 3
                    }
                    if (action[0]instanceof Array && action.length > 1) {
                        throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol)
                    }
                    switch (action[0]) {
                        case 1:
                            stack.push(symbol);
                            vstack.push(this.lexer.yytext);
                            lstack.push(this.lexer.yylloc);
                            stack.push(action[1]);
                            symbol = null;
                            if (!preErrorSymbol) {
                                yyleng = this.lexer.yyleng;
                                yytext = this.lexer.yytext;
                                yylineno = this.lexer.yylineno;
                                yyloc = this.lexer.yylloc;
                                if (recovering > 0)recovering--
                            } else {
                                symbol = preErrorSymbol;
                                preErrorSymbol = null
                            }
                            break;
                        case 2:
                            len = this.productions_[action[1]][1];
                            yyval.$ = vstack[vstack.length - len];
                            yyval._$ = {first_line: lstack[lstack.length - (len || 1)].first_line, last_line: lstack[lstack.length - 1].last_line, first_column: lstack[lstack.length - (len || 1)].first_column, last_column: lstack[lstack.length - 1].last_column};
                            r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
                            if (typeof r !== "undefined") {
                                return r
                            }
                            if (len) {
                                stack = stack.slice(0, -1 * len * 2);
                                vstack = vstack.slice(0, -1 * len);
                                lstack = lstack.slice(0, -1 * len)
                            }
                            stack.push(this.productions_[action[1]][0]);
                            vstack.push(yyval.$);
                            lstack.push(yyval._$);
                            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
                            stack.push(newState);
                            break;
                        case 3:
                            return true
                    }
                }
                return true
            }};
            var lexer = function () {
                var lexer = {EOF: 1, parseError: function parseError(str, hash) {
                    if (this.yy.parseError) {
                        this.yy.parseError(str, hash)
                    } else {
                        throw new Error(str)
                    }
                }, setInput: function (input) {
                    this._input = input;
                    this._more = this._less = this.done = false;
                    this.yylineno = this.yyleng = 0;
                    this.yytext = this.matched = this.match = "";
                    this.conditionStack = ["INITIAL"];
                    this.yylloc = {first_line: 1, first_column: 0, last_line: 1, last_column: 0};
                    return this
                }, input: function () {
                    var ch = this._input[0];
                    this.yytext += ch;
                    this.yyleng++;
                    this.match += ch;
                    this.matched += ch;
                    var lines = ch.match(/\n/);
                    if (lines)this.yylineno++;
                    this._input = this._input.slice(1);
                    return ch
                }, unput: function (ch) {
                    this._input = ch + this._input;
                    return this
                }, more: function () {
                    this._more = true;
                    return this
                }, pastInput: function () {
                    var past = this.matched.substr(0, this.matched.length - this.match.length);
                    return(past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "")
                }, upcomingInput: function () {
                    var next = this.match;
                    if (next.length < 20) {
                        next += this._input.substr(0, 20 - next.length)
                    }
                    return(next.substr(0, 20) + (next.length > 20 ? "..." : "")).replace(/\n/g, "")
                }, showPosition: function () {
                    var pre = this.pastInput();
                    var c = new Array(pre.length + 1).join("-");
                    return pre + this.upcomingInput() + "\n" + c + "^"
                }, next: function () {
                    if (this.done) {
                        return this.EOF
                    }
                    if (!this._input)this.done = true;
                    var token, match, col, lines;
                    if (!this._more) {
                        this.yytext = "";
                        this.match = ""
                    }
                    var rules = this._currentRules();
                    for (var i = 0; i < rules.length; i++) {
                        match = this._input.match(this.rules[rules[i]]);
                        if (match) {
                            lines = match[0].match(/\n.*/g);
                            if (lines)this.yylineno += lines.length;
                            this.yylloc = {first_line: this.yylloc.last_line, last_line: this.yylineno + 1, first_column: this.yylloc.last_column, last_column: lines ? lines[lines.length - 1].length - 1 : this.yylloc.last_column + match[0].length};
                            this.yytext += match[0];
                            this.match += match[0];
                            this.matches = match;
                            this.yyleng = this.yytext.length;
                            this._more = false;
                            this._input = this._input.slice(match[0].length);
                            this.matched += match[0];
                            token = this.performAction.call(this, this.yy, this, rules[i], this.conditionStack[this.conditionStack.length - 1]);
                            if (token)return token; else return
                        }
                    }
                    if (this._input === "") {
                        return this.EOF
                    } else {
                        this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {text: "", token: null, line: this.yylineno})
                    }
                }, lex: function lex() {
                    var r = this.next();
                    if (typeof r !== "undefined") {
                        return r
                    } else {
                        return this.lex()
                    }
                }, begin: function begin(condition) {
                    this.conditionStack.push(condition)
                }, popState: function popState() {
                    return this.conditionStack.pop()
                }, _currentRules: function _currentRules() {
                    return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules
                }, topState: function () {
                    return this.conditionStack[this.conditionStack.length - 2]
                }, pushState: function begin(condition) {
                    this.begin(condition)
                }};
                lexer.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
                    var YYSTATE = YY_START;
                    switch ($avoiding_name_collisions) {
                        case 0:
                            break;
                        case 1:
                            return 20;
                            break;
                        case 2:
                            return 19;
                            break;
                        case 3:
                            return 8;
                            break;
                        case 4:
                            return 9;
                            break;
                        case 5:
                            return 6;
                            break;
                        case 6:
                            return 7;
                            break;
                        case 7:
                            return 11;
                            break;
                        case 8:
                            return 13;
                            break;
                        case 9:
                            return 10;
                            break;
                        case 10:
                            return 12;
                            break;
                        case 11:
                            return 14;
                            break;
                        case 12:
                            return 15;
                            break;
                        case 13:
                            return 16;
                            break;
                        case 14:
                            return 17;
                            break;
                        case 15:
                            return 18;
                            break;
                        case 16:
                            return 5;
                            break;
                        case 17:
                            return"INVALID";
                            break
                    }
                };
                lexer.rules = [/^\s+/, /^[0-9]+(\.[0-9]+)?\b/, /^n\b/, /^\|\|/, /^&&/, /^\?/, /^:/, /^<=/, /^>=/, /^</, /^>/, /^!=/, /^==/, /^%/, /^\(/, /^\)/, /^$/, /^./];
                lexer.conditions = {INITIAL: {rules: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17], inclusive: true}};
                return lexer
            }();
            parser.lexer = lexer;
            return parser
        }();
        if (typeof exports !== "undefined") {
            if (typeof module !== "undefined" && module.exports) {
                exports = module.exports = Jed
            }
            exports.Jed = Jed
        } else {
            if (typeof define === "function" && define.amd) {
                define("jed", function () {
                    return Jed
                })
            }
            root["Jed"] = Jed
        }
    })(this)
}, {}], 54: [function (require, module, exports) {
    (function (global) {
        (function (undefined) {
            var moment, VERSION = "2.8.1", globalScope = typeof global !== "undefined" ? global : this, oldGlobalMoment, round = Math.round, i, YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, locales = {}, momentProperties = [], hasModule = typeof module !== "undefined" && module.exports, aspNetJsonRegex = /^\/?Date\((\-?\d+)/i, aspNetTimeSpanJsonRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/, isoDurationRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/, formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LT|LL?L?L?|l{1,4})/g, parseTokenOneOrTwoDigits = /\d\d?/, parseTokenOneToThreeDigits = /\d{1,3}/, parseTokenOneToFourDigits = /\d{1,4}/, parseTokenOneToSixDigits = /[+\-]?\d{1,6}/, parseTokenDigits = /\d+/, parseTokenWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/gi, parseTokenT = /T/i, parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/, parseTokenOrdinal = /\d{1,2}/, parseTokenOneDigit = /\d/, parseTokenTwoDigits = /\d\d/, parseTokenThreeDigits = /\d{3}/, parseTokenFourDigits = /\d{4}/, parseTokenSixDigits = /[+-]?\d{6}/, parseTokenSignedNumber = /[+-]?\d+/, isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/, isoFormat = "YYYY-MM-DDTHH:mm:ssZ", isoDates = [
                ["YYYYYY-MM-DD", /[+-]\d{6}-\d{2}-\d{2}/],
                ["YYYY-MM-DD", /\d{4}-\d{2}-\d{2}/],
                ["GGGG-[W]WW-E", /\d{4}-W\d{2}-\d/],
                ["GGGG-[W]WW", /\d{4}-W\d{2}/],
                ["YYYY-DDD", /\d{4}-\d{3}/]
            ], isoTimes = [
                ["HH:mm:ss.SSSS", /(T| )\d\d:\d\d:\d\d\.\d+/],
                ["HH:mm:ss", /(T| )\d\d:\d\d:\d\d/],
                ["HH:mm", /(T| )\d\d:\d\d/],
                ["HH", /(T| )\d\d/]
            ], parseTimezoneChunker = /([\+\-]|\d\d)/gi, proxyGettersAndSetters = "Date|Hours|Minutes|Seconds|Milliseconds".split("|"), unitMillisecondFactors = {Milliseconds: 1, Seconds: 1e3, Minutes: 6e4, Hours: 36e5, Days: 864e5, Months: 2592e6, Years: 31536e6}, unitAliases = {ms: "millisecond", s: "second", m: "minute", h: "hour", d: "day", D: "date", w: "week", W: "isoWeek", M: "month", Q: "quarter", y: "year", DDD: "dayOfYear", e: "weekday", E: "isoWeekday", gg: "weekYear", GG: "isoWeekYear"}, camelFunctions = {dayofyear: "dayOfYear", isoweekday: "isoWeekday", isoweek: "isoWeek", weekyear: "weekYear", isoweekyear: "isoWeekYear"}, formatFunctions = {}, relativeTimeThresholds = {s: 45, m: 45, h: 22, d: 26, M: 11}, ordinalizeTokens = "DDD w W M D d".split(" "), paddedTokens = "M D H h m s w W".split(" "), formatTokenFunctions = {M: function () {
                return this.month() + 1
            }, MMM: function (format) {
                return this.localeData().monthsShort(this, format)
            }, MMMM: function (format) {
                return this.localeData().months(this, format)
            }, D: function () {
                return this.date()
            }, DDD: function () {
                return this.dayOfYear()
            }, d: function () {
                return this.day()
            }, dd: function (format) {
                return this.localeData().weekdaysMin(this, format)
            }, ddd: function (format) {
                return this.localeData().weekdaysShort(this, format)
            }, dddd: function (format) {
                return this.localeData().weekdays(this, format)
            }, w: function () {
                return this.week()
            }, W: function () {
                return this.isoWeek()
            }, YY: function () {
                return leftZeroFill(this.year() % 100, 2)
            }, YYYY: function () {
                return leftZeroFill(this.year(), 4)
            }, YYYYY: function () {
                return leftZeroFill(this.year(), 5)
            }, YYYYYY: function () {
                var y = this.year(), sign = y >= 0 ? "+" : "-";
                return sign + leftZeroFill(Math.abs(y), 6)
            }, gg: function () {
                return leftZeroFill(this.weekYear() % 100, 2)
            }, gggg: function () {
                return leftZeroFill(this.weekYear(), 4)
            }, ggggg: function () {
                return leftZeroFill(this.weekYear(), 5)
            }, GG: function () {
                return leftZeroFill(this.isoWeekYear() % 100, 2)
            }, GGGG: function () {
                return leftZeroFill(this.isoWeekYear(), 4)
            }, GGGGG: function () {
                return leftZeroFill(this.isoWeekYear(), 5)
            }, e: function () {
                return this.weekday()
            }, E: function () {
                return this.isoWeekday()
            }, a: function () {
                return this.localeData().meridiem(this.hours(), this.minutes(), true)
            }, A: function () {
                return this.localeData().meridiem(this.hours(), this.minutes(), false)
            }, H: function () {
                return this.hours()
            }, h: function () {
                return this.hours() % 12 || 12
            }, m: function () {
                return this.minutes()
            }, s: function () {
                return this.seconds()
            }, S: function () {
                return toInt(this.milliseconds() / 100)
            }, SS: function () {
                return leftZeroFill(toInt(this.milliseconds() / 10), 2)
            }, SSS: function () {
                return leftZeroFill(this.milliseconds(), 3)
            }, SSSS: function () {
                return leftZeroFill(this.milliseconds(), 3)
            }, Z: function () {
                var a = -this.zone(), b = "+";
                if (a < 0) {
                    a = -a;
                    b = "-"
                }
                return b + leftZeroFill(toInt(a / 60), 2) + ":" + leftZeroFill(toInt(a) % 60, 2)
            }, ZZ: function () {
                var a = -this.zone(), b = "+";
                if (a < 0) {
                    a = -a;
                    b = "-"
                }
                return b + leftZeroFill(toInt(a / 60), 2) + leftZeroFill(toInt(a) % 60, 2)
            }, z: function () {
                return this.zoneAbbr()
            }, zz: function () {
                return this.zoneName()
            }, X: function () {
                return this.unix()
            }, Q: function () {
                return this.quarter()
            }}, deprecations = {}, lists = ["months", "monthsShort", "weekdays", "weekdaysShort", "weekdaysMin"];

            function dfl(a, b, c) {
                switch (arguments.length) {
                    case 2:
                        return a != null ? a : b;
                    case 3:
                        return a != null ? a : b != null ? b : c;
                    default:
                        throw new Error("Implement me")
                }
            }

            function defaultParsingFlags() {
                return{empty: false, unusedTokens: [], unusedInput: [], overflow: -2, charsLeftOver: 0, nullInput: false, invalidMonth: null, invalidFormat: false, userInvalidated: false, iso: false}
            }

            function printMsg(msg) {
                if (moment.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
                    console.warn("Deprecation warning: " + msg)
                }
            }

            function deprecate(msg, fn) {
                var firstTime = true;
                return extend(function () {
                    if (firstTime) {
                        printMsg(msg);
                        firstTime = false
                    }
                    return fn.apply(this, arguments)
                }, fn)
            }

            function deprecateSimple(name, msg) {
                if (!deprecations[name]) {
                    printMsg(msg);
                    deprecations[name] = true
                }
            }

            function padToken(func, count) {
                return function (a) {
                    return leftZeroFill(func.call(this, a), count)
                }
            }

            function ordinalizeToken(func, period) {
                return function (a) {
                    return this.localeData().ordinal(func.call(this, a), period)
                }
            }

            while (ordinalizeTokens.length) {
                i = ordinalizeTokens.pop();
                formatTokenFunctions[i + "o"] = ordinalizeToken(formatTokenFunctions[i], i)
            }
            while (paddedTokens.length) {
                i = paddedTokens.pop();
                formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2)
            }
            formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3);
            function Locale() {
            }

            function Moment(config, skipOverflow) {
                if (skipOverflow !== false) {
                    checkOverflow(config)
                }
                copyConfig(this, config);
                this._d = new Date(+config._d)
            }

            function Duration(duration) {
                var normalizedInput = normalizeObjectUnits(duration), years = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months = normalizedInput.month || 0, weeks = normalizedInput.week || 0, days = normalizedInput.day || 0, hours = normalizedInput.hour || 0, minutes = normalizedInput.minute || 0, seconds = normalizedInput.second || 0, milliseconds = normalizedInput.millisecond || 0;
                this._milliseconds = +milliseconds + seconds * 1e3 + minutes * 6e4 + hours * 36e5;
                this._days = +days + weeks * 7;
                this._months = +months + quarters * 3 + years * 12;
                this._data = {};
                this._locale = moment.localeData();
                this._bubble()
            }

            function extend(a, b) {
                for (var i in b) {
                    if (b.hasOwnProperty(i)) {
                        a[i] = b[i]
                    }
                }
                if (b.hasOwnProperty("toString")) {
                    a.toString = b.toString
                }
                if (b.hasOwnProperty("valueOf")) {
                    a.valueOf = b.valueOf
                }
                return a
            }

            function copyConfig(to, from) {
                var i, prop, val;
                if (typeof from._isAMomentObject !== "undefined") {
                    to._isAMomentObject = from._isAMomentObject
                }
                if (typeof from._i !== "undefined") {
                    to._i = from._i
                }
                if (typeof from._f !== "undefined") {
                    to._f = from._f
                }
                if (typeof from._l !== "undefined") {
                    to._l = from._l
                }
                if (typeof from._strict !== "undefined") {
                    to._strict = from._strict
                }
                if (typeof from._tzm !== "undefined") {
                    to._tzm = from._tzm
                }
                if (typeof from._isUTC !== "undefined") {
                    to._isUTC = from._isUTC
                }
                if (typeof from._offset !== "undefined") {
                    to._offset = from._offset
                }
                if (typeof from._pf !== "undefined") {
                    to._pf = from._pf
                }
                if (typeof from._locale !== "undefined") {
                    to._locale = from._locale
                }
                if (momentProperties.length > 0) {
                    for (i in momentProperties) {
                        prop = momentProperties[i];
                        val = from[prop];
                        if (typeof val !== "undefined") {
                            to[prop] = val
                        }
                    }
                }
                return to
            }

            function absRound(number) {
                if (number < 0) {
                    return Math.ceil(number)
                } else {
                    return Math.floor(number)
                }
            }

            function leftZeroFill(number, targetLength, forceSign) {
                var output = "" + Math.abs(number), sign = number >= 0;
                while (output.length < targetLength) {
                    output = "0" + output
                }
                return(sign ? forceSign ? "+" : "" : "-") + output
            }

            function positiveMomentsDifference(base, other) {
                var res = {milliseconds: 0, months: 0};
                res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
                if (base.clone().add(res.months, "M").isAfter(other)) {
                    --res.months
                }
                res.milliseconds = +other - +base.clone().add(res.months, "M");
                return res
            }

            function momentsDifference(base, other) {
                var res;
                other = makeAs(other, base);
                if (base.isBefore(other)) {
                    res = positiveMomentsDifference(base, other)
                } else {
                    res = positiveMomentsDifference(other, base);
                    res.milliseconds = -res.milliseconds;
                    res.months = -res.months
                }
                return res
            }

            function createAdder(direction, name) {
                return function (val, period) {
                    var dur, tmp;
                    if (period !== null && !isNaN(+period)) {
                        deprecateSimple(name, "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period).");
                        tmp = val;
                        val = period;
                        period = tmp
                    }
                    val = typeof val === "string" ? +val : val;
                    dur = moment.duration(val, period);
                    addOrSubtractDurationFromMoment(this, dur, direction);
                    return this
                }
            }

            function addOrSubtractDurationFromMoment(mom, duration, isAdding, updateOffset) {
                var milliseconds = duration._milliseconds, days = duration._days, months = duration._months;
                updateOffset = updateOffset == null ? true : updateOffset;
                if (milliseconds) {
                    mom._d.setTime(+mom._d + milliseconds * isAdding)
                }
                if (days) {
                    rawSetter(mom, "Date", rawGetter(mom, "Date") + days * isAdding)
                }
                if (months) {
                    rawMonthSetter(mom, rawGetter(mom, "Month") + months * isAdding)
                }
                if (updateOffset) {
                    moment.updateOffset(mom, days || months)
                }
            }

            function isArray(input) {
                return Object.prototype.toString.call(input) === "[object Array]"
            }

            function isDate(input) {
                return Object.prototype.toString.call(input) === "[object Date]" || input instanceof Date
            }

            function compareArrays(array1, array2, dontConvert) {
                var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
                for (i = 0; i < len; i++) {
                    if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
                        diffs++
                    }
                }
                return diffs + lengthDiff
            }

            function normalizeUnits(units) {
                if (units) {
                    var lowered = units.toLowerCase().replace(/(.)s$/, "$1");
                    units = unitAliases[units] || camelFunctions[lowered] || lowered
                }
                return units
            }

            function normalizeObjectUnits(inputObject) {
                var normalizedInput = {}, normalizedProp, prop;
                for (prop in inputObject) {
                    if (inputObject.hasOwnProperty(prop)) {
                        normalizedProp = normalizeUnits(prop);
                        if (normalizedProp) {
                            normalizedInput[normalizedProp] = inputObject[prop]
                        }
                    }
                }
                return normalizedInput
            }

            function makeList(field) {
                var count, setter;
                if (field.indexOf("week") === 0) {
                    count = 7;
                    setter = "day"
                } else if (field.indexOf("month") === 0) {
                    count = 12;
                    setter = "month"
                } else {
                    return
                }
                moment[field] = function (format, index) {
                    var i, getter, method = moment._locale[field], results = [];
                    if (typeof format === "number") {
                        index = format;
                        format = undefined
                    }
                    getter = function (i) {
                        var m = moment().utc().set(setter, i);
                        return method.call(moment._locale, m, format || "")
                    };
                    if (index != null) {
                        return getter(index)
                    } else {
                        for (i = 0; i < count; i++) {
                            results.push(getter(i))
                        }
                        return results
                    }
                }
            }

            function toInt(argumentForCoercion) {
                var coercedNumber = +argumentForCoercion, value = 0;
                if (coercedNumber !== 0 && isFinite(coercedNumber)) {
                    if (coercedNumber >= 0) {
                        value = Math.floor(coercedNumber)
                    } else {
                        value = Math.ceil(coercedNumber)
                    }
                }
                return value
            }

            function daysInMonth(year, month) {
                return new Date(Date.UTC(year, month + 1, 0)).getUTCDate()
            }

            function weeksInYear(year, dow, doy) {
                return weekOfYear(moment([year, 11, 31 + dow - doy]), dow, doy).week
            }

            function daysInYear(year) {
                return isLeapYear(year) ? 366 : 365
            }

            function isLeapYear(year) {
                return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0
            }

            function checkOverflow(m) {
                var overflow;
                if (m._a && m._pf.overflow === -2) {
                    overflow = m._a[MONTH] < 0 || m._a[MONTH] > 11 ? MONTH : m._a[DATE] < 1 || m._a[DATE] > daysInMonth(m._a[YEAR], m._a[MONTH]) ? DATE : m._a[HOUR] < 0 || m._a[HOUR] > 23 ? HOUR : m._a[MINUTE] < 0 || m._a[MINUTE] > 59 ? MINUTE : m._a[SECOND] < 0 || m._a[SECOND] > 59 ? SECOND : m._a[MILLISECOND] < 0 || m._a[MILLISECOND] > 999 ? MILLISECOND : -1;
                    if (m._pf._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                        overflow = DATE
                    }
                    m._pf.overflow = overflow
                }
            }

            function isValid(m) {
                if (m._isValid == null) {
                    m._isValid = !isNaN(m._d.getTime()) && m._pf.overflow < 0 && !m._pf.empty && !m._pf.invalidMonth && !m._pf.nullInput && !m._pf.invalidFormat && !m._pf.userInvalidated;
                    if (m._strict) {
                        m._isValid = m._isValid && m._pf.charsLeftOver === 0 && m._pf.unusedTokens.length === 0
                    }
                }
                return m._isValid
            }

            function normalizeLocale(key) {
                return key ? key.toLowerCase().replace("_", "-") : key
            }

            function chooseLocale(names) {
                var i = 0, j, next, locale, split;
                while (i < names.length) {
                    split = normalizeLocale(names[i]).split("-");
                    j = split.length;
                    next = normalizeLocale(names[i + 1]);
                    next = next ? next.split("-") : null;
                    while (j > 0) {
                        locale = loadLocale(split.slice(0, j).join("-"));
                        if (locale) {
                            return locale
                        }
                        if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                            break
                        }
                        j--
                    }
                    i++
                }
                return null
            }

            function loadLocale(name) {
                var oldLocale = null;
                if (!locales[name] && hasModule) {
                    try {
                        oldLocale = moment.locale();
                        require("./locale/" + name);
                        moment.locale(oldLocale)
                    } catch (e) {
                    }
                }
                return locales[name]
            }

            function makeAs(input, model) {
                return model._isUTC ? moment(input).zone(model._offset || 0) : moment(input).local()
            }

            extend(Locale.prototype, {set: function (config) {
                var prop, i;
                for (i in config) {
                    prop = config[i];
                    if (typeof prop === "function") {
                        this[i] = prop
                    } else {
                        this["_" + i] = prop
                    }
                }
            }, _months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), months: function (m) {
                return this._months[m.month()]
            }, _monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), monthsShort: function (m) {
                return this._monthsShort[m.month()]
            }, monthsParse: function (monthName) {
                var i, mom, regex;
                if (!this._monthsParse) {
                    this._monthsParse = []
                }
                for (i = 0; i < 12; i++) {
                    if (!this._monthsParse[i]) {
                        mom = moment.utc([2e3, i]);
                        regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
                        this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i")
                    }
                    if (this._monthsParse[i].test(monthName)) {
                        return i
                    }
                }
            }, _weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), weekdays: function (m) {
                return this._weekdays[m.day()]
            }, _weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), weekdaysShort: function (m) {
                return this._weekdaysShort[m.day()]
            }, _weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), weekdaysMin: function (m) {
                return this._weekdaysMin[m.day()]
            }, weekdaysParse: function (weekdayName) {
                var i, mom, regex;
                if (!this._weekdaysParse) {
                    this._weekdaysParse = []
                }
                for (i = 0; i < 7; i++) {
                    if (!this._weekdaysParse[i]) {
                        mom = moment([2e3, 1]).day(i);
                        regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
                        this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i")
                    }
                    if (this._weekdaysParse[i].test(weekdayName)) {
                        return i
                    }
                }
            }, _longDateFormat: {LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY LT", LLLL: "dddd, MMMM D, YYYY LT"}, longDateFormat: function (key) {
                var output = this._longDateFormat[key];
                if (!output && this._longDateFormat[key.toUpperCase()]) {
                    output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function (val) {
                        return val.slice(1)
                    });
                    this._longDateFormat[key] = output
                }
                return output
            }, isPM: function (input) {
                return(input + "").toLowerCase().charAt(0) === "p"
            }, _meridiemParse: /[ap]\.?m?\.?/i, meridiem: function (hours, minutes, isLower) {
                if (hours > 11) {
                    return isLower ? "pm" : "PM"
                } else {
                    return isLower ? "am" : "AM"
                }
            }, _calendar: {sameDay: "[Today at] LT", nextDay: "[Tomorrow at] LT", nextWeek: "dddd [at] LT", lastDay: "[Yesterday at] LT", lastWeek: "[Last] dddd [at] LT", sameElse: "L"}, calendar: function (key, mom) {
                var output = this._calendar[key];
                return typeof output === "function" ? output.apply(mom) : output
            }, _relativeTime: {future: "in %s", past: "%s ago", s: "a few seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years"}, relativeTime: function (number, withoutSuffix, string, isFuture) {
                var output = this._relativeTime[string];
                return typeof output === "function" ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number)
            }, pastFuture: function (diff, output) {
                var format = this._relativeTime[diff > 0 ? "future" : "past"];
                return typeof format === "function" ? format(output) : format.replace(/%s/i, output)
            }, ordinal: function (number) {
                return this._ordinal.replace("%d", number)
            }, _ordinal: "%d", preparse: function (string) {
                return string
            }, postformat: function (string) {
                return string
            }, week: function (mom) {
                return weekOfYear(mom, this._week.dow, this._week.doy).week
            }, _week: {dow: 0, doy: 6}, _invalidDate: "Invalid date", invalidDate: function () {
                return this._invalidDate
            }});
            function removeFormattingTokens(input) {
                if (input.match(/\[[\s\S]/)) {
                    return input.replace(/^\[|\]$/g, "")
                }
                return input.replace(/\\/g, "")
            }

            function makeFormatFunction(format) {
                var array = format.match(formattingTokens), i, length;
                for (i = 0, length = array.length; i < length; i++) {
                    if (formatTokenFunctions[array[i]]) {
                        array[i] = formatTokenFunctions[array[i]]
                    } else {
                        array[i] = removeFormattingTokens(array[i])
                    }
                }
                return function (mom) {
                    var output = "";
                    for (i = 0; i < length; i++) {
                        output += array[i]instanceof Function ? array[i].call(mom, format) : array[i]
                    }
                    return output
                }
            }

            function formatMoment(m, format) {
                if (!m.isValid()) {
                    return m.localeData().invalidDate()
                }
                format = expandFormat(format, m.localeData());
                if (!formatFunctions[format]) {
                    formatFunctions[format] = makeFormatFunction(format)
                }
                return formatFunctions[format](m)
            }

            function expandFormat(format, locale) {
                var i = 5;

                function replaceLongDateFormatTokens(input) {
                    return locale.longDateFormat(input) || input
                }

                localFormattingTokens.lastIndex = 0;
                while (i >= 0 && localFormattingTokens.test(format)) {
                    format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
                    localFormattingTokens.lastIndex = 0;
                    i -= 1
                }
                return format
            }

            function getParseRegexForToken(token, config) {
                var a, strict = config._strict;
                switch (token) {
                    case"Q":
                        return parseTokenOneDigit;
                    case"DDDD":
                        return parseTokenThreeDigits;
                    case"YYYY":
                    case"GGGG":
                    case"gggg":
                        return strict ? parseTokenFourDigits : parseTokenOneToFourDigits;
                    case"Y":
                    case"G":
                    case"g":
                        return parseTokenSignedNumber;
                    case"YYYYYY":
                    case"YYYYY":
                    case"GGGGG":
                    case"ggggg":
                        return strict ? parseTokenSixDigits : parseTokenOneToSixDigits;
                    case"S":
                        if (strict) {
                            return parseTokenOneDigit
                        }
                    case"SS":
                        if (strict) {
                            return parseTokenTwoDigits
                        }
                    case"SSS":
                        if (strict) {
                            return parseTokenThreeDigits
                        }
                    case"DDD":
                        return parseTokenOneToThreeDigits;
                    case"MMM":
                    case"MMMM":
                    case"dd":
                    case"ddd":
                    case"dddd":
                        return parseTokenWord;
                    case"a":
                    case"A":
                        return config._locale._meridiemParse;
                    case"X":
                        return parseTokenTimestampMs;
                    case"Z":
                    case"ZZ":
                        return parseTokenTimezone;
                    case"T":
                        return parseTokenT;
                    case"SSSS":
                        return parseTokenDigits;
                    case"MM":
                    case"DD":
                    case"YY":
                    case"GG":
                    case"gg":
                    case"HH":
                    case"hh":
                    case"mm":
                    case"ss":
                    case"ww":
                    case"WW":
                        return strict ? parseTokenTwoDigits : parseTokenOneOrTwoDigits;
                    case"M":
                    case"D":
                    case"d":
                    case"H":
                    case"h":
                    case"m":
                    case"s":
                    case"w":
                    case"W":
                    case"e":
                    case"E":
                        return parseTokenOneOrTwoDigits;
                    case"Do":
                        return parseTokenOrdinal;
                    default:
                        a = new RegExp(regexpEscape(unescapeFormat(token.replace("\\", "")), "i"));
                        return a
                }
            }

            function timezoneMinutesFromString(string) {
                string = string || "";
                var possibleTzMatches = string.match(parseTokenTimezone) || [], tzChunk = possibleTzMatches[possibleTzMatches.length - 1] || [], parts = (tzChunk + "").match(parseTimezoneChunker) || ["-", 0, 0], minutes = +(parts[1] * 60) + toInt(parts[2]);
                return parts[0] === "+" ? -minutes : minutes
            }

            function addTimeToArrayFromToken(token, input, config) {
                var a, datePartArray = config._a;
                switch (token) {
                    case"Q":
                        if (input != null) {
                            datePartArray[MONTH] = (toInt(input) - 1) * 3
                        }
                        break;
                    case"M":
                    case"MM":
                        if (input != null) {
                            datePartArray[MONTH] = toInt(input) - 1
                        }
                        break;
                    case"MMM":
                    case"MMMM":
                        a = config._locale.monthsParse(input);
                        if (a != null) {
                            datePartArray[MONTH] = a
                        } else {
                            config._pf.invalidMonth = input
                        }
                        break;
                    case"D":
                    case"DD":
                        if (input != null) {
                            datePartArray[DATE] = toInt(input)
                        }
                        break;
                    case"Do":
                        if (input != null) {
                            datePartArray[DATE] = toInt(parseInt(input, 10))
                        }
                        break;
                    case"DDD":
                    case"DDDD":
                        if (input != null) {
                            config._dayOfYear = toInt(input)
                        }
                        break;
                    case"YY":
                        datePartArray[YEAR] = moment.parseTwoDigitYear(input);
                        break;
                    case"YYYY":
                    case"YYYYY":
                    case"YYYYYY":
                        datePartArray[YEAR] = toInt(input);
                        break;
                    case"a":
                    case"A":
                        config._isPm = config._locale.isPM(input);
                        break;
                    case"H":
                    case"HH":
                    case"h":
                    case"hh":
                        datePartArray[HOUR] = toInt(input);
                        break;
                    case"m":
                    case"mm":
                        datePartArray[MINUTE] = toInt(input);
                        break;
                    case"s":
                    case"ss":
                        datePartArray[SECOND] = toInt(input);
                        break;
                    case"S":
                    case"SS":
                    case"SSS":
                    case"SSSS":
                        datePartArray[MILLISECOND] = toInt(("0." + input) * 1e3);
                        break;
                    case"X":
                        config._d = new Date(parseFloat(input) * 1e3);
                        break;
                    case"Z":
                    case"ZZ":
                        config._useUTC = true;
                        config._tzm = timezoneMinutesFromString(input);
                        break;
                    case"dd":
                    case"ddd":
                    case"dddd":
                        a = config._locale.weekdaysParse(input);
                        if (a != null) {
                            config._w = config._w || {};
                            config._w["d"] = a
                        } else {
                            config._pf.invalidWeekday = input
                        }
                        break;
                    case"w":
                    case"ww":
                    case"W":
                    case"WW":
                    case"d":
                    case"e":
                    case"E":
                        token = token.substr(0, 1);
                    case"gggg":
                    case"GGGG":
                    case"GGGGG":
                        token = token.substr(0, 2);
                        if (input) {
                            config._w = config._w || {};
                            config._w[token] = toInt(input)
                        }
                        break;
                    case"gg":
                    case"GG":
                        config._w = config._w || {};
                        config._w[token] = moment.parseTwoDigitYear(input)
                }
            }

            function dayOfYearFromWeekInfo(config) {
                var w, weekYear, week, weekday, dow, doy, temp;
                w = config._w;
                if (w.GG != null || w.W != null || w.E != null) {
                    dow = 1;
                    doy = 4;
                    weekYear = dfl(w.GG, config._a[YEAR], weekOfYear(moment(), 1, 4).year);
                    week = dfl(w.W, 1);
                    weekday = dfl(w.E, 1)
                } else {
                    dow = config._locale._week.dow;
                    doy = config._locale._week.doy;
                    weekYear = dfl(w.gg, config._a[YEAR], weekOfYear(moment(), dow, doy).year);
                    week = dfl(w.w, 1);
                    if (w.d != null) {
                        weekday = w.d;
                        if (weekday < dow) {
                            ++week
                        }
                    } else if (w.e != null) {
                        weekday = w.e + dow
                    } else {
                        weekday = dow
                    }
                }
                temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow);
                config._a[YEAR] = temp.year;
                config._dayOfYear = temp.dayOfYear
            }

            function dateFromConfig(config) {
                var i, date, input = [], currentDate, yearToUse;
                if (config._d) {
                    return
                }
                currentDate = currentDateArray(config);
                if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
                    dayOfYearFromWeekInfo(config)
                }
                if (config._dayOfYear) {
                    yearToUse = dfl(config._a[YEAR], currentDate[YEAR]);
                    if (config._dayOfYear > daysInYear(yearToUse)) {
                        config._pf._overflowDayOfYear = true
                    }
                    date = makeUTCDate(yearToUse, 0, config._dayOfYear);
                    config._a[MONTH] = date.getUTCMonth();
                    config._a[DATE] = date.getUTCDate()
                }
                for (i = 0; i < 3 && config._a[i] == null; ++i) {
                    config._a[i] = input[i] = currentDate[i]
                }
                for (; i < 7; i++) {
                    config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i]
                }
                config._d = (config._useUTC ? makeUTCDate : makeDate).apply(null, input);
                if (config._tzm != null) {
                    config._d.setUTCMinutes(config._d.getUTCMinutes() + config._tzm)
                }
            }

            function dateFromObject(config) {
                var normalizedInput;
                if (config._d) {
                    return
                }
                normalizedInput = normalizeObjectUnits(config._i);
                config._a = [normalizedInput.year, normalizedInput.month, normalizedInput.day, normalizedInput.hour, normalizedInput.minute, normalizedInput.second, normalizedInput.millisecond];
                dateFromConfig(config)
            }

            function currentDateArray(config) {
                var now = new Date;
                if (config._useUTC) {
                    return[now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()]
                } else {
                    return[now.getFullYear(), now.getMonth(), now.getDate()]
                }
            }

            function makeDateFromStringAndFormat(config) {
                if (config._f === moment.ISO_8601) {
                    parseISO(config);
                    return
                }
                config._a = [];
                config._pf.empty = true;
                var string = "" + config._i, i, parsedInput, tokens, token, skipped, stringLength = string.length, totalParsedInputLength = 0;
                tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];
                for (i = 0; i < tokens.length; i++) {
                    token = tokens[i];
                    parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
                    if (parsedInput) {
                        skipped = string.substr(0, string.indexOf(parsedInput));
                        if (skipped.length > 0) {
                            config._pf.unusedInput.push(skipped)
                        }
                        string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                        totalParsedInputLength += parsedInput.length
                    }
                    if (formatTokenFunctions[token]) {
                        if (parsedInput) {
                            config._pf.empty = false
                        } else {
                            config._pf.unusedTokens.push(token)
                        }
                        addTimeToArrayFromToken(token, parsedInput, config)
                    } else if (config._strict && !parsedInput) {
                        config._pf.unusedTokens.push(token)
                    }
                }
                config._pf.charsLeftOver = stringLength - totalParsedInputLength;
                if (string.length > 0) {
                    config._pf.unusedInput.push(string)
                }
                if (config._isPm && config._a[HOUR] < 12) {
                    config._a[HOUR] += 12
                }
                if (config._isPm === false && config._a[HOUR] === 12) {
                    config._a[HOUR] = 0
                }
                dateFromConfig(config);
                checkOverflow(config)
            }

            function unescapeFormat(s) {
                return s.replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
                    return p1 || p2 || p3 || p4
                })
            }

            function regexpEscape(s) {
                return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&")
            }

            function makeDateFromStringAndArray(config) {
                var tempConfig, bestMoment, scoreToBeat, i, currentScore;
                if (config._f.length === 0) {
                    config._pf.invalidFormat = true;
                    config._d = new Date(NaN);
                    return
                }
                for (i = 0; i < config._f.length; i++) {
                    currentScore = 0;
                    tempConfig = copyConfig({}, config);
                    tempConfig._pf = defaultParsingFlags();
                    tempConfig._f = config._f[i];
                    makeDateFromStringAndFormat(tempConfig);
                    if (!isValid(tempConfig)) {
                        continue
                    }
                    currentScore += tempConfig._pf.charsLeftOver;
                    currentScore += tempConfig._pf.unusedTokens.length * 10;
                    tempConfig._pf.score = currentScore;
                    if (scoreToBeat == null || currentScore < scoreToBeat) {
                        scoreToBeat = currentScore;
                        bestMoment = tempConfig
                    }
                }
                extend(config, bestMoment || tempConfig)
            }

            function parseISO(config) {
                var i, l, string = config._i, match = isoRegex.exec(string);
                if (match) {
                    config._pf.iso = true;
                    for (i = 0, l = isoDates.length; i < l; i++) {
                        if (isoDates[i][1].exec(string)) {
                            config._f = isoDates[i][0] + (match[6] || " ");
                            break
                        }
                    }
                    for (i = 0, l = isoTimes.length; i < l; i++) {
                        if (isoTimes[i][1].exec(string)) {
                            config._f += isoTimes[i][0];
                            break
                        }
                    }
                    if (string.match(parseTokenTimezone)) {
                        config._f += "Z"
                    }
                    makeDateFromStringAndFormat(config)
                } else {
                    config._isValid = false
                }
            }

            function makeDateFromString(config) {
                parseISO(config);
                if (config._isValid === false) {
                    delete config._isValid;
                    moment.createFromInputFallback(config)
                }
            }

            function makeDateFromInput(config) {
                var input = config._i, matched;
                if (input === undefined) {
                    config._d = new Date
                } else if (isDate(input)) {
                    config._d = new Date(+input)
                } else if ((matched = aspNetJsonRegex.exec(input)) !== null) {
                    config._d = new Date(+matched[1])
                } else if (typeof input === "string") {
                    makeDateFromString(config)
                } else if (isArray(input)) {
                    config._a = input.slice(0);
                    dateFromConfig(config)
                } else if (typeof input === "object") {
                    dateFromObject(config)
                } else if (typeof input === "number") {
                    config._d = new Date(input)
                } else {
                    moment.createFromInputFallback(config)
                }
            }

            function makeDate(y, m, d, h, M, s, ms) {
                var date = new Date(y, m, d, h, M, s, ms);
                if (y < 1970) {
                    date.setFullYear(y)
                }
                return date
            }

            function makeUTCDate(y) {
                var date = new Date(Date.UTC.apply(null, arguments));
                if (y < 1970) {
                    date.setUTCFullYear(y)
                }
                return date
            }

            function parseWeekday(input, locale) {
                if (typeof input === "string") {
                    if (!isNaN(input)) {
                        input = parseInt(input, 10)
                    } else {
                        input = locale.weekdaysParse(input);
                        if (typeof input !== "number") {
                            return null
                        }
                    }
                }
                return input
            }

            function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
                return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture)
            }

            function relativeTime(posNegDuration, withoutSuffix, locale) {
                var duration = moment.duration(posNegDuration).abs(), seconds = round(duration.as("s")), minutes = round(duration.as("m")), hours = round(duration.as("h")), days = round(duration.as("d")), months = round(duration.as("M")), years = round(duration.as("y")), args = seconds < relativeTimeThresholds.s && ["s", seconds] || minutes === 1 && ["m"] || minutes < relativeTimeThresholds.m && ["mm", minutes] || hours === 1 && ["h"] || hours < relativeTimeThresholds.h && ["hh", hours] || days === 1 && ["d"] || days < relativeTimeThresholds.d && ["dd", days] || months === 1 && ["M"] || months < relativeTimeThresholds.M && ["MM", months] || years === 1 && ["y"] || ["yy", years];
                args[2] = withoutSuffix;
                args[3] = +posNegDuration > 0;
                args[4] = locale;
                return substituteTimeAgo.apply({}, args)
            }

            function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
                var end = firstDayOfWeekOfYear - firstDayOfWeek, daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(), adjustedMoment;
                if (daysToDayOfWeek > end) {
                    daysToDayOfWeek -= 7
                }
                if (daysToDayOfWeek < end - 7) {
                    daysToDayOfWeek += 7
                }
                adjustedMoment = moment(mom).add(daysToDayOfWeek, "d");
                return{week: Math.ceil(adjustedMoment.dayOfYear() / 7), year: adjustedMoment.year()}
            }

            function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
                var d = makeUTCDate(year, 0, 1).getUTCDay(), daysToAdd, dayOfYear;
                d = d === 0 ? 7 : d;
                weekday = weekday != null ? weekday : firstDayOfWeek;
                daysToAdd = firstDayOfWeek - d + (d > firstDayOfWeekOfYear ? 7 : 0) - (d < firstDayOfWeek ? 7 : 0);
                dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1;
                return{year: dayOfYear > 0 ? year : year - 1, dayOfYear: dayOfYear > 0 ? dayOfYear : daysInYear(year - 1) + dayOfYear}
            }

            function makeMoment(config) {
                var input = config._i, format = config._f;
                config._locale = config._locale || moment.localeData(config._l);
                if (input === null || format === undefined && input === "") {
                    return moment.invalid({nullInput: true})
                }
                if (typeof input === "string") {
                    config._i = input = config._locale.preparse(input)
                }
                if (moment.isMoment(input)) {
                    return new Moment(input, true)
                } else if (format) {
                    if (isArray(format)) {
                        makeDateFromStringAndArray(config)
                    } else {
                        makeDateFromStringAndFormat(config)
                    }
                } else {
                    makeDateFromInput(config)
                }
                return new Moment(config)
            }

            moment = function (input, format, locale, strict) {
                var c;
                if (typeof locale === "boolean") {
                    strict = locale;
                    locale = undefined
                }
                c = {};
                c._isAMomentObject = true;
                c._i = input;
                c._f = format;
                c._l = locale;
                c._strict = strict;
                c._isUTC = false;
                c._pf = defaultParsingFlags();
                return makeMoment(c)
            };
            moment.suppressDeprecationWarnings = false;
            moment.createFromInputFallback = deprecate("moment construction falls back to js Date. This is " + "discouraged and will be removed in upcoming major " + "release. Please refer to " + "https://github.com/moment/moment/issues/1407 for more info.", function (config) {
                config._d = new Date(config._i)
            });
            function pickBy(fn, moments) {
                var res, i;
                if (moments.length === 1 && isArray(moments[0])) {
                    moments = moments[0]
                }
                if (!moments.length) {
                    return moment()
                }
                res = moments[0];
                for (i = 1; i < moments.length; ++i) {
                    if (moments[i][fn](res)) {
                        res = moments[i]
                    }
                }
                return res
            }

            moment.min = function () {
                var args = [].slice.call(arguments, 0);
                return pickBy("isBefore", args)
            };
            moment.max = function () {
                var args = [].slice.call(arguments, 0);
                return pickBy("isAfter", args)
            };
            moment.utc = function (input, format, locale, strict) {
                var c;
                if (typeof locale === "boolean") {
                    strict = locale;
                    locale = undefined
                }
                c = {};
                c._isAMomentObject = true;
                c._useUTC = true;
                c._isUTC = true;
                c._l = locale;
                c._i = input;
                c._f = format;
                c._strict = strict;
                c._pf = defaultParsingFlags();
                return makeMoment(c).utc()
            };
            moment.unix = function (input) {
                return moment(input * 1e3)
            };
            moment.duration = function (input, key) {
                var duration = input, match = null, sign, ret, parseIso, diffRes;
                if (moment.isDuration(input)) {
                    duration = {ms: input._milliseconds, d: input._days, M: input._months}
                } else if (typeof input === "number") {
                    duration = {};
                    if (key) {
                        duration[key] = input
                    } else {
                        duration.milliseconds = input
                    }
                } else if (!!(match = aspNetTimeSpanJsonRegex.exec(input))) {
                    sign = match[1] === "-" ? -1 : 1;
                    duration = {y: 0, d: toInt(match[DATE]) * sign, h: toInt(match[HOUR]) * sign, m: toInt(match[MINUTE]) * sign, s: toInt(match[SECOND]) * sign, ms: toInt(match[MILLISECOND]) * sign}
                } else if (!!(match = isoDurationRegex.exec(input))) {
                    sign = match[1] === "-" ? -1 : 1;
                    parseIso = function (inp) {
                        var res = inp && parseFloat(inp.replace(",", "."));
                        return(isNaN(res) ? 0 : res) * sign
                    };
                    duration = {y: parseIso(match[2]), M: parseIso(match[3]), d: parseIso(match[4]), h: parseIso(match[5]), m: parseIso(match[6]), s: parseIso(match[7]), w: parseIso(match[8])}
                } else if (typeof duration === "object" && ("from"in duration || "to"in duration)) {
                    diffRes = momentsDifference(moment(duration.from), moment(duration.to));
                    duration = {};
                    duration.ms = diffRes.milliseconds;
                    duration.M = diffRes.months
                }
                ret = new Duration(duration);
                if (moment.isDuration(input) && input.hasOwnProperty("_locale")) {
                    ret._locale = input._locale
                }
                return ret
            };
            moment.version = VERSION;
            moment.defaultFormat = isoFormat;
            moment.ISO_8601 = function () {
            };
            moment.momentProperties = momentProperties;
            moment.updateOffset = function () {
            };
            moment.relativeTimeThreshold = function (threshold, limit) {
                if (relativeTimeThresholds[threshold] === undefined) {
                    return false
                }
                if (limit === undefined) {
                    return relativeTimeThresholds[threshold]
                }
                relativeTimeThresholds[threshold] = limit;
                return true
            };
            moment.lang = deprecate("moment.lang is deprecated. Use moment.locale instead.", function (key, value) {
                return moment.locale(key, value)
            });
            moment.locale = function (key, values) {
                var data;
                if (key) {
                    if (typeof values !== "undefined") {
                        data = moment.defineLocale(key, values)
                    } else {
                        data = moment.localeData(key)
                    }
                    if (data) {
                        moment.duration._locale = moment._locale = data
                    }
                }
                return moment._locale._abbr
            };
            moment.defineLocale = function (name, values) {
                if (values !== null) {
                    values.abbr = name;
                    if (!locales[name]) {
                        locales[name] = new Locale
                    }
                    locales[name].set(values);
                    moment.locale(name);
                    return locales[name]
                } else {
                    delete locales[name];
                    return null
                }
            };
            moment.langData = deprecate("moment.langData is deprecated. Use moment.localeData instead.", function (key) {
                return moment.localeData(key)
            });
            moment.localeData = function (key) {
                var locale;
                if (key && key._locale && key._locale._abbr) {
                    key = key._locale._abbr
                }
                if (!key) {
                    return moment._locale
                }
                if (!isArray(key)) {
                    locale = loadLocale(key);
                    if (locale) {
                        return locale
                    }
                    key = [key]
                }
                return chooseLocale(key)
            };
            moment.isMoment = function (obj) {
                return obj instanceof Moment || obj != null && obj.hasOwnProperty("_isAMomentObject")
            };
            moment.isDuration = function (obj) {
                return obj instanceof Duration
            };
            for (i = lists.length - 1; i >= 0; --i) {
                makeList(lists[i])
            }
            moment.normalizeUnits = function (units) {
                return normalizeUnits(units)
            };
            moment.invalid = function (flags) {
                var m = moment.utc(NaN);
                if (flags != null) {
                    extend(m._pf, flags)
                } else {
                    m._pf.userInvalidated = true
                }
                return m
            };
            moment.parseZone = function () {
                return moment.apply(null, arguments).parseZone()
            };
            moment.parseTwoDigitYear = function (input) {
                return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3)
            };
            extend(moment.fn = Moment.prototype, {clone: function () {
                return moment(this)
            }, valueOf: function () {
                return+this._d + (this._offset || 0) * 6e4
            }, unix: function () {
                return Math.floor(+this / 1e3)
            }, toString: function () {
                return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")
            }, toDate: function () {
                return this._offset ? new Date(+this) : this._d
            }, toISOString: function () {
                var m = moment(this).utc();
                if (0 < m.year() && m.year() <= 9999) {
                    return formatMoment(m, "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]")
                } else {
                    return formatMoment(m, "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]")
                }
            }, toArray: function () {
                var m = this;
                return[m.year(), m.month(), m.date(), m.hours(), m.minutes(), m.seconds(), m.milliseconds()]
            }, isValid: function () {
                return isValid(this)
            }, isDSTShifted: function () {
                if (this._a) {
                    return this.isValid() && compareArrays(this._a, (this._isUTC ? moment.utc(this._a) : moment(this._a)).toArray()) > 0
                }
                return false
            }, parsingFlags: function () {
                return extend({}, this._pf)
            }, invalidAt: function () {
                return this._pf.overflow
            }, utc: function (keepLocalTime) {
                return this.zone(0, keepLocalTime)
            }, local: function (keepLocalTime) {
                if (this._isUTC) {
                    this.zone(0, keepLocalTime);
                    this._isUTC = false;
                    if (keepLocalTime) {
                        this.add(this._d.getTimezoneOffset(), "m")
                    }
                }
                return this
            }, format: function (inputString) {
                var output = formatMoment(this, inputString || moment.defaultFormat);
                return this.localeData().postformat(output)
            }, add: createAdder(1, "add"), subtract: createAdder(-1, "subtract"), diff: function (input, units, asFloat) {
                var that = makeAs(input, this), zoneDiff = (this.zone() - that.zone()) * 6e4, diff, output;
                units = normalizeUnits(units);
                if (units === "year" || units === "month") {
                    diff = (this.daysInMonth() + that.daysInMonth()) * 432e5;
                    output = (this.year() - that.year()) * 12 + (this.month() - that.month());
                    output += (this - moment(this).startOf("month") - (that - moment(that).startOf("month"))) / diff;
                    output -= (this.zone() - moment(this).startOf("month").zone() - (that.zone() - moment(that).startOf("month").zone())) * 6e4 / diff;
                    if (units === "year") {
                        output = output / 12
                    }
                } else {
                    diff = this - that;
                    output = units === "second" ? diff / 1e3 : units === "minute" ? diff / 6e4 : units === "hour" ? diff / 36e5 : units === "day" ? (diff - zoneDiff) / 864e5 : units === "week" ? (diff - zoneDiff) / 6048e5 : diff
                }
                return asFloat ? output : absRound(output)
            }, from: function (time, withoutSuffix) {
                return moment.duration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix)
            }, fromNow: function (withoutSuffix) {
                return this.from(moment(), withoutSuffix)
            }, calendar: function (time) {
                var now = time || moment(), sod = makeAs(now, this).startOf("day"), diff = this.diff(sod, "days", true), format = diff < -6 ? "sameElse" : diff < -1 ? "lastWeek" : diff < 0 ? "lastDay" : diff < 1 ? "sameDay" : diff < 2 ? "nextDay" : diff < 7 ? "nextWeek" : "sameElse";
                return this.format(this.localeData().calendar(format, this))
            }, isLeapYear: function () {
                return isLeapYear(this.year())
            }, isDST: function () {
                return this.zone() < this.clone().month(0).zone() || this.zone() < this.clone().month(5).zone()
            }, day: function (input) {
                var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
                if (input != null) {
                    input = parseWeekday(input, this.localeData());
                    return this.add(input - day, "d")
                } else {
                    return day
                }
            }, month: makeAccessor("Month", true), startOf: function (units) {
                units = normalizeUnits(units);
                switch (units) {
                    case"year":
                        this.month(0);
                    case"quarter":
                    case"month":
                        this.date(1);
                    case"week":
                    case"isoWeek":
                    case"day":
                        this.hours(0);
                    case"hour":
                        this.minutes(0);
                    case"minute":
                        this.seconds(0);
                    case"second":
                        this.milliseconds(0)
                }
                if (units === "week") {
                    this.weekday(0)
                } else if (units === "isoWeek") {
                    this.isoWeekday(1)
                }
                if (units === "quarter") {
                    this.month(Math.floor(this.month() / 3) * 3)
                }
                return this
            }, endOf: function (units) {
                units = normalizeUnits(units);
                return this.startOf(units).add(1, units === "isoWeek" ? "week" : units).subtract(1, "ms")
            }, isAfter: function (input, units) {
                units = typeof units !== "undefined" ? units : "millisecond";
                return+this.clone().startOf(units) > +moment(input).startOf(units)
            }, isBefore: function (input, units) {
                units = typeof units !== "undefined" ? units : "millisecond";
                return+this.clone().startOf(units) < +moment(input).startOf(units)
            }, isSame: function (input, units) {
                units = units || "ms";
                return+this.clone().startOf(units) === +makeAs(input, this).startOf(units)
            }, min: deprecate("moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548", function (other) {
                other = moment.apply(null, arguments);
                return other < this ? this : other
            }), max: deprecate("moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548", function (other) {
                other = moment.apply(null, arguments);
                return other > this ? this : other
            }), zone: function (input, keepLocalTime) {
                var offset = this._offset || 0, localAdjust;
                if (input != null) {
                    if (typeof input === "string") {
                        input = timezoneMinutesFromString(input)
                    }
                    if (Math.abs(input) < 16) {
                        input = input * 60
                    }
                    if (!this._isUTC && keepLocalTime) {
                        localAdjust = this._d.getTimezoneOffset()
                    }
                    this._offset = input;
                    this._isUTC = true;
                    if (localAdjust != null) {
                        this.subtract(localAdjust, "m")
                    }
                    if (offset !== input) {
                        if (!keepLocalTime || this._changeInProgress) {
                            addOrSubtractDurationFromMoment(this, moment.duration(offset - input, "m"), 1, false)
                        } else if (!this._changeInProgress) {
                            this._changeInProgress = true;
                            moment.updateOffset(this, true);
                            this._changeInProgress = null
                        }
                    }
                } else {
                    return this._isUTC ? offset : this._d.getTimezoneOffset()
                }
                return this
            }, zoneAbbr: function () {
                return this._isUTC ? "UTC" : ""
            }, zoneName: function () {
                return this._isUTC ? "Coordinated Universal Time" : ""
            }, parseZone: function () {
                if (this._tzm) {
                    this.zone(this._tzm)
                } else if (typeof this._i === "string") {
                    this.zone(this._i)
                }
                return this
            }, hasAlignedHourOffset: function (input) {
                if (!input) {
                    input = 0
                } else {
                    input = moment(input).zone()
                }
                return(this.zone() - input) % 60 === 0
            }, daysInMonth: function () {
                return daysInMonth(this.year(), this.month())
            }, dayOfYear: function (input) {
                var dayOfYear = round((moment(this).startOf("day") - moment(this).startOf("year")) / 864e5) + 1;
                return input == null ? dayOfYear : this.add(input - dayOfYear, "d")
            }, quarter: function (input) {
                return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3)
            }, weekYear: function (input) {
                var year = weekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).year;
                return input == null ? year : this.add(input - year, "y")
            }, isoWeekYear: function (input) {
                var year = weekOfYear(this, 1, 4).year;
                return input == null ? year : this.add(input - year, "y")
            }, week: function (input) {
                var week = this.localeData().week(this);
                return input == null ? week : this.add((input - week) * 7, "d")
            }, isoWeek: function (input) {
                var week = weekOfYear(this, 1, 4).week;
                return input == null ? week : this.add((input - week) * 7, "d")
            }, weekday: function (input) {
                var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
                return input == null ? weekday : this.add(input - weekday, "d")
            }, isoWeekday: function (input) {
                return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7)
            }, isoWeeksInYear: function () {
                return weeksInYear(this.year(), 1, 4)
            }, weeksInYear: function () {
                var weekInfo = this.localeData()._week;
                return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy)
            }, get: function (units) {
                units = normalizeUnits(units);
                return this[units]()
            }, set: function (units, value) {
                units = normalizeUnits(units);
                if (typeof this[units] === "function") {
                    this[units](value)
                }
                return this
            }, locale: function (key) {
                if (key === undefined) {
                    return this._locale._abbr
                } else {
                    this._locale = moment.localeData(key);
                    return this
                }
            }, lang: deprecate("moment().lang() is deprecated. Use moment().localeData() instead.", function (key) {
                if (key === undefined) {
                    return this.localeData()
                } else {
                    this._locale = moment.localeData(key);
                    return this
                }
            }), localeData: function () {
                return this._locale
            }});
            function rawMonthSetter(mom, value) {
                var dayOfMonth;
                if (typeof value === "string") {
                    value = mom.localeData().monthsParse(value);
                    if (typeof value !== "number") {
                        return mom
                    }
                }
                dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
                mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
                return mom
            }

            function rawGetter(mom, unit) {
                return mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]()
            }

            function rawSetter(mom, unit, value) {
                if (unit === "Month") {
                    return rawMonthSetter(mom, value)
                } else {
                    return mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value)
                }
            }

            function makeAccessor(unit, keepTime) {
                return function (value) {
                    if (value != null) {
                        rawSetter(this, unit, value);
                        moment.updateOffset(this, keepTime);
                        return this
                    } else {
                        return rawGetter(this, unit)
                    }
                }
            }

            moment.fn.millisecond = moment.fn.milliseconds = makeAccessor("Milliseconds", false);
            moment.fn.second = moment.fn.seconds = makeAccessor("Seconds", false);
            moment.fn.minute = moment.fn.minutes = makeAccessor("Minutes", false);
            moment.fn.hour = moment.fn.hours = makeAccessor("Hours", true);
            moment.fn.date = makeAccessor("Date", true);
            moment.fn.dates = deprecate("dates accessor is deprecated. Use date instead.", makeAccessor("Date", true));
            moment.fn.year = makeAccessor("FullYear", true);
            moment.fn.years = deprecate("years accessor is deprecated. Use year instead.", makeAccessor("FullYear", true));
            moment.fn.days = moment.fn.day;
            moment.fn.months = moment.fn.month;
            moment.fn.weeks = moment.fn.week;
            moment.fn.isoWeeks = moment.fn.isoWeek;
            moment.fn.quarters = moment.fn.quarter;
            moment.fn.toJSON = moment.fn.toISOString;
            function daysToYears(days) {
                return days * 400 / 146097
            }

            function yearsToDays(years) {
                return years * 146097 / 400
            }

            extend(moment.duration.fn = Duration.prototype, {_bubble: function () {
                var milliseconds = this._milliseconds, days = this._days, months = this._months, data = this._data, seconds, minutes, hours, years = 0;
                data.milliseconds = milliseconds % 1e3;
                seconds = absRound(milliseconds / 1e3);
                data.seconds = seconds % 60;
                minutes = absRound(seconds / 60);
                data.minutes = minutes % 60;
                hours = absRound(minutes / 60);
                data.hours = hours % 24;
                days += absRound(hours / 24);
                years = absRound(daysToYears(days));
                days -= absRound(yearsToDays(years));
                months += absRound(days / 30);
                days %= 30;
                years += absRound(months / 12);
                months %= 12;
                data.days = days;
                data.months = months;
                data.years = years
            }, abs: function () {
                this._milliseconds = Math.abs(this._milliseconds);
                this._days = Math.abs(this._days);
                this._months = Math.abs(this._months);
                this._data.milliseconds = Math.abs(this._data.milliseconds);
                this._data.seconds = Math.abs(this._data.seconds);
                this._data.minutes = Math.abs(this._data.minutes);
                this._data.hours = Math.abs(this._data.hours);
                this._data.months = Math.abs(this._data.months);
                this._data.years = Math.abs(this._data.years);
                return this
            }, weeks: function () {
                return absRound(this.days() / 7)
            }, valueOf: function () {
                return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6
            }, humanize: function (withSuffix) {
                var output = relativeTime(this, !withSuffix, this.localeData());
                if (withSuffix) {
                    output = this.localeData().pastFuture(+this, output)
                }
                return this.localeData().postformat(output)
            }, add: function (input, val) {
                var dur = moment.duration(input, val);
                this._milliseconds += dur._milliseconds;
                this._days += dur._days;
                this._months += dur._months;
                this._bubble();
                return this
            }, subtract: function (input, val) {
                var dur = moment.duration(input, val);
                this._milliseconds -= dur._milliseconds;
                this._days -= dur._days;
                this._months -= dur._months;
                this._bubble();
                return this
            }, get: function (units) {
                units = normalizeUnits(units);
                return this[units.toLowerCase() + "s"]()
            }, as: function (units) {
                var days, months;
                units = normalizeUnits(units);
                days = this._days + this._milliseconds / 864e5;
                if (units === "month" || units === "year") {
                    months = this._months + daysToYears(days) * 12;
                    return units === "month" ? months : months / 12
                } else {
                    days += yearsToDays(this._months / 12);
                    switch (units) {
                        case"week":
                            return days / 7;
                        case"day":
                            return days;
                        case"hour":
                            return days * 24;
                        case"minute":
                            return days * 24 * 60;
                        case"second":
                            return days * 24 * 60 * 60;
                        case"millisecond":
                            return days * 24 * 60 * 60 * 1e3;
                        default:
                            throw new Error("Unknown unit " + units)
                    }
                }
            }, lang: moment.fn.lang, locale: moment.fn.locale, toIsoString: deprecate("toIsoString() is deprecated. Please use toISOString() instead " + "(notice the capitals)", function () {
                return this.toISOString()
            }), toISOString: function () {
                var years = Math.abs(this.years()), months = Math.abs(this.months()), days = Math.abs(this.days()), hours = Math.abs(this.hours()), minutes = Math.abs(this.minutes()), seconds = Math.abs(this.seconds() + this.milliseconds() / 1e3);
                if (!this.asSeconds()) {
                    return"P0D"
                }
                return(this.asSeconds() < 0 ? "-" : "") + "P" + (years ? years + "Y" : "") + (months ? months + "M" : "") + (days ? days + "D" : "") + (hours || minutes || seconds ? "T" : "") + (hours ? hours + "H" : "") + (minutes ? minutes + "M" : "") + (seconds ? seconds + "S" : "")
            }, localeData: function () {
                return this._locale
            }});
            function makeDurationGetter(name) {
                moment.duration.fn[name] = function () {
                    return this._data[name]
                }
            }

            for (i in unitMillisecondFactors) {
                if (unitMillisecondFactors.hasOwnProperty(i)) {
                    makeDurationGetter(i.toLowerCase())
                }
            }
            moment.duration.fn.asMilliseconds = function () {
                return this.as("ms")
            };
            moment.duration.fn.asSeconds = function () {
                return this.as("s")
            };
            moment.duration.fn.asMinutes = function () {
                return this.as("m")
            };
            moment.duration.fn.asHours = function () {
                return this.as("h")
            };
            moment.duration.fn.asDays = function () {
                return this.as("d")
            };
            moment.duration.fn.asWeeks = function () {
                return this.as("weeks")
            };
            moment.duration.fn.asMonths = function () {
                return this.as("M")
            };
            moment.duration.fn.asYears = function () {
                return this.as("y")
            };
            moment.locale("en", {ordinal: function (number) {
                var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
                return number + output
            }});
            function makeGlobal(shouldDeprecate) {
                if (typeof ender !== "undefined") {
                    return
                }
                oldGlobalMoment = globalScope.moment;
                if (shouldDeprecate) {
                    globalScope.moment = deprecate("Accessing Moment through the global scope is " + "deprecated, and will be removed in an upcoming " + "release.", moment)
                } else {
                    globalScope.moment = moment
                }
            }

            if (hasModule) {
                module.exports = moment
            } else if (typeof define === "function" && define.amd) {
                define("moment", function (require, exports, module) {
                    if (module.config && module.config() && module.config().noGlobal === true) {
                        globalScope.moment = oldGlobalMoment
                    }
                    return moment
                });
                makeGlobal(true)
            } else {
                makeGlobal()
            }
        }).call(this)
    }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
}, {}], 55: [function (require, module, exports) {
    var pathtoRegexp = require("path-to-regexp");
    module.exports = page;
    var location = window.history.location || window.location;
    var dispatch = true;
    var base = "";
    var running;
    var hashbang = false;

    function page(path, fn) {
        if ("function" === typeof path) {
            return page("*", path)
        }
        if ("function" === typeof fn) {
            var route = new Route(path);
            for (var i = 1; i < arguments.length; ++i) {
                page.callbacks.push(route.middleware(arguments[i]))
            }
        } else if ("string" == typeof path) {
            "string" === typeof fn ? page.redirect(path, fn) : page.show(path, fn)
        } else {
            page.start(path)
        }
    }

    page.callbacks = [];
    page.base = function (path) {
        if (0 === arguments.length)return base;
        base = path
    };
    page.start = function (options) {
        options = options || {};
        if (running)return;
        running = true;
        if (false === options.dispatch)dispatch = false;
        if (false !== options.popstate)window.addEventListener("popstate", onpopstate, false);
        if (false !== options.click)window.addEventListener("click", onclick, false);
        if (true === options.hashbang)hashbang = true;
        if (!dispatch)return;
        var url = hashbang && ~location.hash.indexOf("#!") ? location.hash.substr(2) + location.search : location.pathname + location.search + location.hash;
        page.replace(url, null, true, dispatch)
    };
    page.stop = function () {
        if (!running)return;
        running = false;
        window.removeEventListener("click", onclick, false);
        window.removeEventListener("popstate", onpopstate, false)
    };
    page.show = function (path, state, dispatch) {
        var ctx = new Context(path, state);
        if (false !== dispatch)page.dispatch(ctx);
        if (false !== ctx.handled)ctx.pushState();
        return ctx
    };
    page.redirect = function (from, to) {
        page(from, function (e) {
            setTimeout(function () {
                page.replace(to)
            })
        })
    };
    page.replace = function (path, state, init, dispatch) {
        var ctx = new Context(path, state);
        ctx.init = init;
        ctx.save();
        if (false !== dispatch)page.dispatch(ctx);
        return ctx
    };
    page.dispatch = function (ctx) {
        var i = 0;

        function next() {
            var fn = page.callbacks[i++];
            if (!fn)return unhandled(ctx);
            fn(ctx, next)
        }

        next()
    };
    function unhandled(ctx) {
        if (ctx.handled)return;
        var current;
        if (hashbang) {
            current = base + location.hash.replace("#!", "")
        } else {
            current = location.pathname + location.search
        }
        if (current === ctx.canonicalPath)return;
        page.stop();
        ctx.handled = false;
        location.href = ctx.canonicalPath
    }

    function Context(path, state) {
        if ("/" === path[0] && 0 !== path.indexOf(base))path = base + path;
        var i = path.indexOf("?");
        this.canonicalPath = path;
        this.path = path.replace(base, "") || "/";
        this.title = document.title;
        this.state = state || {};
        this.state.path = path;
        this.querystring = ~i ? path.slice(i + 1) : "";
        this.pathname = ~i ? path.slice(0, i) : path;
        this.params = [];
        this.hash = "";
        if (!~this.path.indexOf("#"))return;
        var parts = this.path.split("#");
        this.path = parts[0];
        this.hash = parts[1] || "";
        this.querystring = this.querystring.split("#")[0]
    }

    page.Context = Context;
    Context.prototype.pushState = function () {
        history.pushState(this.state, this.title, hashbang && this.path !== "/" ? "#!" + this.path : this.canonicalPath)
    };
    Context.prototype.save = function () {
        history.replaceState(this.state, this.title, hashbang && this.path !== "/" ? "#!" + this.path : this.canonicalPath)
    };
    function Route(path, options) {
        options = options || {};
        this.path = path === "*" ? "(.*)" : path;
        this.method = "GET";
        this.regexp = pathtoRegexp(this.path, this.keys = [], options.sensitive, options.strict)
    }

    page.Route = Route;
    Route.prototype.middleware = function (fn) {
        var self = this;
        return function (ctx, next) {
            if (self.match(ctx.path, ctx.params))return fn(ctx, next);
            next()
        }
    };
    Route.prototype.match = function (path, params) {
        var keys = this.keys, qsIndex = path.indexOf("?"), pathname = ~qsIndex ? path.slice(0, qsIndex) : path, m = this.regexp.exec(decodeURIComponent(pathname));
        if (!m)return false;
        for (var i = 1, len = m.length; i < len; ++i) {
            var key = keys[i - 1];
            var val = "string" === typeof m[i] ? decodeURIComponent(m[i]) : m[i];
            if (key) {
                params[key.name] = undefined !== params[key.name] ? params[key.name] : val
            } else {
                params.push(val)
            }
        }
        return true
    };
    function onpopstate(e) {
        if (e.state) {
            var path = e.state.path;
            page.replace(path, e.state)
        }
    }

    function onclick(e) {
        if (1 != which(e))return;
        if (e.metaKey || e.ctrlKey || e.shiftKey)return;
        if (e.defaultPrevented)return;
        var el = e.target;
        while (el && "A" != el.nodeName)el = el.parentNode;
        if (!el || "A" != el.nodeName)return;
        var link = el.getAttribute("href");
        if (el.pathname === location.pathname && (el.hash || "#" === link))return;
        if (link && link.indexOf("mailto:") > -1)return;
        if (el.target)return;
        if (!sameOrigin(el.href))return;
        var path = el.pathname + el.search + (el.hash || "");
        var orig = path;
        path = path.replace(base, "");
        if (base && orig === path)return;
        e.preventDefault();
        page.show(orig)
    }

    function which(e) {
        e = e || window.event;
        return null === e.which ? e.button : e.which
    }

    function sameOrigin(href) {
        var origin = location.protocol + "//" + location.hostname;
        if (location.port)origin += ":" + location.port;
        return href && 0 === href.indexOf(origin)
    }

    page.sameOrigin = sameOrigin
}, {"path-to-regexp": 56}], 56: [function (require, module, exports) {
    module.exports = pathtoRegexp;
    var PATH_REGEXP = new RegExp(["(\\\\.)", "([\\/.])?(?:\\:(\\w+)(?:\\(((?:\\\\.|[^)])*)\\))?|\\(((?:\\\\.|[^)])*)\\))([+*?])?", "([.+*?=^!:${}()[\\]|\\/])"].join("|"), "g");

    function escapeGroup(group) {
        return group.replace(/([=!:$\/()])/g, "\\$1")
    }

    var attachKeys = function (re, keys) {
        re.keys = keys;
        return re
    };

    function pathtoRegexp(path, keys, options) {
        if (keys && !Array.isArray(keys)) {
            options = keys;
            keys = null
        }
        keys = keys || [];
        options = options || {};
        var strict = options.strict;
        var end = options.end !== false;
        var flags = options.sensitive ? "" : "i";
        var index = 0;
        if (path instanceof RegExp) {
            var groups = path.source.match(/\((?!\?)/g) || [];
            keys.push.apply(keys, groups.map(function (match, index) {
                return{name: index, delimiter: null, optional: false, repeat: false}
            }));
            return attachKeys(path, keys)
        }
        if (Array.isArray(path)) {
            path = path.map(function (value) {
                return pathtoRegexp(value, keys, options).source
            });
            return attachKeys(new RegExp("(?:" + path.join("|") + ")", flags), keys)
        }
        path = path.replace(PATH_REGEXP, function (match, escaped, prefix, key, capture, group, suffix, escape) {
            if (escaped) {
                return escaped
            }
            if (escape) {
                return"\\" + escape
            }
            var repeat = suffix === "+" || suffix === "*";
            var optional = suffix === "?" || suffix === "*";
            keys.push({name: key || index++, delimiter: prefix || "/", optional: optional, repeat: repeat});
            prefix = prefix ? "\\" + prefix : "";
            capture = escapeGroup(capture || group || "[^" + (prefix || "\\/") + "]+?");
            if (repeat) {
                capture = capture + "(?:" + prefix + capture + ")*"
            }
            if (optional) {
                return"(?:" + prefix + "(" + capture + "))?"
            }
            return prefix + "(" + capture + ")"
        });
        var endsWithSlash = path[path.length - 1] === "/";
        if (!strict) {
            path = (endsWithSlash ? path.slice(0, -2) : path) + "(?:\\/(?=$))?"
        }
        if (!end) {
            path += strict && endsWithSlash ? "" : "(?=\\/|$)"
        }
        return attachKeys(new RegExp("^" + path + (end ? "$" : ""), flags), keys)
    }
}, {}], 57: [function (require, module, exports) {
    var raf = require("raf");
    module.exports = throttle;
    function throttle(fn) {
        var rtn;
        var ignoring = false;
        return function queue() {
            if (ignoring)return rtn;
            ignoring = true;
            raf(function () {
                ignoring = false
            });
            rtn = fn.apply(this, arguments);
            return rtn
        }
    }
}, {raf: 58}], 58: [function (require, module, exports) {
    exports = module.exports = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || fallback;
    var prev = (new Date).getTime();

    function fallback(fn) {
        var curr = (new Date).getTime();
        var ms = Math.max(0, 16 - (curr - prev));
        var req = setTimeout(fn, ms);
        prev = curr;
        return req
    }

    var cancel = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame || window.clearTimeout;
    exports.cancel = function (id) {
        cancel.call(window, id)
    }
}, {}], 59: [function (require, module, exports) {
    module.exports = require("./lib")
}, {"./lib": 60}], 60: [function (require, module, exports) {
    var Stringify = require("./stringify");
    var Parse = require("./parse");
    var internals = {};
    module.exports = {stringify: Stringify, parse: Parse}
}, {"./parse": 61, "./stringify": 62}], 61: [function (require, module, exports) {
    var Utils = require("./utils");
    var internals = {delimiter: "&", depth: 5, arrayLimit: 20, parameterLimit: 1e3};
    internals.parseValues = function (str, options) {
        var obj = {};
        var parts = str.split(options.delimiter, options.parameterLimit === Infinity ? undefined : options.parameterLimit);
        for (var i = 0, il = parts.length; i < il; ++i) {
            var part = parts[i];
            var pos = part.indexOf("]=") === -1 ? part.indexOf("=") : part.indexOf("]=") + 1;
            if (pos === -1) {
                obj[Utils.decode(part)] = ""
            } else {
                var key = Utils.decode(part.slice(0, pos));
                var val = Utils.decode(part.slice(pos + 1));
                if (!obj[key]) {
                    obj[key] = val
                } else {
                    obj[key] = [].concat(obj[key]).concat(val)
                }
            }
        }
        return obj
    };
    internals.parseObject = function (chain, val, options) {
        if (!chain.length) {
            return val
        }
        var root = chain.shift();
        var obj = {};
        if (root === "[]") {
            obj = [];
            obj = obj.concat(internals.parseObject(chain, val, options))
        } else {
            var cleanRoot = root[0] === "[" && root[root.length - 1] === "]" ? root.slice(1, root.length - 1) : root;
            var index = parseInt(cleanRoot, 10);
            if (!isNaN(index) && root !== cleanRoot && index <= options.arrayLimit) {
                obj = [];
                obj[index] = internals.parseObject(chain, val, options)
            } else {
                obj[cleanRoot] = internals.parseObject(chain, val, options)
            }
        }
        return obj
    };
    internals.parseKeys = function (key, val, options) {
        if (!key) {
            return
        }
        var parent = /^([^\[\]]*)/;
        var child = /(\[[^\[\]]*\])/g;
        var segment = parent.exec(key);
        if (Object.prototype.hasOwnProperty(segment[1])) {
            return
        }
        var keys = [];
        if (segment[1]) {
            keys.push(segment[1])
        }
        var i = 0;
        while ((segment = child.exec(key)) !== null && i < options.depth) {
            ++i;
            if (!Object.prototype.hasOwnProperty(segment[1].replace(/\[|\]/g, ""))) {
                keys.push(segment[1])
            }
        }
        if (segment) {
            keys.push("[" + key.slice(segment.index) + "]")
        }
        return internals.parseObject(keys, val, options)
    };
    module.exports = function (str, options) {
        if (str === "" || str === null || typeof str === "undefined") {
            return{}
        }
        options = options || {};
        options.delimiter = typeof options.delimiter === "string" || Utils.isRegExp(options.delimiter) ? options.delimiter : internals.delimiter;
        options.depth = typeof options.depth === "number" ? options.depth : internals.depth;
        options.arrayLimit = typeof options.arrayLimit === "number" ? options.arrayLimit : internals.arrayLimit;
        options.parameterLimit = typeof options.parameterLimit === "number" ? options.parameterLimit : internals.parameterLimit;
        var tempObj = typeof str === "string" ? internals.parseValues(str, options) : Utils.clone(str);
        var obj = {};
        for (var key in tempObj) {
            if (tempObj.hasOwnProperty(key)) {
                var newObj = internals.parseKeys(key, tempObj[key], options);
                obj = Utils.merge(obj, newObj)
            }
        }
        return Utils.compact(obj)
    }
}, {"./utils": 63}], 62: [function (require, module, exports) {
    var Utils = require("./utils");
    var internals = {delimiter: "&"};
    internals.stringify = function (obj, prefix) {
        if (Utils.isBuffer(obj)) {
            obj = obj.toString()
        } else if (obj instanceof Date) {
            obj = obj.toISOString()
        } else if (obj === null) {
            obj = ""
        }
        if (typeof obj === "string" || typeof obj === "number" || typeof obj === "boolean") {
            return[encodeURIComponent(prefix) + "=" + encodeURIComponent(obj)]
        }
        var values = [];
        for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
                values = values.concat(internals.stringify(obj[key], prefix + "[" + key + "]"))
            }
        }
        return values
    };
    module.exports = function (obj, options) {
        options = options || {};
        var delimiter = typeof options.delimiter === "undefined" ? internals.delimiter : options.delimiter;
        var keys = [];
        for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
                keys = keys.concat(internals.stringify(obj[key], key))
            }
        }
        return keys.join(delimiter)
    }
}, {"./utils": 63}], 63: [function (require, module, exports) {
    (function (Buffer) {
        var internals = {};
        exports.arrayToObject = function (source) {
            var obj = {};
            for (var i = 0, il = source.length; i < il; ++i) {
                if (typeof source[i] !== "undefined") {
                    obj[i] = source[i]
                }
            }
            return obj
        };
        exports.clone = function (source) {
            if (typeof source !== "object" || source === null) {
                return source
            }
            if (exports.isBuffer(source)) {
                return source.toString()
            }
            var obj = Array.isArray(source) ? [] : {};
            for (var i in source) {
                if (source.hasOwnProperty(i)) {
                    obj[i] = exports.clone(source[i])
                }
            }
            return obj
        };
        exports.merge = function (target, source) {
            if (!source) {
                return target
            }
            if (Array.isArray(source)) {
                for (var i = 0, il = source.length; i < il; ++i) {
                    if (typeof source[i] !== "undefined") {
                        if (typeof target[i] === "object") {
                            target[i] = exports.merge(target[i], source[i])
                        } else {
                            target[i] = source[i]
                        }
                    }
                }
                return target
            }
            if (Array.isArray(target)) {
                if (typeof source !== "object") {
                    target.push(source);
                    return target
                } else {
                    target = exports.arrayToObject(target)
                }
            }
            var keys = Object.keys(source);
            for (var k = 0, kl = keys.length; k < kl; ++k) {
                var key = keys[k];
                var value = source[key];
                if (value && typeof value === "object") {
                    if (!target[key]) {
                        target[key] = exports.clone(value)
                    } else {
                        target[key] = exports.merge(target[key], value)
                    }
                } else {
                    target[key] = value
                }
            }
            return target
        };
        exports.decode = function (str) {
            try {
                return decodeURIComponent(str.replace(/\+/g, " "))
            } catch (e) {
                return str
            }
        };
        exports.compact = function (obj) {
            if (typeof obj !== "object" || obj === null) {
                return obj
            }
            var compacted = {};
            for (var key in obj) {
                if (obj.hasOwnProperty(key)) {
                    if (Array.isArray(obj[key])) {
                        compacted[key] = [];
                        for (var i = 0, l = obj[key].length; i < l; i++) {
                            if (typeof obj[key][i] !== "undefined") {
                                compacted[key].push(obj[key][i])
                            }
                        }
                    } else {
                        compacted[key] = exports.compact(obj[key])
                    }
                }
            }
            return compacted
        };
        exports.isRegExp = function (obj) {
            return Object.prototype.toString.call(obj) === "[object RegExp]"
        };
        exports.isBuffer = function (obj) {
            if (typeof Buffer !== "undefined") {
                return Buffer.isBuffer(obj)
            } else {
                return false
            }
        }
    }).call(this, require("buffer").Buffer)
}, {buffer: 40}], 64: [function (require, module, exports) {
    var ImageLoader, ImageLoaderImg, PropTypes, React, ReactLoaderMixin, Status, hasSize, img, merge, noscript, span, _ref, __slice = [].slice;
    React = require("react");
    merge = require("xtend");
    ReactLoaderMixin = require("react-loadermixin");
    PropTypes = React.PropTypes;
    _ref = React.DOM, span = _ref.span, img = _ref.img, noscript = _ref.noscript;
    Status = {PENDING: "pending", LOADING: "loading", LOADED: "loaded", FAILED: "failed"};
    hasSize = function (i) {
        return i.naturalWidth + i.naturalHeight === 0 || i.width + i.height === 0
    };
    ImageLoaderImg = React.createFactory(React.createClass({displayName: "ImageLoaderImage", getInitialState: function () {
        return{isInitialRender: true}
    }, componentDidMount: function () {
        return this.setState({isInitialRender: false})
    }, handleLoad: function () {
        var args, image, _base;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        if (!this.isMounted()) {
            return
        }
        image = this.refs.image;
        if ("naturalWidth"in image && !hasSize(image)) {
            return this.handleError(new Error("Image <" + image.src + "> could not be loaded."))
        } else {
            return typeof(_base = this.props).onLoad === "function" ? _base.onLoad.apply(_base, args) : void 0
        }
    }, handleError: function () {
        var args, _base;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return typeof(_base = this.props).onError === "function" ? _base.onError.apply(_base, args) : void 0
    }, renderImg: function () {
        return img(merge(this.props, {ref: "image", onLoad: this.handleLoad, onError: this.handleError}))
    }, render: function () {
        var html;
        if (this.state.isInitialRender) {
            html = React.renderToStaticMarkup(noscript(null, this.renderImg()));
            return span({style: {display: "none"}, dangerouslySetInnerHTML: {__html: html}})
        } else {
            return this.renderImg()
        }
    }}));
    module.exports = ImageLoader = React.createClass({displayName: "ImageLoader", mixins: [ReactLoaderMixin], propTypes: {wrapper: PropTypes.func, preloader: PropTypes.func}, getInitialState: function () {
        return{status: Status.PENDING}
    }, getDefaultProps: function () {
        return{wrapper: span, loader: ImageLoaderImg}
    }, componentWillReceiveProps: function (nextProps) {
        if (this.props.src !== nextProps.src) {
            return this.setState({status: nextProps.src ? Status.LOADING : Status.PENDING})
        }
    }, getClassName: function () {
        var className;
        className = "imageloader " + this.state.status;
        if (this.props.className) {
            className += " " + this.props.className
        }
        return className
    }, getImgProps: function () {
        var props;
        props = merge(this.props, {style: merge(this.props.style, {display: this.state.status === Status.LOADED ? null : "none"})});
        delete props.wrapper;
        delete props.preloader;
        return props
    }, loaderDidLoad: function () {
        return this.setState({status: Status.LOADED})
    }, loaderDidError: function () {
        return this.setState({status: Status.FAILED})
    }, renderChildren: function () {
        if (Array.isArray(this.props.children)) {
            return this.props.children.slice(0)
        } else {
            return[this.props.children]
        }
    }, render: function () {
        var wrapperArgs, _ref1;
        wrapperArgs = [
            {className: this.getClassName()}
        ];
        if (this.props.src) {
            wrapperArgs.push(this.renderLoader(ImageLoaderImg, this.getImgProps()))
        }
        if (this.props.preloader && this.state.status !== Status.LOADED) {
            wrapperArgs.push(this.props.preloader())
        }
        if (this.state.status === Status.FAILED) {
            wrapperArgs = wrapperArgs.concat(this.renderChildren())
        }
        return(_ref1 = this.props).wrapper.apply(_ref1, wrapperArgs)
    }})
}, {react: 213, "react-loadermixin": 66, xtend: 65}], 65: [function (require, module, exports) {
    module.exports = extend;
    function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
                if (source.hasOwnProperty(key)) {
                    target[key] = source[key]
                }
            }
        }
        return target
    }
}, {}], 66: [function (require, module, exports) {
    var PropTypes, React, ReactLoaderMixin, merge, __slice = [].slice;
    React = require("react");
    merge = require("xtend");
    PropTypes = React.PropTypes;
    module.exports = ReactLoaderMixin = {propTypes: {src: PropTypes.string, onLoad: PropTypes.func, onError: PropTypes.func}, renderLoader: function (loader, props) {
        return loader(merge(props, {src: this.props.src, onLoad: function (_this) {
            return function () {
                var args, _base;
                args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                if (typeof _this.loaderDidLoad === "function") {
                    _this.loaderDidLoad.apply(_this, args)
                }
                return typeof(_base = _this.props).onLoad === "function" ? _base.onLoad.apply(_base, args) : void 0
            }
        }(this), onError: function (_this) {
            return function () {
                var args, _base;
                args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                if (typeof _this.loaderDidError === "function") {
                    _this.loaderDidError.apply(_this, args)
                }
                return typeof(_base = _this.props).onError === "function" ? _base.onError.apply(_base, args) : void 0
            }
        }(this)}))
    }}
}, {react: 213, xtend: 67}], 67: [function (require, module, exports) {
    module.exports = require(65)
}, {}], 68: [function (require, module, exports) {
    "use strict";
    var focusNode = require("./focusNode");
    var AutoFocusMixin = {componentDidMount: function () {
        if (this.props.autoFocus) {
            focusNode(this.getDOMNode())
        }
    }};
    module.exports = AutoFocusMixin
}, {"./focusNode": 178}], 69: [function (require, module, exports) {
    "use strict";
    var EventConstants = require("./EventConstants");
    var EventPropagators = require("./EventPropagators");
    var ExecutionEnvironment = require("./ExecutionEnvironment");
    var SyntheticInputEvent = require("./SyntheticInputEvent");
    var keyOf = require("./keyOf");
    var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && "TextEvent"in window && !("documentMode"in document || isPresto());

    function isPresto() {
        var opera = window.opera;
        return typeof opera === "object" && typeof opera.version === "function" && parseInt(opera.version(), 10) <= 12
    }

    var SPACEBAR_CODE = 32;
    var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
    var topLevelTypes = EventConstants.topLevelTypes;
    var eventTypes = {beforeInput: {phasedRegistrationNames: {bubbled: keyOf({onBeforeInput: null}), captured: keyOf({onBeforeInputCapture: null})}, dependencies: [topLevelTypes.topCompositionEnd, topLevelTypes.topKeyPress, topLevelTypes.topTextInput, topLevelTypes.topPaste]}};
    var fallbackChars = null;
    var hasSpaceKeypress = false;

    function isKeypressCommand(nativeEvent) {
        return(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && !(nativeEvent.ctrlKey && nativeEvent.altKey)
    }

    var BeforeInputEventPlugin = {eventTypes: eventTypes, extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
        var chars;
        if (canUseTextInputEvent) {
            switch (topLevelType) {
                case topLevelTypes.topKeyPress:
                    var which = nativeEvent.which;
                    if (which !== SPACEBAR_CODE) {
                        return
                    }
                    hasSpaceKeypress = true;
                    chars = SPACEBAR_CHAR;
                    break;
                case topLevelTypes.topTextInput:
                    chars = nativeEvent.data;
                    if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
                        return
                    }
                    break;
                default:
                    return
            }
        } else {
            switch (topLevelType) {
                case topLevelTypes.topPaste:
                    fallbackChars = null;
                    break;
                case topLevelTypes.topKeyPress:
                    if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
                        fallbackChars = String.fromCharCode(nativeEvent.which)
                    }
                    break;
                case topLevelTypes.topCompositionEnd:
                    fallbackChars = nativeEvent.data;
                    break
            }
            if (fallbackChars === null) {
                return
            }
            chars = fallbackChars
        }
        if (!chars) {
            return
        }
        var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, topLevelTargetID, nativeEvent);
        event.data = chars;
        fallbackChars = null;
        EventPropagators.accumulateTwoPhaseDispatches(event);
        return event
    }};
    module.exports = BeforeInputEventPlugin
}, {"./EventConstants": 82, "./EventPropagators": 87, "./ExecutionEnvironment": 88, "./SyntheticInputEvent": 156, "./keyOf": 200}], 70: [function (require, module, exports) {
    "use strict";
    var isUnitlessNumber = {columnCount: true, fillOpacity: true, flex: true, flexGrow: true, flexShrink: true, fontWeight: true, lineClamp: true, lineHeight: true, opacity: true, order: true, orphans: true, widows: true, zIndex: true, zoom: true};

    function prefixKey(prefix, key) {
        return prefix + key.charAt(0).toUpperCase() + key.substring(1)
    }

    var prefixes = ["Webkit", "ms", "Moz", "O"];
    Object.keys(isUnitlessNumber).forEach(function (prop) {
        prefixes.forEach(function (prefix) {
            isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop]
        })
    });
    var shorthandPropertyExpansions = {background: {backgroundImage: true, backgroundPosition: true, backgroundRepeat: true, backgroundColor: true}, border: {borderWidth: true, borderStyle: true, borderColor: true}, borderBottom: {borderBottomWidth: true, borderBottomStyle: true, borderBottomColor: true}, borderLeft: {borderLeftWidth: true, borderLeftStyle: true, borderLeftColor: true}, borderRight: {borderRightWidth: true, borderRightStyle: true, borderRightColor: true}, borderTop: {borderTopWidth: true, borderTopStyle: true, borderTopColor: true}, font: {fontStyle: true, fontVariant: true, fontWeight: true, fontSize: true, lineHeight: true, fontFamily: true}};
    var CSSProperty = {isUnitlessNumber: isUnitlessNumber, shorthandPropertyExpansions: shorthandPropertyExpansions};
    module.exports = CSSProperty
}, {}], 71: [function (require, module, exports) {
    "use strict";
    var CSSProperty = require("./CSSProperty");
    var ExecutionEnvironment = require("./ExecutionEnvironment");
    var camelizeStyleName = require("./camelizeStyleName");
    var dangerousStyleValue = require("./dangerousStyleValue");
    var hyphenateStyleName = require("./hyphenateStyleName");
    var memoizeStringOnly = require("./memoizeStringOnly");
    var warning = require("./warning");
    var processStyleName = memoizeStringOnly(function (styleName) {
        return hyphenateStyleName(styleName)
    });
    var styleFloatAccessor = "cssFloat";
    if (ExecutionEnvironment.canUseDOM) {
        if (document.documentElement.style.cssFloat === undefined) {
            styleFloatAccessor = "styleFloat"
        }
    }
    if ("production" !== "production") {
        var warnedStyleNames = {};
        var warnHyphenatedStyleName = function (name) {
            if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
                return
            }
            warnedStyleNames[name] = true;
            "production" !== "production" ? warning(false, "Unsupported style property " + name + ". Did you mean " + camelizeStyleName(name) + "?") : null
        }
    }
    var CSSPropertyOperations = {createMarkupForStyles: function (styles) {
        var serialized = "";
        for (var styleName in styles) {
            if (!styles.hasOwnProperty(styleName)) {
                continue
            }
            if ("production" !== "production") {
                if (styleName.indexOf("-") > -1) {
                    warnHyphenatedStyleName(styleName)
                }
            }
            var styleValue = styles[styleName];
            if (styleValue != null) {
                serialized += processStyleName(styleName) + ":";
                serialized += dangerousStyleValue(styleName, styleValue) + ";"
            }
        }
        return serialized || null
    }, setValueForStyles: function (node, styles) {
        var style = node.style;
        for (var styleName in styles) {
            if (!styles.hasOwnProperty(styleName)) {
                continue
            }
            if ("production" !== "production") {
                if (styleName.indexOf("-") > -1) {
                    warnHyphenatedStyleName(styleName)
                }
            }
            var styleValue = dangerousStyleValue(styleName, styles[styleName]);
            if (styleName === "float") {
                styleName = styleFloatAccessor
            }
            if (styleValue) {
                style[styleName] = styleValue
            } else {
                var expansion = CSSProperty.shorthandPropertyExpansions[styleName];
                if (expansion) {
                    for (var individualStyleName in expansion) {
                        style[individualStyleName] = ""
                    }
                } else {
                    style[styleName] = ""
                }
            }
        }
    }};
    module.exports = CSSPropertyOperations
}, {"./CSSProperty": 70, "./ExecutionEnvironment": 88, "./camelizeStyleName": 167, "./dangerousStyleValue": 172, "./hyphenateStyleName": 191, "./memoizeStringOnly": 202, "./warning": 212}], 72: [function (require, module, exports) {
    "use strict";
    var PooledClass = require("./PooledClass");
    var assign = require("./Object.assign");
    var invariant = require("./invariant");

    function CallbackQueue() {
        this._callbacks = null;
        this._contexts = null
    }

    assign(CallbackQueue.prototype, {enqueue: function (callback, context) {
        this._callbacks = this._callbacks || [];
        this._contexts = this._contexts || [];
        this._callbacks.push(callback);
        this._contexts.push(context)
    }, notifyAll: function () {
        var callbacks = this._callbacks;
        var contexts = this._contexts;
        if (callbacks) {
            "production" !== "production" ? invariant(callbacks.length === contexts.length, "Mismatched list of contexts in callback queue") : invariant(callbacks.length === contexts.length);
            this._callbacks = null;
            this._contexts = null;
            for (var i = 0, l = callbacks.length; i < l; i++) {
                callbacks[i].call(contexts[i])
            }
            callbacks.length = 0;
            contexts.length = 0
        }
    }, reset: function () {
        this._callbacks = null;
        this._contexts = null
    }, destructor: function () {
        this.reset()
    }});
    PooledClass.addPoolingTo(CallbackQueue);
    module.exports = CallbackQueue
}, {"./Object.assign": 93, "./PooledClass": 94, "./invariant": 193}], 73: [function (require, module, exports) {
    "use strict";
    var EventConstants = require("./EventConstants");
    var EventPluginHub = require("./EventPluginHub");
    var EventPropagators = require("./EventPropagators");
    var ExecutionEnvironment = require("./ExecutionEnvironment");
    var ReactUpdates = require("./ReactUpdates");
    var SyntheticEvent = require("./SyntheticEvent");
    var isEventSupported = require("./isEventSupported");
    var isTextInputElement = require("./isTextInputElement");
    var keyOf = require("./keyOf");
    var topLevelTypes = EventConstants.topLevelTypes;
    var eventTypes = {change: {phasedRegistrationNames: {bubbled: keyOf({onChange: null}), captured: keyOf({onChangeCapture: null})}, dependencies: [topLevelTypes.topBlur, topLevelTypes.topChange, topLevelTypes.topClick, topLevelTypes.topFocus, topLevelTypes.topInput, topLevelTypes.topKeyDown, topLevelTypes.topKeyUp, topLevelTypes.topSelectionChange]}};
    var activeElement = null;
    var activeElementID = null;
    var activeElementValue = null;
    var activeElementValueProp = null;

    function shouldUseChangeEvent(elem) {
        return elem.nodeName === "SELECT" || elem.nodeName === "INPUT" && elem.type === "file"
    }

    var doesChangeEventBubble = false;
    if (ExecutionEnvironment.canUseDOM) {
        doesChangeEventBubble = isEventSupported("change") && (!("documentMode"in document) || document.documentMode > 8)
    }
    function manualDispatchChangeEvent(nativeEvent) {
        var event = SyntheticEvent.getPooled(eventTypes.change, activeElementID, nativeEvent);
        EventPropagators.accumulateTwoPhaseDispatches(event);
        ReactUpdates.batchedUpdates(runEventInBatch, event)
    }

    function runEventInBatch(event) {
        EventPluginHub.enqueueEvents(event);
        EventPluginHub.processEventQueue()
    }

    function startWatchingForChangeEventIE8(target, targetID) {
        activeElement = target;
        activeElementID = targetID;
        activeElement.attachEvent("onchange", manualDispatchChangeEvent)
    }

    function stopWatchingForChangeEventIE8() {
        if (!activeElement) {
            return
        }
        activeElement.detachEvent("onchange", manualDispatchChangeEvent);
        activeElement = null;
        activeElementID = null
    }

    function getTargetIDForChangeEvent(topLevelType, topLevelTarget, topLevelTargetID) {
        if (topLevelType === topLevelTypes.topChange) {
            return topLevelTargetID
        }
    }

    function handleEventsForChangeEventIE8(topLevelType, topLevelTarget, topLevelTargetID) {
        if (topLevelType === topLevelTypes.topFocus) {
            stopWatchingForChangeEventIE8();
            startWatchingForChangeEventIE8(topLevelTarget, topLevelTargetID)
        } else if (topLevelType === topLevelTypes.topBlur) {
            stopWatchingForChangeEventIE8()
        }
    }

    var isInputEventSupported = false;
    if (ExecutionEnvironment.canUseDOM) {
        isInputEventSupported = isEventSupported("input") && (!("documentMode"in document) || document.documentMode > 9)
    }
    var newValueProp = {get: function () {
        return activeElementValueProp.get.call(this)
    }, set: function (val) {
        activeElementValue = "" + val;
        activeElementValueProp.set.call(this, val)
    }};

    function startWatchingForValueChange(target, targetID) {
        activeElement = target;
        activeElementID = targetID;
        activeElementValue = target.value;
        activeElementValueProp = Object.getOwnPropertyDescriptor(target.constructor.prototype, "value");
        Object.defineProperty(activeElement, "value", newValueProp);
        activeElement.attachEvent("onpropertychange", handlePropertyChange)
    }

    function stopWatchingForValueChange() {
        if (!activeElement) {
            return
        }
        delete activeElement.value;
        activeElement.detachEvent("onpropertychange", handlePropertyChange);
        activeElement = null;
        activeElementID = null;
        activeElementValue = null;
        activeElementValueProp = null
    }

    function handlePropertyChange(nativeEvent) {
        if (nativeEvent.propertyName !== "value") {
            return
        }
        var value = nativeEvent.srcElement.value;
        if (value === activeElementValue) {
            return
        }
        activeElementValue = value;
        manualDispatchChangeEvent(nativeEvent)
    }

    function getTargetIDForInputEvent(topLevelType, topLevelTarget, topLevelTargetID) {
        if (topLevelType === topLevelTypes.topInput) {
            return topLevelTargetID
        }
    }

    function handleEventsForInputEventIE(topLevelType, topLevelTarget, topLevelTargetID) {
        if (topLevelType === topLevelTypes.topFocus) {
            stopWatchingForValueChange();
            startWatchingForValueChange(topLevelTarget, topLevelTargetID)
        } else if (topLevelType === topLevelTypes.topBlur) {
            stopWatchingForValueChange()
        }
    }

    function getTargetIDForInputEventIE(topLevelType, topLevelTarget, topLevelTargetID) {
        if (topLevelType === topLevelTypes.topSelectionChange || topLevelType === topLevelTypes.topKeyUp || topLevelType === topLevelTypes.topKeyDown) {
            if (activeElement && activeElement.value !== activeElementValue) {
                activeElementValue = activeElement.value;
                return activeElementID
            }
        }
    }

    function shouldUseClickEvent(elem) {
        return elem.nodeName === "INPUT" && (elem.type === "checkbox" || elem.type === "radio")
    }

    function getTargetIDForClickEvent(topLevelType, topLevelTarget, topLevelTargetID) {
        if (topLevelType === topLevelTypes.topClick) {
            return topLevelTargetID
        }
    }

    var ChangeEventPlugin = {eventTypes: eventTypes, extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
        var getTargetIDFunc, handleEventFunc;
        if (shouldUseChangeEvent(topLevelTarget)) {
            if (doesChangeEventBubble) {
                getTargetIDFunc = getTargetIDForChangeEvent
            } else {
                handleEventFunc = handleEventsForChangeEventIE8
            }
        } else if (isTextInputElement(topLevelTarget)) {
            if (isInputEventSupported) {
                getTargetIDFunc = getTargetIDForInputEvent
            } else {
                getTargetIDFunc = getTargetIDForInputEventIE;
                handleEventFunc = handleEventsForInputEventIE
            }
        } else if (shouldUseClickEvent(topLevelTarget)) {
            getTargetIDFunc = getTargetIDForClickEvent
        }
        if (getTargetIDFunc) {
            var targetID = getTargetIDFunc(topLevelType, topLevelTarget, topLevelTargetID);
            if (targetID) {
                var event = SyntheticEvent.getPooled(eventTypes.change, targetID, nativeEvent);
                EventPropagators.accumulateTwoPhaseDispatches(event);
                return event
            }
        }
        if (handleEventFunc) {
            handleEventFunc(topLevelType, topLevelTarget, topLevelTargetID)
        }
    }};
    module.exports = ChangeEventPlugin
}, {"./EventConstants": 82, "./EventPluginHub": 84, "./EventPropagators": 87, "./ExecutionEnvironment": 88, "./ReactUpdates": 146, "./SyntheticEvent": 154, "./isEventSupported": 194, "./isTextInputElement": 196, "./keyOf": 200}], 74: [function (require, module, exports) {
    "use strict";
    var nextReactRootIndex = 0;
    var ClientReactRootIndex = {createReactRootIndex: function () {
        return nextReactRootIndex++
    }};
    module.exports = ClientReactRootIndex
}, {}], 75: [function (require, module, exports) {
    "use strict";
    var EventConstants = require("./EventConstants");
    var EventPropagators = require("./EventPropagators");
    var ExecutionEnvironment = require("./ExecutionEnvironment");
    var ReactInputSelection = require("./ReactInputSelection");
    var SyntheticCompositionEvent = require("./SyntheticCompositionEvent");
    var getTextContentAccessor = require("./getTextContentAccessor");
    var keyOf = require("./keyOf");
    var END_KEYCODES = [9, 13, 27, 32];
    var START_KEYCODE = 229;
    var useCompositionEvent = ExecutionEnvironment.canUseDOM && "CompositionEvent"in window;
    var useFallbackData = !useCompositionEvent || "documentMode"in document && document.documentMode > 8 && document.documentMode <= 11;
    var topLevelTypes = EventConstants.topLevelTypes;
    var currentComposition = null;
    var eventTypes = {compositionEnd: {phasedRegistrationNames: {bubbled: keyOf({onCompositionEnd: null}), captured: keyOf({onCompositionEndCapture: null})}, dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionEnd, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]}, compositionStart: {phasedRegistrationNames: {bubbled: keyOf({onCompositionStart: null}), captured: keyOf({onCompositionStartCapture: null})}, dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionStart, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]}, compositionUpdate: {phasedRegistrationNames: {bubbled: keyOf({onCompositionUpdate: null}), captured: keyOf({onCompositionUpdateCapture: null})}, dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionUpdate, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]}};

    function getCompositionEventType(topLevelType) {
        switch (topLevelType) {
            case topLevelTypes.topCompositionStart:
                return eventTypes.compositionStart;
            case topLevelTypes.topCompositionEnd:
                return eventTypes.compositionEnd;
            case topLevelTypes.topCompositionUpdate:
                return eventTypes.compositionUpdate
        }
    }

    function isFallbackStart(topLevelType, nativeEvent) {
        return topLevelType === topLevelTypes.topKeyDown && nativeEvent.keyCode === START_KEYCODE
    }

    function isFallbackEnd(topLevelType, nativeEvent) {
        switch (topLevelType) {
            case topLevelTypes.topKeyUp:
                return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
            case topLevelTypes.topKeyDown:
                return nativeEvent.keyCode !== START_KEYCODE;
            case topLevelTypes.topKeyPress:
            case topLevelTypes.topMouseDown:
            case topLevelTypes.topBlur:
                return true;
            default:
                return false
        }
    }

    function FallbackCompositionState(root) {
        this.root = root;
        this.startSelection = ReactInputSelection.getSelection(root);
        this.startValue = this.getText()
    }

    FallbackCompositionState.prototype.getText = function () {
        return this.root.value || this.root[getTextContentAccessor()]
    };
    FallbackCompositionState.prototype.getData = function () {
        var endValue = this.getText();
        var prefixLength = this.startSelection.start;
        var suffixLength = this.startValue.length - this.startSelection.end;
        return endValue.substr(prefixLength, endValue.length - suffixLength - prefixLength)
    };
    var CompositionEventPlugin = {eventTypes: eventTypes, extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
        var eventType;
        var data;
        if (useCompositionEvent) {
            eventType = getCompositionEventType(topLevelType)
        } else if (!currentComposition) {
            if (isFallbackStart(topLevelType, nativeEvent)) {
                eventType = eventTypes.compositionStart
            }
        } else if (isFallbackEnd(topLevelType, nativeEvent)) {
            eventType = eventTypes.compositionEnd
        }
        if (useFallbackData) {
            if (!currentComposition && eventType === eventTypes.compositionStart) {
                currentComposition = new FallbackCompositionState(topLevelTarget)
            } else if (eventType === eventTypes.compositionEnd) {
                if (currentComposition) {
                    data = currentComposition.getData();
                    currentComposition = null
                }
            }
        }
        if (eventType) {
            var event = SyntheticCompositionEvent.getPooled(eventType, topLevelTargetID, nativeEvent);
            if (data) {
                event.data = data
            }
            EventPropagators.accumulateTwoPhaseDispatches(event);
            return event
        }
    }};
    module.exports = CompositionEventPlugin
}, {"./EventConstants": 82, "./EventPropagators": 87, "./ExecutionEnvironment": 88, "./ReactInputSelection": 126, "./SyntheticCompositionEvent": 152, "./getTextContentAccessor": 188, "./keyOf": 200}], 76: [function (require, module, exports) {
    "use strict";
    var Danger = require("./Danger");
    var ReactMultiChildUpdateTypes = require("./ReactMultiChildUpdateTypes");
    var getTextContentAccessor = require("./getTextContentAccessor");
    var invariant = require("./invariant");
    var textContentAccessor = getTextContentAccessor();

    function insertChildAt(parentNode, childNode, index) {
        parentNode.insertBefore(childNode, parentNode.childNodes[index] || null)
    }

    var updateTextContent;
    if (textContentAccessor === "textContent") {
        updateTextContent = function (node, text) {
            node.textContent = text
        }
    } else {
        updateTextContent = function (node, text) {
            while (node.firstChild) {
                node.removeChild(node.firstChild)
            }
            if (text) {
                var doc = node.ownerDocument || document;
                node.appendChild(doc.createTextNode(text))
            }
        }
    }
    var DOMChildrenOperations = {dangerouslyReplaceNodeWithMarkup: Danger.dangerouslyReplaceNodeWithMarkup, updateTextContent: updateTextContent, processUpdates: function (updates, markupList) {
        var update;
        var initialChildren = null;
        var updatedChildren = null;
        for (var i = 0; update = updates[i]; i++) {
            if (update.type === ReactMultiChildUpdateTypes.MOVE_EXISTING || update.type === ReactMultiChildUpdateTypes.REMOVE_NODE) {
                var updatedIndex = update.fromIndex;
                var updatedChild = update.parentNode.childNodes[updatedIndex];
                var parentID = update.parentID;
                "production" !== "production" ? invariant(updatedChild, "processUpdates(): Unable to find child %s of element. This " + "probably means the DOM was unexpectedly mutated (e.g., by the " + "browser), usually due to forgetting a <tbody> when using tables, " + "nesting tags like <form>, <p>, or <a>, or using non-SVG elements " + "in an <svg> parent. Try inspecting the child nodes of the element " + "with React ID `%s`.", updatedIndex, parentID) : invariant(updatedChild);
                initialChildren = initialChildren || {};
                initialChildren[parentID] = initialChildren[parentID] || [];
                initialChildren[parentID][updatedIndex] = updatedChild;
                updatedChildren = updatedChildren || [];
                updatedChildren.push(updatedChild)
            }
        }
        var renderedMarkup = Danger.dangerouslyRenderMarkup(markupList);
        if (updatedChildren) {
            for (var j = 0; j < updatedChildren.length; j++) {
                updatedChildren[j].parentNode.removeChild(updatedChildren[j])
            }
        }
        for (var k = 0; update = updates[k]; k++) {
            switch (update.type) {
                case ReactMultiChildUpdateTypes.INSERT_MARKUP:
                    insertChildAt(update.parentNode, renderedMarkup[update.markupIndex], update.toIndex);
                    break;
                case ReactMultiChildUpdateTypes.MOVE_EXISTING:
                    insertChildAt(update.parentNode, initialChildren[update.parentID][update.fromIndex], update.toIndex);
                    break;
                case ReactMultiChildUpdateTypes.TEXT_CONTENT:
                    updateTextContent(update.parentNode, update.textContent);
                    break;
                case ReactMultiChildUpdateTypes.REMOVE_NODE:
                    break
            }
        }
    }};
    module.exports = DOMChildrenOperations
}, {"./Danger": 79, "./ReactMultiChildUpdateTypes": 132, "./getTextContentAccessor": 188, "./invariant": 193}], 77: [function (require, module, exports) {
    "use strict";
    var invariant = require("./invariant");

    function checkMask(value, bitmask) {
        return(value & bitmask) === bitmask
    }

    var DOMPropertyInjection = {MUST_USE_ATTRIBUTE: 1, MUST_USE_PROPERTY: 2, HAS_SIDE_EFFECTS: 4, HAS_BOOLEAN_VALUE: 8, HAS_NUMERIC_VALUE: 16, HAS_POSITIVE_NUMERIC_VALUE: 32 | 16, HAS_OVERLOADED_BOOLEAN_VALUE: 64, injectDOMPropertyConfig: function (domPropertyConfig) {
        var Properties = domPropertyConfig.Properties || {};
        var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
        var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
        var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};
        if (domPropertyConfig.isCustomAttribute) {
            DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute)
        }
        for (var propName in Properties) {
            "production" !== "production" ? invariant(!DOMProperty.isStandardName.hasOwnProperty(propName), "injectDOMPropertyConfig(...): You're trying to inject DOM property " + "'%s' which has already been injected. You may be accidentally " + "injecting the same DOM property config twice, or you may be " + "injecting two configs that have conflicting property names.", propName) : invariant(!DOMProperty.isStandardName.hasOwnProperty(propName));
            DOMProperty.isStandardName[propName] = true;
            var lowerCased = propName.toLowerCase();
            DOMProperty.getPossibleStandardName[lowerCased] = propName;
            if (DOMAttributeNames.hasOwnProperty(propName)) {
                var attributeName = DOMAttributeNames[propName];
                DOMProperty.getPossibleStandardName[attributeName] = propName;
                DOMProperty.getAttributeName[propName] = attributeName
            } else {
                DOMProperty.getAttributeName[propName] = lowerCased
            }
            DOMProperty.getPropertyName[propName] = DOMPropertyNames.hasOwnProperty(propName) ? DOMPropertyNames[propName] : propName;
            if (DOMMutationMethods.hasOwnProperty(propName)) {
                DOMProperty.getMutationMethod[propName] = DOMMutationMethods[propName]
            } else {
                DOMProperty.getMutationMethod[propName] = null
            }
            var propConfig = Properties[propName];
            DOMProperty.mustUseAttribute[propName] = checkMask(propConfig, DOMPropertyInjection.MUST_USE_ATTRIBUTE);
            DOMProperty.mustUseProperty[propName] = checkMask(propConfig, DOMPropertyInjection.MUST_USE_PROPERTY);
            DOMProperty.hasSideEffects[propName] = checkMask(propConfig, DOMPropertyInjection.HAS_SIDE_EFFECTS);
            DOMProperty.hasBooleanValue[propName] = checkMask(propConfig, DOMPropertyInjection.HAS_BOOLEAN_VALUE);
            DOMProperty.hasNumericValue[propName] = checkMask(propConfig, DOMPropertyInjection.HAS_NUMERIC_VALUE);
            DOMProperty.hasPositiveNumericValue[propName] = checkMask(propConfig, DOMPropertyInjection.HAS_POSITIVE_NUMERIC_VALUE);
            DOMProperty.hasOverloadedBooleanValue[propName] = checkMask(propConfig, DOMPropertyInjection.HAS_OVERLOADED_BOOLEAN_VALUE);
            "production" !== "production" ? invariant(!DOMProperty.mustUseAttribute[propName] || !DOMProperty.mustUseProperty[propName], "DOMProperty: Cannot require using both attribute and property: %s", propName) : invariant(!DOMProperty.mustUseAttribute[propName] || !DOMProperty.mustUseProperty[propName]);
            "production" !== "production" ? invariant(DOMProperty.mustUseProperty[propName] || !DOMProperty.hasSideEffects[propName], "DOMProperty: Properties that have side effects must use property: %s", propName) : invariant(DOMProperty.mustUseProperty[propName] || !DOMProperty.hasSideEffects[propName]);
            "production" !== "production" ? invariant(!!DOMProperty.hasBooleanValue[propName] + !!DOMProperty.hasNumericValue[propName] + !!DOMProperty.hasOverloadedBooleanValue[propName] <= 1, "DOMProperty: Value can be one of boolean, overloaded boolean, or " + "numeric value, but not a combination: %s", propName) : invariant(!!DOMProperty.hasBooleanValue[propName] + !!DOMProperty.hasNumericValue[propName] + !!DOMProperty.hasOverloadedBooleanValue[propName] <= 1)
        }
    }};
    var defaultValueCache = {};
    var DOMProperty = {ID_ATTRIBUTE_NAME: "data-reactid", isStandardName: {}, getPossibleStandardName: {}, getAttributeName: {}, getPropertyName: {}, getMutationMethod: {}, mustUseAttribute: {}, mustUseProperty: {}, hasSideEffects: {}, hasBooleanValue: {}, hasNumericValue: {}, hasPositiveNumericValue: {}, hasOverloadedBooleanValue: {}, _isCustomAttributeFunctions: [], isCustomAttribute: function (attributeName) {
        for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
            var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
            if (isCustomAttributeFn(attributeName)) {
                return true
            }
        }
        return false
    }, getDefaultValueForProperty: function (nodeName, prop) {
        var nodeDefaults = defaultValueCache[nodeName];
        var testElement;
        if (!nodeDefaults) {
            defaultValueCache[nodeName] = nodeDefaults = {}
        }
        if (!(prop in nodeDefaults)) {
            testElement = document.createElement(nodeName);
            nodeDefaults[prop] = testElement[prop]
        }
        return nodeDefaults[prop]
    }, injection: DOMPropertyInjection};
    module.exports = DOMProperty
}, {"./invariant": 193}], 78: [function (require, module, exports) {
    "use strict";
    var DOMProperty = require("./DOMProperty");
    var escapeTextForBrowser = require("./escapeTextForBrowser");
    var memoizeStringOnly = require("./memoizeStringOnly");
    var warning = require("./warning");

    function shouldIgnoreValue(name, value) {
        return value == null || DOMProperty.hasBooleanValue[name] && !value || DOMProperty.hasNumericValue[name] && isNaN(value) || DOMProperty.hasPositiveNumericValue[name] && value < 1 || DOMProperty.hasOverloadedBooleanValue[name] && value === false
    }

    var processAttributeNameAndPrefix = memoizeStringOnly(function (name) {
        return escapeTextForBrowser(name) + '="'
    });
    if ("production" !== "production") {
        var reactProps = {children: true, dangerouslySetInnerHTML: true, key: true, ref: true};
        var warnedProperties = {};
        var warnUnknownProperty = function (name) {
            if (reactProps.hasOwnProperty(name) && reactProps[name] || warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
                return
            }
            warnedProperties[name] = true;
            var lowerCasedName = name.toLowerCase();
            var standardName = DOMProperty.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;
            "production" !== "production" ? warning(standardName == null, "Unknown DOM property " + name + ". Did you mean " + standardName + "?") : null
        }
    }
    var DOMPropertyOperations = {createMarkupForID: function (id) {
        return processAttributeNameAndPrefix(DOMProperty.ID_ATTRIBUTE_NAME) + escapeTextForBrowser(id) + '"'
    }, createMarkupForProperty: function (name, value) {
        if (DOMProperty.isStandardName.hasOwnProperty(name) && DOMProperty.isStandardName[name]) {
            if (shouldIgnoreValue(name, value)) {
                return""
            }
            var attributeName = DOMProperty.getAttributeName[name];
            if (DOMProperty.hasBooleanValue[name] || DOMProperty.hasOverloadedBooleanValue[name] && value === true) {
                return escapeTextForBrowser(attributeName)
            }
            return processAttributeNameAndPrefix(attributeName) + escapeTextForBrowser(value) + '"'
        } else if (DOMProperty.isCustomAttribute(name)) {
            if (value == null) {
                return""
            }
            return processAttributeNameAndPrefix(name) + escapeTextForBrowser(value) + '"'
        } else if ("production" !== "production") {
            warnUnknownProperty(name)
        }
        return null
    }, setValueForProperty: function (node, name, value) {
        if (DOMProperty.isStandardName.hasOwnProperty(name) && DOMProperty.isStandardName[name]) {
            var mutationMethod = DOMProperty.getMutationMethod[name];
            if (mutationMethod) {
                mutationMethod(node, value)
            } else if (shouldIgnoreValue(name, value)) {
                this.deleteValueForProperty(node, name)
            } else if (DOMProperty.mustUseAttribute[name]) {
                node.setAttribute(DOMProperty.getAttributeName[name], "" + value)
            } else {
                var propName = DOMProperty.getPropertyName[name];
                if (!DOMProperty.hasSideEffects[name] || "" + node[propName] !== "" + value) {
                    node[propName] = value
                }
            }
        } else if (DOMProperty.isCustomAttribute(name)) {
            if (value == null) {
                node.removeAttribute(name)
            } else {
                node.setAttribute(name, "" + value)
            }
        } else if ("production" !== "production") {
            warnUnknownProperty(name)
        }
    }, deleteValueForProperty: function (node, name) {
        if (DOMProperty.isStandardName.hasOwnProperty(name) && DOMProperty.isStandardName[name]) {
            var mutationMethod = DOMProperty.getMutationMethod[name];
            if (mutationMethod) {
                mutationMethod(node, undefined)
            } else if (DOMProperty.mustUseAttribute[name]) {
                node.removeAttribute(DOMProperty.getAttributeName[name])
            } else {
                var propName = DOMProperty.getPropertyName[name];
                var defaultValue = DOMProperty.getDefaultValueForProperty(node.nodeName, propName);
                if (!DOMProperty.hasSideEffects[name] || "" + node[propName] !== defaultValue) {
                    node[propName] = defaultValue
                }
            }
        } else if (DOMProperty.isCustomAttribute(name)) {
            node.removeAttribute(name)
        } else if ("production" !== "production") {
            warnUnknownProperty(name)
        }
    }};
    module.exports = DOMPropertyOperations
}, {"./DOMProperty": 77, "./escapeTextForBrowser": 176, "./memoizeStringOnly": 202, "./warning": 212}], 79: [function (require, module, exports) {
    "use strict";
    var ExecutionEnvironment = require("./ExecutionEnvironment");
    var createNodesFromMarkup = require("./createNodesFromMarkup");
    var emptyFunction = require("./emptyFunction");
    var getMarkupWrap = require("./getMarkupWrap");
    var invariant = require("./invariant");
    var OPEN_TAG_NAME_EXP = /^(<[^ \/>]+)/;
    var RESULT_INDEX_ATTR = "data-danger-index";

    function getNodeName(markup) {
        return markup.substring(1, markup.indexOf(" "))
    }

    var Danger = {dangerouslyRenderMarkup: function (markupList) {
        "production" !== "production" ? invariant(ExecutionEnvironment.canUseDOM, "dangerouslyRenderMarkup(...): Cannot render markup in a worker " + "thread. Make sure `window` and `document` are available globally " + "before requiring React when unit testing or use " + "React.renderToString for server rendering.") : invariant(ExecutionEnvironment.canUseDOM);
        var nodeName;
        var markupByNodeName = {};
        for (var i = 0; i < markupList.length; i++) {
            "production" !== "production" ? invariant(markupList[i], "dangerouslyRenderMarkup(...): Missing markup.") : invariant(markupList[i]);
            nodeName = getNodeName(markupList[i]);
            nodeName = getMarkupWrap(nodeName) ? nodeName : "*";
            markupByNodeName[nodeName] = markupByNodeName[nodeName] || [];
            markupByNodeName[nodeName][i] = markupList[i]
        }
        var resultList = [];
        var resultListAssignmentCount = 0;
        for (nodeName in markupByNodeName) {
            if (!markupByNodeName.hasOwnProperty(nodeName)) {
                continue
            }
            var markupListByNodeName = markupByNodeName[nodeName];
            for (var resultIndex in markupListByNodeName) {
                if (markupListByNodeName.hasOwnProperty(resultIndex)) {
                    var markup = markupListByNodeName[resultIndex];
                    markupListByNodeName[resultIndex] = markup.replace(OPEN_TAG_NAME_EXP, "$1 " + RESULT_INDEX_ATTR + '="' + resultIndex + '" ')
                }
            }
            var renderNodes = createNodesFromMarkup(markupListByNodeName.join(""), emptyFunction);
            for (i = 0; i < renderNodes.length; ++i) {
                var renderNode = renderNodes[i];
                if (renderNode.hasAttribute && renderNode.hasAttribute(RESULT_INDEX_ATTR)) {
                    resultIndex = +renderNode.getAttribute(RESULT_INDEX_ATTR);
                    renderNode.removeAttribute(RESULT_INDEX_ATTR);
                    "production" !== "production" ? invariant(!resultList.hasOwnProperty(resultIndex), "Danger: Assigning to an already-occupied result index.") : invariant(!resultList.hasOwnProperty(resultIndex));
                    resultList[resultIndex] = renderNode;
                    resultListAssignmentCount += 1
                } else if ("production" !== "production") {
                    console.error("Danger: Discarding unexpected node:", renderNode)
                }
            }
        }
        "production" !== "production" ? invariant(resultListAssignmentCount === resultList.length, "Danger: Did not assign to every index of resultList.") : invariant(resultListAssignmentCount === resultList.length);
        "production" !== "production" ? invariant(resultList.length === markupList.length, "Danger: Expected markup to render %s nodes, but rendered %s.", markupList.length, resultList.length) : invariant(resultList.length === markupList.length);
        return resultList
    }, dangerouslyReplaceNodeWithMarkup: function (oldChild, markup) {
        "production" !== "production" ? invariant(ExecutionEnvironment.canUseDOM, "dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a " + "worker thread. Make sure `window` and `document` are available " + "globally before requiring React when unit testing or use " + "React.renderToString for server rendering.") : invariant(ExecutionEnvironment.canUseDOM);
        "production" !== "production" ? invariant(markup, "dangerouslyReplaceNodeWithMarkup(...): Missing markup.") : invariant(markup);
        "production" !== "production" ? invariant(oldChild.tagName.toLowerCase() !== "html", "dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the " + "<html> node. This is because browser quirks make this unreliable " + "and/or slow. If you want to render to the root you must use " + "server rendering. See renderComponentToString().") : invariant(oldChild.tagName.toLowerCase() !== "html");
        var newChild = createNodesFromMarkup(markup, emptyFunction)[0];
        oldChild.parentNode.replaceChild(newChild, oldChild)
    }};
    module.exports = Danger
}, {"./ExecutionEnvironment": 88, "./createNodesFromMarkup": 171, "./emptyFunction": 174, "./getMarkupWrap": 185, "./invariant": 193}], 80: [function (require, module, exports) {
    "use strict";
    var keyOf = require("./keyOf");
    var DefaultEventPluginOrder = [keyOf({ResponderEventPlugin: null}), keyOf({SimpleEventPlugin: null}), keyOf({TapEventPlugin: null}), keyOf({EnterLeaveEventPlugin: null}), keyOf({ChangeEventPlugin: null}), keyOf({SelectEventPlugin: null}), keyOf({CompositionEventPlugin: null}), keyOf({BeforeInputEventPlugin: null}), keyOf({AnalyticsEventPlugin: null}), keyOf({MobileSafariClickEventPlugin: null})];
    module.exports = DefaultEventPluginOrder
}, {"./keyOf": 200}], 81: [function (require, module, exports) {
    "use strict";
    var EventConstants = require("./EventConstants");
    var EventPropagators = require("./EventPropagators");
    var SyntheticMouseEvent = require("./SyntheticMouseEvent");
    var ReactMount = require("./ReactMount");
    var keyOf = require("./keyOf");
    var topLevelTypes = EventConstants.topLevelTypes;
    var getFirstReactDOM = ReactMount.getFirstReactDOM;
    var eventTypes = {mouseEnter: {registrationName: keyOf({onMouseEnter: null}), dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]}, mouseLeave: {registrationName: keyOf({onMouseLeave: null}), dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]}};
    var extractedEvents = [null, null];
    var EnterLeaveEventPlugin = {eventTypes: eventTypes, extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
        if (topLevelType === topLevelTypes.topMouseOver && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
            return null
        }
        if (topLevelType !== topLevelTypes.topMouseOut && topLevelType !== topLevelTypes.topMouseOver) {
            return null
        }
        var win;
        if (topLevelTarget.window === topLevelTarget) {
            win = topLevelTarget
        } else {
            var doc = topLevelTarget.ownerDocument;
            if (doc) {
                win = doc.defaultView || doc.parentWindow
            } else {
                win = window
            }
        }
        var from, to;
        if (topLevelType === topLevelTypes.topMouseOut) {
            from = topLevelTarget;
            to = getFirstReactDOM(nativeEvent.relatedTarget || nativeEvent.toElement) || win
        } else {
            from = win;
            to = topLevelTarget
        }
        if (from === to) {
            return null
        }
        var fromID = from ? ReactMount.getID(from) : "";
        var toID = to ? ReactMount.getID(to) : "";
        var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, fromID, nativeEvent);
        leave.type = "mouseleave";
        leave.target = from;
        leave.relatedTarget = to;
        var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, toID, nativeEvent);
        enter.type = "mouseenter";
        enter.target = to;
        enter.relatedTarget = from;
        EventPropagators.accumulateEnterLeaveDispatches(leave, enter, fromID, toID);
        extractedEvents[0] = leave;
        extractedEvents[1] = enter;
        return extractedEvents
    }};
    module.exports = EnterLeaveEventPlugin
}, {"./EventConstants": 82, "./EventPropagators": 87, "./ReactMount": 130, "./SyntheticMouseEvent": 158, "./keyOf": 200}], 82: [function (require, module, exports) {
    "use strict";
    var keyMirror = require("./keyMirror");
    var PropagationPhases = keyMirror({bubbled: null, captured: null});
    var topLevelTypes = keyMirror({topBlur: null, topChange: null, topClick: null, topCompositionEnd: null, topCompositionStart: null, topCompositionUpdate: null, topContextMenu: null, topCopy: null, topCut: null, topDoubleClick: null, topDrag: null, topDragEnd: null, topDragEnter: null, topDragExit: null, topDragLeave: null, topDragOver: null, topDragStart: null, topDrop: null, topError: null, topFocus: null, topInput: null, topKeyDown: null, topKeyPress: null, topKeyUp: null, topLoad: null, topMouseDown: null, topMouseMove: null, topMouseOut: null, topMouseOver: null, topMouseUp: null, topPaste: null, topReset: null, topScroll: null, topSelectionChange: null, topSubmit: null, topTextInput: null, topTouchCancel: null, topTouchEnd: null, topTouchMove: null, topTouchStart: null, topWheel: null});
    var EventConstants = {topLevelTypes: topLevelTypes, PropagationPhases: PropagationPhases};
    module.exports = EventConstants
}, {"./keyMirror": 199}], 83: [function (require, module, exports) {
    var emptyFunction = require("./emptyFunction");
    var EventListener = {listen: function (target, eventType, callback) {
        if (target.addEventListener) {
            target.addEventListener(eventType, callback, false);
            return{remove: function () {
                target.removeEventListener(eventType, callback, false)
            }}
        } else if (target.attachEvent) {
            target.attachEvent("on" + eventType, callback);
            return{remove: function () {
                target.detachEvent("on" + eventType, callback)
            }}
        }
    }, capture: function (target, eventType, callback) {
        if (!target.addEventListener) {
            if ("production" !== "production") {
                console.error("Attempted to listen to events during the capture phase on a " + "browser that does not support the capture phase. Your application " + "will not receive some events.")
            }
            return{remove: emptyFunction}
        } else {
            target.addEventListener(eventType, callback, true);
            return{remove: function () {
                target.removeEventListener(eventType, callback, true)
            }}
        }
    }, registerDefault: function () {
    }};
    module.exports = EventListener
}, {"./emptyFunction": 174}], 84: [function (require, module, exports) {
    "use strict";
    var EventPluginRegistry = require("./EventPluginRegistry");
    var EventPluginUtils = require("./EventPluginUtils");
    var accumulateInto = require("./accumulateInto");
    var forEachAccumulated = require("./forEachAccumulated");
    var invariant = require("./invariant");
    var listenerBank = {};
    var eventQueue = null;
    var executeDispatchesAndRelease = function (event) {
        if (event) {
            var executeDispatch = EventPluginUtils.executeDispatch;
            var PluginModule = EventPluginRegistry.getPluginModuleForEvent(event);
            if (PluginModule && PluginModule.executeDispatch) {
                executeDispatch = PluginModule.executeDispatch
            }
            EventPluginUtils.executeDispatchesInOrder(event, executeDispatch);
            if (!event.isPersistent()) {
                event.constructor.release(event)
            }
        }
    };
    var InstanceHandle = null;

    function validateInstanceHandle() {
        var invalid = !InstanceHandle || !InstanceHandle.traverseTwoPhase || !InstanceHandle.traverseEnterLeave;
        if (invalid) {
            throw new Error("InstanceHandle not injected before use!")
        }
    }

    var EventPluginHub = {injection: {injectMount: EventPluginUtils.injection.injectMount, injectInstanceHandle: function (InjectedInstanceHandle) {
        InstanceHandle = InjectedInstanceHandle;
        if ("production" !== "production") {
            validateInstanceHandle()
        }
    }, getInstanceHandle: function () {
        if ("production" !== "production") {
            validateInstanceHandle()
        }
        return InstanceHandle
    }, injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder, injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName}, eventNameDispatchConfigs: EventPluginRegistry.eventNameDispatchConfigs, registrationNameModules: EventPluginRegistry.registrationNameModules, putListener: function (id, registrationName, listener) {
        "production" !== "production" ? invariant(!listener || typeof listener === "function", "Expected %s listener to be a function, instead got type %s", registrationName, typeof listener) : invariant(!listener || typeof listener === "function");
        var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
        bankForRegistrationName[id] = listener
    }, getListener: function (id, registrationName) {
        var bankForRegistrationName = listenerBank[registrationName];
        return bankForRegistrationName && bankForRegistrationName[id]
    }, deleteListener: function (id, registrationName) {
        var bankForRegistrationName = listenerBank[registrationName];
        if (bankForRegistrationName) {
            delete bankForRegistrationName[id]
        }
    }, deleteAllListeners: function (id) {
        for (var registrationName in listenerBank) {
            delete listenerBank[registrationName][id]
        }
    }, extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
        var events;
        var plugins = EventPluginRegistry.plugins;
        for (var i = 0, l = plugins.length; i < l; i++) {
            var possiblePlugin = plugins[i];
            if (possiblePlugin) {
                var extractedEvents = possiblePlugin.extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent);
                if (extractedEvents) {
                    events = accumulateInto(events, extractedEvents)
                }
            }
        }
        return events
    }, enqueueEvents: function (events) {
        if (events) {
            eventQueue = accumulateInto(eventQueue, events)
        }
    }, processEventQueue: function () {
        var processingEventQueue = eventQueue;
        eventQueue = null;
        forEachAccumulated(processingEventQueue, executeDispatchesAndRelease);
        "production" !== "production" ? invariant(!eventQueue, "processEventQueue(): Additional events were enqueued while processing " + "an event queue. Support for this has not yet been implemented.") : invariant(!eventQueue)
    }, __purge: function () {
        listenerBank = {}
    }, __getListenerBank: function () {
        return listenerBank
    }};
    module.exports = EventPluginHub
}, {"./EventPluginRegistry": 85, "./EventPluginUtils": 86, "./accumulateInto": 164, "./forEachAccumulated": 179, "./invariant": 193}], 85: [function (require, module, exports) {
    "use strict";
    var invariant = require("./invariant");
    var EventPluginOrder = null;
    var namesToPlugins = {};

    function recomputePluginOrdering() {
        if (!EventPluginOrder) {
            return
        }
        for (var pluginName in namesToPlugins) {
            var PluginModule = namesToPlugins[pluginName];
            var pluginIndex = EventPluginOrder.indexOf(pluginName);
            "production" !== "production" ? invariant(pluginIndex > -1, "EventPluginRegistry: Cannot inject event plugins that do not exist in " + "the plugin ordering, `%s`.", pluginName) : invariant(pluginIndex > -1);
            if (EventPluginRegistry.plugins[pluginIndex]) {
                continue
            }
            "production" !== "production" ? invariant(PluginModule.extractEvents, "EventPluginRegistry: Event plugins must implement an `extractEvents` " + "method, but `%s` does not.", pluginName) : invariant(PluginModule.extractEvents);
            EventPluginRegistry.plugins[pluginIndex] = PluginModule;
            var publishedEvents = PluginModule.eventTypes;
            for (var eventName in publishedEvents) {
                "production" !== "production" ? invariant(publishEventForPlugin(publishedEvents[eventName], PluginModule, eventName), "EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.", eventName, pluginName) : invariant(publishEventForPlugin(publishedEvents[eventName], PluginModule, eventName))
            }
        }
    }

    function publishEventForPlugin(dispatchConfig, PluginModule, eventName) {
        "production" !== "production" ? invariant(!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName), "EventPluginHub: More than one plugin attempted to publish the same " + "event name, `%s`.", eventName) : invariant(!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName));
        EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;
        var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
        if (phasedRegistrationNames) {
            for (var phaseName in phasedRegistrationNames) {
                if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
                    var phasedRegistrationName = phasedRegistrationNames[phaseName];
                    publishRegistrationName(phasedRegistrationName, PluginModule, eventName)
                }
            }
            return true
        } else if (dispatchConfig.registrationName) {
            publishRegistrationName(dispatchConfig.registrationName, PluginModule, eventName);
            return true
        }
        return false
    }

    function publishRegistrationName(registrationName, PluginModule, eventName) {
        "production" !== "production" ? invariant(!EventPluginRegistry.registrationNameModules[registrationName], "EventPluginHub: More than one plugin attempted to publish the same " + "registration name, `%s`.", registrationName) : invariant(!EventPluginRegistry.registrationNameModules[registrationName]);
        EventPluginRegistry.registrationNameModules[registrationName] = PluginModule;
        EventPluginRegistry.registrationNameDependencies[registrationName] = PluginModule.eventTypes[eventName].dependencies
    }

    var EventPluginRegistry = {plugins: [], eventNameDispatchConfigs: {}, registrationNameModules: {}, registrationNameDependencies: {}, injectEventPluginOrder: function (InjectedEventPluginOrder) {
        "production" !== "production" ? invariant(!EventPluginOrder, "EventPluginRegistry: Cannot inject event plugin ordering more than " + "once. You are likely trying to load more than one copy of React.") : invariant(!EventPluginOrder);
        EventPluginOrder = Array.prototype.slice.call(InjectedEventPluginOrder);
        recomputePluginOrdering()
    }, injectEventPluginsByName: function (injectedNamesToPlugins) {
        var isOrderingDirty = false;
        for (var pluginName in injectedNamesToPlugins) {
            if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
                continue
            }
            var PluginModule = injectedNamesToPlugins[pluginName];
            if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== PluginModule) {
                "production" !== "production" ? invariant(!namesToPlugins[pluginName], "EventPluginRegistry: Cannot inject two different event plugins " + "using the same name, `%s`.", pluginName) : invariant(!namesToPlugins[pluginName]);
                namesToPlugins[pluginName] = PluginModule;
                isOrderingDirty = true
            }
        }
        if (isOrderingDirty) {
            recomputePluginOrdering()
        }
    }, getPluginModuleForEvent: function (event) {
        var dispatchConfig = event.dispatchConfig;
        if (dispatchConfig.registrationName) {
            return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null
        }
        for (var phase in dispatchConfig.phasedRegistrationNames) {
            if (!dispatchConfig.phasedRegistrationNames.hasOwnProperty(phase)) {
                continue
            }
            var PluginModule = EventPluginRegistry.registrationNameModules[dispatchConfig.phasedRegistrationNames[phase]];
            if (PluginModule) {
                return PluginModule
            }
        }
        return null
    }, _resetEventPlugins: function () {
        EventPluginOrder = null;
        for (var pluginName in namesToPlugins) {
            if (namesToPlugins.hasOwnProperty(pluginName)) {
                delete namesToPlugins[pluginName]
            }
        }
        EventPluginRegistry.plugins.length = 0;
        var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
        for (var eventName in eventNameDispatchConfigs) {
            if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
                delete eventNameDispatchConfigs[eventName]
            }
        }
        var registrationNameModules = EventPluginRegistry.registrationNameModules;
        for (var registrationName in registrationNameModules) {
            if (registrationNameModules.hasOwnProperty(registrationName)) {
                delete registrationNameModules[registrationName]
            }
        }
    }};
    module.exports = EventPluginRegistry
}, {"./invariant": 193}], 86: [function (require, module, exports) {
    "use strict";
    var EventConstants = require("./EventConstants");
    var invariant = require("./invariant");
    var injection = {Mount: null, injectMount: function (InjectedMount) {
        injection.Mount = InjectedMount;
        if ("production" !== "production") {
            "production" !== "production" ? invariant(InjectedMount && InjectedMount.getNode, "EventPluginUtils.injection.injectMount(...): Injected Mount module " + "is missing getNode.") : invariant(InjectedMount && InjectedMount.getNode)
        }
    }};
    var topLevelTypes = EventConstants.topLevelTypes;

    function isEndish(topLevelType) {
        return topLevelType === topLevelTypes.topMouseUp || topLevelType === topLevelTypes.topTouchEnd || topLevelType === topLevelTypes.topTouchCancel
    }

    function isMoveish(topLevelType) {
        return topLevelType === topLevelTypes.topMouseMove || topLevelType === topLevelTypes.topTouchMove
    }

    function isStartish(topLevelType) {
        return topLevelType === topLevelTypes.topMouseDown || topLevelType === topLevelTypes.topTouchStart
    }

    var validateEventDispatches;
    if ("production" !== "production") {
        validateEventDispatches = function (event) {
            var dispatchListeners = event._dispatchListeners;
            var dispatchIDs = event._dispatchIDs;
            var listenersIsArr = Array.isArray(dispatchListeners);
            var idsIsArr = Array.isArray(dispatchIDs);
            var IDsLen = idsIsArr ? dispatchIDs.length : dispatchIDs ? 1 : 0;
            var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;
            "production" !== "production" ? invariant(idsIsArr === listenersIsArr && IDsLen === listenersLen, "EventPluginUtils: Invalid `event`.") : invariant(idsIsArr === listenersIsArr && IDsLen === listenersLen)
        }
    }
    function forEachEventDispatch(event, cb) {
        var dispatchListeners = event._dispatchListeners;
        var dispatchIDs = event._dispatchIDs;
        if ("production" !== "production") {
            validateEventDispatches(event)
        }
        if (Array.isArray(dispatchListeners)) {
            for (var i = 0; i < dispatchListeners.length; i++) {
                if (event.isPropagationStopped()) {
                    break
                }
                cb(event, dispatchListeners[i], dispatchIDs[i])
            }
        } else if (dispatchListeners) {
            cb(event, dispatchListeners, dispatchIDs)
        }
    }

    function executeDispatch(event, listener, domID) {
        event.currentTarget = injection.Mount.getNode(domID);
        var returnValue = listener(event, domID);
        event.currentTarget = null;
        return returnValue
    }

    function executeDispatchesInOrder(event, executeDispatch) {
        forEachEventDispatch(event, executeDispatch);
        event._dispatchListeners = null;
        event._dispatchIDs = null
    }

    function executeDispatchesInOrderStopAtTrueImpl(event) {
        var dispatchListeners = event._dispatchListeners;
        var dispatchIDs = event._dispatchIDs;
        if ("production" !== "production") {
            validateEventDispatches(event)
        }
        if (Array.isArray(dispatchListeners)) {
            for (var i = 0; i < dispatchListeners.length; i++) {
                if (event.isPropagationStopped()) {
                    break
                }
                if (dispatchListeners[i](event, dispatchIDs[i])) {
                    return dispatchIDs[i]
                }
            }
        } else if (dispatchListeners) {
            if (dispatchListeners(event, dispatchIDs)) {
                return dispatchIDs
            }
        }
        return null
    }

    function executeDispatchesInOrderStopAtTrue(event) {
        var ret = executeDispatchesInOrderStopAtTrueImpl(event);
        event._dispatchIDs = null;
        event._dispatchListeners = null;
        return ret
    }

    function executeDirectDispatch(event) {
        if ("production" !== "production") {
            validateEventDispatches(event)
        }
        var dispatchListener = event._dispatchListeners;
        var dispatchID = event._dispatchIDs;
        "production" !== "production" ? invariant(!Array.isArray(dispatchListener), "executeDirectDispatch(...): Invalid `event`.") : invariant(!Array.isArray(dispatchListener));
        var res = dispatchListener ? dispatchListener(event, dispatchID) : null;
        event._dispatchListeners = null;
        event._dispatchIDs = null;
        return res
    }

    function hasDispatches(event) {
        return!!event._dispatchListeners
    }

    var EventPluginUtils = {isEndish: isEndish, isMoveish: isMoveish, isStartish: isStartish, executeDirectDispatch: executeDirectDispatch, executeDispatch: executeDispatch, executeDispatchesInOrder: executeDispatchesInOrder, executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue, hasDispatches: hasDispatches, injection: injection, useTouchEvents: false};
    module.exports = EventPluginUtils
}, {"./EventConstants": 82, "./invariant": 193}], 87: [function (require, module, exports) {
    "use strict";
    var EventConstants = require("./EventConstants");
    var EventPluginHub = require("./EventPluginHub");
    var accumulateInto = require("./accumulateInto");
    var forEachAccumulated = require("./forEachAccumulated");
    var PropagationPhases = EventConstants.PropagationPhases;
    var getListener = EventPluginHub.getListener;

    function listenerAtPhase(id, event, propagationPhase) {
        var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
        return getListener(id, registrationName)
    }

    function accumulateDirectionalDispatches(domID, upwards, event) {
        if ("production" !== "production") {
            if (!domID) {
                throw new Error("Dispatching id must not be null")
            }
        }
        var phase = upwards ? PropagationPhases.bubbled : PropagationPhases.captured;
        var listener = listenerAtPhase(domID, event, phase);
        if (listener) {
            event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
            event._dispatchIDs = accumulateInto(event._dispatchIDs, domID)
        }
    }

    function accumulateTwoPhaseDispatchesSingle(event) {
        if (event && event.dispatchConfig.phasedRegistrationNames) {
            EventPluginHub.injection.getInstanceHandle().traverseTwoPhase(event.dispatchMarker, accumulateDirectionalDispatches, event)
        }
    }

    function accumulateDispatches(id, ignoredDirection, event) {
        if (event && event.dispatchConfig.registrationName) {
            var registrationName = event.dispatchConfig.registrationName;
            var listener = getListener(id, registrationName);
            if (listener) {
                event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
                event._dispatchIDs = accumulateInto(event._dispatchIDs, id)
            }
        }
    }

    function accumulateDirectDispatchesSingle(event) {
        if (event && event.dispatchConfig.registrationName) {
            accumulateDispatches(event.dispatchMarker, null, event)
        }
    }

    function accumulateTwoPhaseDispatches(events) {
        forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle)
    }

    function accumulateEnterLeaveDispatches(leave, enter, fromID, toID) {
        EventPluginHub.injection.getInstanceHandle().traverseEnterLeave(fromID, toID, accumulateDispatches, leave, enter)
    }

    function accumulateDirectDispatches(events) {
        forEachAccumulated(events, accumulateDirectDispatchesSingle)
    }

    var EventPropagators = {accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches, accumulateDirectDispatches: accumulateDirectDispatches, accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches};
    module.exports = EventPropagators
}, {"./EventConstants": 82, "./EventPluginHub": 84, "./accumulateInto": 164, "./forEachAccumulated": 179}], 88: [function (require, module, exports) {
    "use strict";
    var canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);
    var ExecutionEnvironment = {canUseDOM: canUseDOM, canUseWorkers: typeof Worker !== "undefined", canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent), canUseViewport: canUseDOM && !!window.screen, isInWorker: !canUseDOM};
    module.exports = ExecutionEnvironment
}, {}], 89: [function (require, module, exports) {
    "use strict";
    var DOMProperty = require("./DOMProperty");
    var ExecutionEnvironment = require("./ExecutionEnvironment");
    var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;
    var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
    var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
    var HAS_SIDE_EFFECTS = DOMProperty.injection.HAS_SIDE_EFFECTS;
    var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
    var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
    var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;
    var hasSVG;
    if (ExecutionEnvironment.canUseDOM) {
        var implementation = document.implementation;
        hasSVG = implementation && implementation.hasFeature && implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1")
    }
    var HTMLDOMPropertyConfig = {isCustomAttribute: RegExp.prototype.test.bind(/^(data|aria)-[a-z_][a-z\d_.\-]*$/), Properties: {accept: null, acceptCharset: null, accessKey: null, action: null, allowFullScreen: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE, allowTransparency: MUST_USE_ATTRIBUTE, alt: null, async: HAS_BOOLEAN_VALUE, autoComplete: null, autoPlay: HAS_BOOLEAN_VALUE, cellPadding: null, cellSpacing: null, charSet: MUST_USE_ATTRIBUTE, checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE, classID: MUST_USE_ATTRIBUTE, className: hasSVG ? MUST_USE_ATTRIBUTE : MUST_USE_PROPERTY, cols: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE, colSpan: null, content: null, contentEditable: null, contextMenu: MUST_USE_ATTRIBUTE, controls: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE, coords: null, crossOrigin: null, data: null, dateTime: MUST_USE_ATTRIBUTE, defer: HAS_BOOLEAN_VALUE, dir: null, disabled: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE, download: HAS_OVERLOADED_BOOLEAN_VALUE, draggable: null, encType: null, form: MUST_USE_ATTRIBUTE, formNoValidate: HAS_BOOLEAN_VALUE, frameBorder: MUST_USE_ATTRIBUTE, height: MUST_USE_ATTRIBUTE, hidden: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE, href: null, hrefLang: null, htmlFor: null, httpEquiv: null, icon: null, id: MUST_USE_PROPERTY, label: null, lang: null, list: MUST_USE_ATTRIBUTE, loop: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE, manifest: MUST_USE_ATTRIBUTE, max: null, maxLength: MUST_USE_ATTRIBUTE, media: MUST_USE_ATTRIBUTE, mediaGroup: null, method: null, min: null, multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE, muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE, name: null, noValidate: HAS_BOOLEAN_VALUE, open: null, pattern: null, placeholder: null, poster: null, preload: null, radioGroup: null, readOnly: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE, rel: null, required: HAS_BOOLEAN_VALUE, role: MUST_USE_ATTRIBUTE, rows: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE, rowSpan: null, sandbox: null, scope: null, scrolling: null, seamless: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE, selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE, shape: null, size: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE, sizes: MUST_USE_ATTRIBUTE, span: HAS_POSITIVE_NUMERIC_VALUE, spellCheck: null, src: null, srcDoc: MUST_USE_PROPERTY, srcSet: MUST_USE_ATTRIBUTE, start: HAS_NUMERIC_VALUE, step: null, style: null, tabIndex: null, target: null, title: null, type: null, useMap: null, value: MUST_USE_PROPERTY | HAS_SIDE_EFFECTS, width: MUST_USE_ATTRIBUTE, wmode: MUST_USE_ATTRIBUTE, autoCapitalize: null, autoCorrect: null, itemProp: MUST_USE_ATTRIBUTE, itemScope: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE, itemType: MUST_USE_ATTRIBUTE, property: null}, DOMAttributeNames: {acceptCharset: "accept-charset", className: "class", htmlFor: "for", httpEquiv: "http-equiv"}, DOMPropertyNames: {autoCapitalize: "autocapitalize", autoComplete: "autocomplete", autoCorrect: "autocorrect", autoFocus: "autofocus", autoPlay: "autoplay", encType: "enctype", hrefLang: "hreflang", radioGroup: "radiogroup", spellCheck: "spellcheck", srcDoc: "srcdoc", srcSet: "srcset"}};
    module.exports = HTMLDOMPropertyConfig
}, {"./DOMProperty": 77, "./ExecutionEnvironment": 88}], 90: [function (require, module, exports) {
    "use strict";
    var ReactPropTypes = require("./ReactPropTypes");
    var invariant = require("./invariant");
    var hasReadOnlyValue = {button: true, checkbox: true, image: true, hidden: true, radio: true, reset: true, submit: true};

    function _assertSingleLink(input) {
        "production" !== "production" ? invariant(input.props.checkedLink == null || input.props.valueLink == null, "Cannot provide a checkedLink and a valueLink. If you want to use " + "checkedLink, you probably don't want to use valueLink and vice versa.") : invariant(input.props.checkedLink == null || input.props.valueLink == null)
    }

    function _assertValueLink(input) {
        _assertSingleLink(input);
        "production" !== "production" ? invariant(input.props.value == null && input.props.onChange == null, "Cannot provide a valueLink and a value or onChange event. If you want " + "to use value or onChange, you probably don't want to use valueLink.") : invariant(input.props.value == null && input.props.onChange == null)
    }

    function _assertCheckedLink(input) {
        _assertSingleLink(input);
        "production" !== "production" ? invariant(input.props.checked == null && input.props.onChange == null, "Cannot provide a checkedLink and a checked property or onChange event. " + "If you want to use checked or onChange, you probably don't want to " + "use checkedLink") : invariant(input.props.checked == null && input.props.onChange == null)
    }

    function _handleLinkedValueChange(e) {
        this.props.valueLink.requestChange(e.target.value)
    }

    function _handleLinkedCheckChange(e) {
        this.props.checkedLink.requestChange(e.target.checked)
    }

    var LinkedValueUtils = {Mixin: {propTypes: {value: function (props, propName, componentName) {
        if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
            return
        }
        return new Error("You provided a `value` prop to a form field without an " + "`onChange` handler. This will render a read-only field. If " + "the field should be mutable use `defaultValue`. Otherwise, " + "set either `onChange` or `readOnly`.")
    }, checked: function (props, propName, componentName) {
        if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
            return
        }
        return new Error("You provided a `checked` prop to a form field without an " + "`onChange` handler. This will render a read-only field. If " + "the field should be mutable use `defaultChecked`. Otherwise, " + "set either `onChange` or `readOnly`.")
    }, onChange: ReactPropTypes.func}}, getValue: function (input) {
        if (input.props.valueLink) {
            _assertValueLink(input);
            return input.props.valueLink.value
        }
        return input.props.value
    }, getChecked: function (input) {
        if (input.props.checkedLink) {
            _assertCheckedLink(input);
            return input.props.checkedLink.value
        }
        return input.props.checked
    }, getOnChange: function (input) {
        if (input.props.valueLink) {
            _assertValueLink(input);
            return _handleLinkedValueChange
        } else if (input.props.checkedLink) {
            _assertCheckedLink(input);
            return _handleLinkedCheckChange
        }
        return input.props.onChange
    }};
    module.exports = LinkedValueUtils
}, {"./ReactPropTypes": 139, "./invariant": 193}], 91: [function (require, module, exports) {
    "use strict";
    var ReactBrowserEventEmitter = require("./ReactBrowserEventEmitter");
    var accumulateInto = require("./accumulateInto");
    var forEachAccumulated = require("./forEachAccumulated");
    var invariant = require("./invariant");

    function remove(event) {
        event.remove()
    }

    var LocalEventTrapMixin = {trapBubbledEvent: function (topLevelType, handlerBaseName) {
        "production" !== "production" ? invariant(this.isMounted(), "Must be mounted to trap events") : invariant(this.isMounted());
        var listener = ReactBrowserEventEmitter.trapBubbledEvent(topLevelType, handlerBaseName, this.getDOMNode());
        this._localEventListeners = accumulateInto(this._localEventListeners, listener)
    }, componentWillUnmount: function () {
        if (this._localEventListeners) {
            forEachAccumulated(this._localEventListeners, remove)
        }
    }};
    module.exports = LocalEventTrapMixin
}, {"./ReactBrowserEventEmitter": 97, "./accumulateInto": 164, "./forEachAccumulated": 179, "./invariant": 193}], 92: [function (require, module, exports) {
    "use strict";
    var EventConstants = require("./EventConstants");
    var emptyFunction = require("./emptyFunction");
    var topLevelTypes = EventConstants.topLevelTypes;
    var MobileSafariClickEventPlugin = {eventTypes: null, extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
        if (topLevelType === topLevelTypes.topTouchStart) {
            var target = nativeEvent.target;
            if (target && !target.onclick) {
                target.onclick = emptyFunction
            }
        }
    }};
    module.exports = MobileSafariClickEventPlugin
}, {"./EventConstants": 82, "./emptyFunction": 174}], 93: [function (require, module, exports) {
    function assign(target, sources) {
        if (target == null) {
            throw new TypeError("Object.assign target cannot be null or undefined")
        }
        var to = Object(target);
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        for (var nextIndex = 1; nextIndex < arguments.length; nextIndex++) {
            var nextSource = arguments[nextIndex];
            if (nextSource == null) {
                continue
            }
            var from = Object(nextSource);
            for (var key in from) {
                if (hasOwnProperty.call(from, key)) {
                    to[key] = from[key]
                }
            }
        }
        return to
    }

    module.exports = assign
}, {}], 94: [function (require, module, exports) {
    "use strict";
    var invariant = require("./invariant");
    var oneArgumentPooler = function (copyFieldsFrom) {
        var Klass = this;
        if (Klass.instancePool.length) {
            var instance = Klass.instancePool.pop();
            Klass.call(instance, copyFieldsFrom);
            return instance
        } else {
            return new Klass(copyFieldsFrom)
        }
    };
    var twoArgumentPooler = function (a1, a2) {
        var Klass = this;
        if (Klass.instancePool.length) {
            var instance = Klass.instancePool.pop();
            Klass.call(instance, a1, a2);
            return instance
        } else {
            return new Klass(a1, a2)
        }
    };
    var threeArgumentPooler = function (a1, a2, a3) {
        var Klass = this;
        if (Klass.instancePool.length) {
            var instance = Klass.instancePool.pop();
            Klass.call(instance, a1, a2, a3);
            return instance
        } else {
            return new Klass(a1, a2, a3)
        }
    };
    var fiveArgumentPooler = function (a1, a2, a3, a4, a5) {
        var Klass = this;
        if (Klass.instancePool.length) {
            var instance = Klass.instancePool.pop();
            Klass.call(instance, a1, a2, a3, a4, a5);
            return instance
        } else {
            return new Klass(a1, a2, a3, a4, a5)
        }
    };
    var standardReleaser = function (instance) {
        var Klass = this;
        "production" !== "production" ? invariant(instance instanceof Klass, "Trying to release an instance into a pool of a different type.") : invariant(instance instanceof Klass);
        if (instance.destructor) {
            instance.destructor()
        }
        if (Klass.instancePool.length < Klass.poolSize) {
            Klass.instancePool.push(instance)
        }
    };
    var DEFAULT_POOL_SIZE = 10;
    var DEFAULT_POOLER = oneArgumentPooler;
    var addPoolingTo = function (CopyConstructor, pooler) {
        var NewKlass = CopyConstructor;
        NewKlass.instancePool = [];
        NewKlass.getPooled = pooler || DEFAULT_POOLER;
        if (!NewKlass.poolSize) {
            NewKlass.poolSize = DEFAULT_POOL_SIZE
        }
        NewKlass.release = standardReleaser;
        return NewKlass
    };
    var PooledClass = {addPoolingTo: addPoolingTo, oneArgumentPooler: oneArgumentPooler, twoArgumentPooler: twoArgumentPooler, threeArgumentPooler: threeArgumentPooler, fiveArgumentPooler: fiveArgumentPooler};
    module.exports = PooledClass
}, {"./invariant": 193}], 95: [function (require, module, exports) {
    "use strict";
    var DOMPropertyOperations = require("./DOMPropertyOperations");
    var EventPluginUtils = require("./EventPluginUtils");
    var ReactChildren = require("./ReactChildren");
    var ReactComponent = require("./ReactComponent");
    var ReactCompositeComponent = require("./ReactCompositeComponent");
    var ReactContext = require("./ReactContext");
    var ReactCurrentOwner = require("./ReactCurrentOwner");
    var ReactElement = require("./ReactElement");
    var ReactElementValidator = require("./ReactElementValidator");
    var ReactDOM = require("./ReactDOM");
    var ReactDOMComponent = require("./ReactDOMComponent");
    var ReactDefaultInjection = require("./ReactDefaultInjection");
    var ReactInstanceHandles = require("./ReactInstanceHandles");
    var ReactLegacyElement = require("./ReactLegacyElement");
    var ReactMount = require("./ReactMount");
    var ReactMultiChild = require("./ReactMultiChild");
    var ReactPerf = require("./ReactPerf");
    var ReactPropTypes = require("./ReactPropTypes");
    var ReactServerRendering = require("./ReactServerRendering");
    var ReactTextComponent = require("./ReactTextComponent");
    var assign = require("./Object.assign");
    var deprecated = require("./deprecated");
    var onlyChild = require("./onlyChild");
    ReactDefaultInjection.inject();
    var createElement = ReactElement.createElement;
    var createFactory = ReactElement.createFactory;
    if ("production" !== "production") {
        createElement = ReactElementValidator.createElement;
        createFactory = ReactElementValidator.createFactory
    }
    createElement = ReactLegacyElement.wrapCreateElement(createElement);
    createFactory = ReactLegacyElement.wrapCreateFactory(createFactory);
    var render = ReactPerf.measure("React", "render", ReactMount.render);
    var React = {Children: {map: ReactChildren.map, forEach: ReactChildren.forEach, count: ReactChildren.count, only: onlyChild}, DOM: ReactDOM, PropTypes: ReactPropTypes, initializeTouchEvents: function (shouldUseTouch) {
        EventPluginUtils.useTouchEvents = shouldUseTouch
    }, createClass: ReactCompositeComponent.createClass, createElement: createElement, createFactory: createFactory, constructAndRenderComponent: ReactMount.constructAndRenderComponent, constructAndRenderComponentByID: ReactMount.constructAndRenderComponentByID, render: render, renderToString: ReactServerRendering.renderToString, renderToStaticMarkup: ReactServerRendering.renderToStaticMarkup, unmountComponentAtNode: ReactMount.unmountComponentAtNode, isValidClass: ReactLegacyElement.isValidClass, isValidElement: ReactElement.isValidElement, withContext: ReactContext.withContext, __spread: assign, renderComponent: deprecated("React", "renderComponent", "render", this, render), renderComponentToString: deprecated("React", "renderComponentToString", "renderToString", this, ReactServerRendering.renderToString), renderComponentToStaticMarkup: deprecated("React", "renderComponentToStaticMarkup", "renderToStaticMarkup", this, ReactServerRendering.renderToStaticMarkup), isValidComponent: deprecated("React", "isValidComponent", "isValidElement", this, ReactElement.isValidElement)};
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === "function") {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({Component: ReactComponent, CurrentOwner: ReactCurrentOwner, DOMComponent: ReactDOMComponent, DOMPropertyOperations: DOMPropertyOperations, InstanceHandles: ReactInstanceHandles, Mount: ReactMount, MultiChild: ReactMultiChild, TextComponent: ReactTextComponent})
    }
    if ("production" !== "production") {
        var ExecutionEnvironment = require("./ExecutionEnvironment");
        if (ExecutionEnvironment.canUseDOM && window.top === window.self) {
            if (navigator.userAgent.indexOf("Chrome") > -1) {
                if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined") {
                    console.debug("Download the React DevTools for a better development experience: " + "http://fb.me/react-devtools")
                }
            }
            var expectedFeatures = [Array.isArray, Array.prototype.every, Array.prototype.forEach, Array.prototype.indexOf, Array.prototype.map, Date.now, Function.prototype.bind, Object.keys, String.prototype.split, String.prototype.trim, Object.create, Object.freeze];
            for (var i = 0; i < expectedFeatures.length; i++) {
                if (!expectedFeatures[i]) {
                    console.error("One or more ES5 shim/shams expected by React are not available: " + "http://fb.me/react-warning-polyfills");
                    break
                }
            }
        }
    }
    React.version = "0.12.1";
    module.exports = React
}, {"./DOMPropertyOperations": 78, "./EventPluginUtils": 86, "./ExecutionEnvironment": 88, "./Object.assign": 93, "./ReactChildren": 98, "./ReactComponent": 99, "./ReactCompositeComponent": 101, "./ReactContext": 102, "./ReactCurrentOwner": 103, "./ReactDOM": 104, "./ReactDOMComponent": 106, "./ReactDefaultInjection": 116, "./ReactElement": 119, "./ReactElementValidator": 120, "./ReactInstanceHandles": 127, "./ReactLegacyElement": 128, "./ReactMount": 130, "./ReactMultiChild": 131, "./ReactPerf": 135, "./ReactPropTypes": 139, "./ReactServerRendering": 143, "./ReactTextComponent": 145, "./deprecated": 173, "./onlyChild": 204}], 96: [function (require, module, exports) {
    "use strict";
    var ReactEmptyComponent = require("./ReactEmptyComponent");
    var ReactMount = require("./ReactMount");
    var invariant = require("./invariant");
    var ReactBrowserComponentMixin = {getDOMNode: function () {
        "production" !== "production" ? invariant(this.isMounted(), "getDOMNode(): A component must be mounted to have a DOM node.") : invariant(this.isMounted());
        if (ReactEmptyComponent.isNullComponentID(this._rootNodeID)) {
            return null
        }
        return ReactMount.getNode(this._rootNodeID)
    }};
    module.exports = ReactBrowserComponentMixin
}, {"./ReactEmptyComponent": 121, "./ReactMount": 130, "./invariant": 193}], 97: [function (require, module, exports) {
    "use strict";
    var EventConstants = require("./EventConstants");
    var EventPluginHub = require("./EventPluginHub");
    var EventPluginRegistry = require("./EventPluginRegistry");
    var ReactEventEmitterMixin = require("./ReactEventEmitterMixin");
    var ViewportMetrics = require("./ViewportMetrics");
    var assign = require("./Object.assign");
    var isEventSupported = require("./isEventSupported");
    var alreadyListeningTo = {};
    var isMonitoringScrollValue = false;
    var reactTopListenersCounter = 0;
    var topEventMapping = {topBlur: "blur", topChange: "change", topClick: "click", topCompositionEnd: "compositionend", topCompositionStart: "compositionstart", topCompositionUpdate: "compositionupdate", topContextMenu: "contextmenu", topCopy: "copy", topCut: "cut", topDoubleClick: "dblclick", topDrag: "drag", topDragEnd: "dragend", topDragEnter: "dragenter", topDragExit: "dragexit", topDragLeave: "dragleave", topDragOver: "dragover", topDragStart: "dragstart", topDrop: "drop", topFocus: "focus", topInput: "input", topKeyDown: "keydown", topKeyPress: "keypress", topKeyUp: "keyup", topMouseDown: "mousedown", topMouseMove: "mousemove", topMouseOut: "mouseout", topMouseOver: "mouseover", topMouseUp: "mouseup", topPaste: "paste", topScroll: "scroll", topSelectionChange: "selectionchange", topTextInput: "textInput", topTouchCancel: "touchcancel", topTouchEnd: "touchend", topTouchMove: "touchmove", topTouchStart: "touchstart", topWheel: "wheel"};
    var topListenersIDKey = "_reactListenersID" + String(Math.random()).slice(2);

    function getListeningForDocument(mountAt) {
        if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
            mountAt[topListenersIDKey] = reactTopListenersCounter++;
            alreadyListeningTo[mountAt[topListenersIDKey]] = {}
        }
        return alreadyListeningTo[mountAt[topListenersIDKey]]
    }

    var ReactBrowserEventEmitter = assign({}, ReactEventEmitterMixin, {ReactEventListener: null, injection: {injectReactEventListener: function (ReactEventListener) {
        ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel);
        ReactBrowserEventEmitter.ReactEventListener = ReactEventListener
    }}, setEnabled: function (enabled) {
        if (ReactBrowserEventEmitter.ReactEventListener) {
            ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled)
        }
    }, isEnabled: function () {
        return!!(ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled())
    }, listenTo: function (registrationName, contentDocumentHandle) {
        var mountAt = contentDocumentHandle;
        var isListening = getListeningForDocument(mountAt);
        var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];
        var topLevelTypes = EventConstants.topLevelTypes;
        for (var i = 0, l = dependencies.length; i < l; i++) {
            var dependency = dependencies[i];
            if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
                if (dependency === topLevelTypes.topWheel) {
                    if (isEventSupported("wheel")) {
                        ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, "wheel", mountAt)
                    } else if (isEventSupported("mousewheel")) {
                        ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, "mousewheel", mountAt)
                    } else {
                        ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, "DOMMouseScroll", mountAt)
                    }
                } else if (dependency === topLevelTypes.topScroll) {
                    if (isEventSupported("scroll", true)) {
                        ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topScroll, "scroll", mountAt)
                    } else {
                        ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topScroll, "scroll", ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE)
                    }
                } else if (dependency === topLevelTypes.topFocus || dependency === topLevelTypes.topBlur) {
                    if (isEventSupported("focus", true)) {
                        ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topFocus, "focus", mountAt);
                        ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topBlur, "blur", mountAt)
                    } else if (isEventSupported("focusin")) {
                        ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topFocus, "focusin", mountAt);
                        ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topBlur, "focusout", mountAt)
                    }
                    isListening[topLevelTypes.topBlur] = true;
                    isListening[topLevelTypes.topFocus] = true
                } else if (topEventMapping.hasOwnProperty(dependency)) {
                    ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt)
                }
                isListening[dependency] = true
            }
        }
    }, trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {
        return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle)
    }, trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {
        return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle)
    }, ensureScrollValueMonitoring: function () {
        if (!isMonitoringScrollValue) {
            var refresh = ViewportMetrics.refreshScrollValues;
            ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
            isMonitoringScrollValue = true
        }
    }, eventNameDispatchConfigs: EventPluginHub.eventNameDispatchConfigs, registrationNameModules: EventPluginHub.registrationNameModules, putListener: EventPluginHub.putListener, getListener: EventPluginHub.getListener, deleteListener: EventPluginHub.deleteListener, deleteAllListeners: EventPluginHub.deleteAllListeners});
    module.exports = ReactBrowserEventEmitter
}, {"./EventConstants": 82, "./EventPluginHub": 84, "./EventPluginRegistry": 85, "./Object.assign": 93, "./ReactEventEmitterMixin": 123, "./ViewportMetrics": 163, "./isEventSupported": 194}], 98: [function (require, module, exports) {
    "use strict";
    var PooledClass = require("./PooledClass");
    var traverseAllChildren = require("./traverseAllChildren");
    var warning = require("./warning");
    var twoArgumentPooler = PooledClass.twoArgumentPooler;
    var threeArgumentPooler = PooledClass.threeArgumentPooler;

    function ForEachBookKeeping(forEachFunction, forEachContext) {
        this.forEachFunction = forEachFunction;
        this.forEachContext = forEachContext
    }

    PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);
    function forEachSingleChild(traverseContext, child, name, i) {
        var forEachBookKeeping = traverseContext;
        forEachBookKeeping.forEachFunction.call(forEachBookKeeping.forEachContext, child, i)
    }

    function forEachChildren(children, forEachFunc, forEachContext) {
        if (children == null) {
            return children
        }
        var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
        traverseAllChildren(children, forEachSingleChild, traverseContext);
        ForEachBookKeeping.release(traverseContext)
    }

    function MapBookKeeping(mapResult, mapFunction, mapContext) {
        this.mapResult = mapResult;
        this.mapFunction = mapFunction;
        this.mapContext = mapContext
    }

    PooledClass.addPoolingTo(MapBookKeeping, threeArgumentPooler);
    function mapSingleChildIntoContext(traverseContext, child, name, i) {
        var mapBookKeeping = traverseContext;
        var mapResult = mapBookKeeping.mapResult;
        var keyUnique = !mapResult.hasOwnProperty(name);
        "production" !== "production" ? warning(keyUnique, "ReactChildren.map(...): Encountered two children with the same key, " + "`%s`. Child keys must be unique; when two children share a key, only " + "the first child will be used.", name) : null;
        if (keyUnique) {
            var mappedChild = mapBookKeeping.mapFunction.call(mapBookKeeping.mapContext, child, i);
            mapResult[name] = mappedChild
        }
    }

    function mapChildren(children, func, context) {
        if (children == null) {
            return children
        }
        var mapResult = {};
        var traverseContext = MapBookKeeping.getPooled(mapResult, func, context);
        traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
        MapBookKeeping.release(traverseContext);
        return mapResult
    }

    function forEachSingleChildDummy(traverseContext, child, name, i) {
        return null
    }

    function countChildren(children, context) {
        return traverseAllChildren(children, forEachSingleChildDummy, null)
    }

    var ReactChildren = {forEach: forEachChildren, map: mapChildren, count: countChildren};
    module.exports = ReactChildren
}, {"./PooledClass": 94, "./traverseAllChildren": 211, "./warning": 212}], 99: [function (require, module, exports) {
    "use strict";
    var ReactElement = require("./ReactElement");
    var ReactOwner = require("./ReactOwner");
    var ReactUpdates = require("./ReactUpdates");
    var assign = require("./Object.assign");
    var invariant = require("./invariant");
    var keyMirror = require("./keyMirror");
    var ComponentLifeCycle = keyMirror({MOUNTED: null, UNMOUNTED: null});
    var injected = false;
    var unmountIDFromEnvironment = null;
    var mountImageIntoNode = null;
    var ReactComponent = {injection: {injectEnvironment: function (ReactComponentEnvironment) {
        "production" !== "production" ? invariant(!injected, "ReactComponent: injectEnvironment() can only be called once.") : invariant(!injected);
        mountImageIntoNode = ReactComponentEnvironment.mountImageIntoNode;
        unmountIDFromEnvironment = ReactComponentEnvironment.unmountIDFromEnvironment;
        ReactComponent.BackendIDOperations = ReactComponentEnvironment.BackendIDOperations;
        injected = true
    }}, LifeCycle: ComponentLifeCycle, BackendIDOperations: null, Mixin: {isMounted: function () {
        return this._lifeCycleState === ComponentLifeCycle.MOUNTED
    }, setProps: function (partialProps, callback) {
        var element = this._pendingElement || this._currentElement;
        this.replaceProps(assign({}, element.props, partialProps), callback)
    }, replaceProps: function (props, callback) {
        "production" !== "production" ? invariant(this.isMounted(), "replaceProps(...): Can only update a mounted component.") : invariant(this.isMounted());
        "production" !== "production" ? invariant(this._mountDepth === 0, "replaceProps(...): You called `setProps` or `replaceProps` on a " + "component with a parent. This is an anti-pattern since props will " + "get reactively updated when rendered. Instead, change the owner's " + "`render` method to pass the correct value as props to the component " + "where it is created.") : invariant(this._mountDepth === 0);
        this._pendingElement = ReactElement.cloneAndReplaceProps(this._pendingElement || this._currentElement, props);
        ReactUpdates.enqueueUpdate(this, callback)
    }, _setPropsInternal: function (partialProps, callback) {
        var element = this._pendingElement || this._currentElement;
        this._pendingElement = ReactElement.cloneAndReplaceProps(element, assign({}, element.props, partialProps));
        ReactUpdates.enqueueUpdate(this, callback)
    }, construct: function (element) {
        this.props = element.props;
        this._owner = element._owner;
        this._lifeCycleState = ComponentLifeCycle.UNMOUNTED;
        this._pendingCallbacks = null;
        this._currentElement = element;
        this._pendingElement = null
    }, mountComponent: function (rootID, transaction, mountDepth) {
        "production" !== "production" ? invariant(!this.isMounted(), "mountComponent(%s, ...): Can only mount an unmounted component. " + "Make sure to avoid storing components between renders or reusing a " + "single component instance in multiple places.", rootID) : invariant(!this.isMounted());
        var ref = this._currentElement.ref;
        if (ref != null) {
            var owner = this._currentElement._owner;
            ReactOwner.addComponentAsRefTo(this, ref, owner)
        }
        this._rootNodeID = rootID;
        this._lifeCycleState = ComponentLifeCycle.MOUNTED;
        this._mountDepth = mountDepth
    }, unmountComponent: function () {
        "production" !== "production" ? invariant(this.isMounted(), "unmountComponent(): Can only unmount a mounted component.") : invariant(this.isMounted());
        var ref = this._currentElement.ref;
        if (ref != null) {
            ReactOwner.removeComponentAsRefFrom(this, ref, this._owner)
        }
        unmountIDFromEnvironment(this._rootNodeID);
        this._rootNodeID = null;
        this._lifeCycleState = ComponentLifeCycle.UNMOUNTED
    }, receiveComponent: function (nextElement, transaction) {
        "production" !== "production" ? invariant(this.isMounted(), "receiveComponent(...): Can only update a mounted component.") : invariant(this.isMounted());
        this._pendingElement = nextElement;
        this.performUpdateIfNecessary(transaction)
    }, performUpdateIfNecessary: function (transaction) {
        if (this._pendingElement == null) {
            return
        }
        var prevElement = this._currentElement;
        var nextElement = this._pendingElement;
        this._currentElement = nextElement;
        this.props = nextElement.props;
        this._owner = nextElement._owner;
        this._pendingElement = null;
        this.updateComponent(transaction, prevElement)
    }, updateComponent: function (transaction, prevElement) {
        var nextElement = this._currentElement;
        if (nextElement._owner !== prevElement._owner || nextElement.ref !== prevElement.ref) {
            if (prevElement.ref != null) {
                ReactOwner.removeComponentAsRefFrom(this, prevElement.ref, prevElement._owner)
            }
            if (nextElement.ref != null) {
                ReactOwner.addComponentAsRefTo(this, nextElement.ref, nextElement._owner)
            }
        }
    }, mountComponentIntoNode: function (rootID, container, shouldReuseMarkup) {
        var transaction = ReactUpdates.ReactReconcileTransaction.getPooled();
        transaction.perform(this._mountComponentIntoNode, this, rootID, container, transaction, shouldReuseMarkup);
        ReactUpdates.ReactReconcileTransaction.release(transaction)
    }, _mountComponentIntoNode: function (rootID, container, transaction, shouldReuseMarkup) {
        var markup = this.mountComponent(rootID, transaction, 0);
        mountImageIntoNode(markup, container, shouldReuseMarkup)
    }, isOwnedBy: function (owner) {
        return this._owner === owner
    }, getSiblingByRef: function (ref) {
        var owner = this._owner;
        if (!owner || !owner.refs) {
            return null
        }
        return owner.refs[ref]
    }}};
    module.exports = ReactComponent
}, {"./Object.assign": 93, "./ReactElement": 119, "./ReactOwner": 134, "./ReactUpdates": 146, "./invariant": 193, "./keyMirror": 199}], 100: [function (require, module, exports) {
    "use strict";
    var ReactDOMIDOperations = require("./ReactDOMIDOperations");
    var ReactMarkupChecksum = require("./ReactMarkupChecksum");
    var ReactMount = require("./ReactMount");
    var ReactPerf = require("./ReactPerf");
    var ReactReconcileTransaction = require("./ReactReconcileTransaction");
    var getReactRootElementInContainer = require("./getReactRootElementInContainer");
    var invariant = require("./invariant");
    var setInnerHTML = require("./setInnerHTML");
    var ELEMENT_NODE_TYPE = 1;
    var DOC_NODE_TYPE = 9;
    var ReactComponentBrowserEnvironment = {ReactReconcileTransaction: ReactReconcileTransaction, BackendIDOperations: ReactDOMIDOperations, unmountIDFromEnvironment: function (rootNodeID) {
        ReactMount.purgeID(rootNodeID)
    }, mountImageIntoNode: ReactPerf.measure("ReactComponentBrowserEnvironment", "mountImageIntoNode", function (markup, container, shouldReuseMarkup) {
        "production" !== "production" ? invariant(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE), "mountComponentIntoNode(...): Target container is not valid.") : invariant(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE));
        if (shouldReuseMarkup) {
            if (ReactMarkupChecksum.canReuseMarkup(markup, getReactRootElementInContainer(container))) {
                return
            } else {
                "production" !== "production" ? invariant(container.nodeType !== DOC_NODE_TYPE, "You're trying to render a component to the document using " + "server rendering but the checksum was invalid. This usually " + "means you rendered a different component type or props on " + "the client from the one on the server, or your render() " + "methods are impure. React cannot handle this case due to " + "cross-browser quirks by rendering at the document root. You " + "should look for environment dependent code in your components " + "and ensure the props are the same client and server side.") : invariant(container.nodeType !== DOC_NODE_TYPE);
                if ("production" !== "production") {
                    console.warn("React attempted to use reuse markup in a container but the " + "checksum was invalid. This generally means that you are " + "using server rendering and the markup generated on the " + "server was not what the client was expecting. React injected " + "new markup to compensate which works but you have lost many " + "of the benefits of server rendering. Instead, figure out " + "why the markup being generated is different on the client " + "or server.")
                }
            }
        }
        "production" !== "production" ? invariant(container.nodeType !== DOC_NODE_TYPE, "You're trying to render a component to the document but " + "you didn't use server rendering. We can't do this " + "without using server rendering due to cross-browser quirks. " + "See renderComponentToString() for server rendering.") : invariant(container.nodeType !== DOC_NODE_TYPE);
        setInnerHTML(container, markup)
    })};
    module.exports = ReactComponentBrowserEnvironment
}, {"./ReactDOMIDOperations": 108, "./ReactMarkupChecksum": 129, "./ReactMount": 130, "./ReactPerf": 135, "./ReactReconcileTransaction": 141, "./getReactRootElementInContainer": 187, "./invariant": 193, "./setInnerHTML": 207}], 101: [function (require, module, exports) {
    "use strict";
    var ReactComponent = require("./ReactComponent");
    var ReactContext = require("./ReactContext");
    var ReactCurrentOwner = require("./ReactCurrentOwner");
    var ReactElement = require("./ReactElement");
    var ReactElementValidator = require("./ReactElementValidator");
    var ReactEmptyComponent = require("./ReactEmptyComponent");
    var ReactErrorUtils = require("./ReactErrorUtils");
    var ReactLegacyElement = require("./ReactLegacyElement");
    var ReactOwner = require("./ReactOwner");
    var ReactPerf = require("./ReactPerf");
    var ReactPropTransferer = require("./ReactPropTransferer");
    var ReactPropTypeLocations = require("./ReactPropTypeLocations");
    var ReactPropTypeLocationNames = require("./ReactPropTypeLocationNames");
    var ReactUpdates = require("./ReactUpdates");
    var assign = require("./Object.assign");
    var instantiateReactComponent = require("./instantiateReactComponent");
    var invariant = require("./invariant");
    var keyMirror = require("./keyMirror");
    var keyOf = require("./keyOf");
    var monitorCodeUse = require("./monitorCodeUse");
    var mapObject = require("./mapObject");
    var shouldUpdateReactComponent = require("./shouldUpdateReactComponent");
    var warning = require("./warning");
    var MIXINS_KEY = keyOf({mixins: null});
    var SpecPolicy = keyMirror({DEFINE_ONCE: null, DEFINE_MANY: null, OVERRIDE_BASE: null, DEFINE_MANY_MERGED: null});
    var injectedMixins = [];
    var ReactCompositeComponentInterface = {mixins: SpecPolicy.DEFINE_MANY, statics: SpecPolicy.DEFINE_MANY, propTypes: SpecPolicy.DEFINE_MANY, contextTypes: SpecPolicy.DEFINE_MANY, childContextTypes: SpecPolicy.DEFINE_MANY, getDefaultProps: SpecPolicy.DEFINE_MANY_MERGED, getInitialState: SpecPolicy.DEFINE_MANY_MERGED, getChildContext: SpecPolicy.DEFINE_MANY_MERGED, render: SpecPolicy.DEFINE_ONCE, componentWillMount: SpecPolicy.DEFINE_MANY, componentDidMount: SpecPolicy.DEFINE_MANY, componentWillReceiveProps: SpecPolicy.DEFINE_MANY, shouldComponentUpdate: SpecPolicy.DEFINE_ONCE, componentWillUpdate: SpecPolicy.DEFINE_MANY, componentDidUpdate: SpecPolicy.DEFINE_MANY, componentWillUnmount: SpecPolicy.DEFINE_MANY, updateComponent: SpecPolicy.OVERRIDE_BASE};
    var RESERVED_SPEC_KEYS = {displayName: function (Constructor, displayName) {
        Constructor.displayName = displayName
    }, mixins: function (Constructor, mixins) {
        if (mixins) {
            for (var i = 0; i < mixins.length; i++) {
                mixSpecIntoComponent(Constructor, mixins[i])
            }
        }
    }, childContextTypes: function (Constructor, childContextTypes) {
        validateTypeDef(Constructor, childContextTypes, ReactPropTypeLocations.childContext);
        Constructor.childContextTypes = assign({}, Constructor.childContextTypes, childContextTypes)
    }, contextTypes: function (Constructor, contextTypes) {
        validateTypeDef(Constructor, contextTypes, ReactPropTypeLocations.context);
        Constructor.contextTypes = assign({}, Constructor.contextTypes, contextTypes)
    }, getDefaultProps: function (Constructor, getDefaultProps) {
        if (Constructor.getDefaultProps) {
            Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, getDefaultProps)
        } else {
            Constructor.getDefaultProps = getDefaultProps
        }
    }, propTypes: function (Constructor, propTypes) {
        validateTypeDef(Constructor, propTypes, ReactPropTypeLocations.prop);
        Constructor.propTypes = assign({}, Constructor.propTypes, propTypes)
    }, statics: function (Constructor, statics) {
        mixStaticSpecIntoComponent(Constructor, statics)
    }};

    function getDeclarationErrorAddendum(component) {
        var owner = component._owner || null;
        if (owner && owner.constructor && owner.constructor.displayName) {
            return" Check the render method of `" + owner.constructor.displayName + "`."
        }
        return""
    }

    function validateTypeDef(Constructor, typeDef, location) {
        for (var propName in typeDef) {
            if (typeDef.hasOwnProperty(propName)) {
                "production" !== "production" ? invariant(typeof typeDef[propName] == "function", "%s: %s type `%s` is invalid; it must be a function, usually from " + "React.PropTypes.", Constructor.displayName || "ReactCompositeComponent", ReactPropTypeLocationNames[location], propName) : invariant(typeof typeDef[propName] == "function")
            }
        }
    }

    function validateMethodOverride(proto, name) {
        var specPolicy = ReactCompositeComponentInterface.hasOwnProperty(name) ? ReactCompositeComponentInterface[name] : null;
        if (ReactCompositeComponentMixin.hasOwnProperty(name)) {
            "production" !== "production" ? invariant(specPolicy === SpecPolicy.OVERRIDE_BASE, "ReactCompositeComponentInterface: You are attempting to override " + "`%s` from your class specification. Ensure that your method names " + "do not overlap with React methods.", name) : invariant(specPolicy === SpecPolicy.OVERRIDE_BASE)
        }
        if (proto.hasOwnProperty(name)) {
            "production" !== "production" ? invariant(specPolicy === SpecPolicy.DEFINE_MANY || specPolicy === SpecPolicy.DEFINE_MANY_MERGED, "ReactCompositeComponentInterface: You are attempting to define " + "`%s` on your component more than once. This conflict may be due " + "to a mixin.", name) : invariant(specPolicy === SpecPolicy.DEFINE_MANY || specPolicy === SpecPolicy.DEFINE_MANY_MERGED)
        }
    }

    function validateLifeCycleOnReplaceState(instance) {
        var compositeLifeCycleState = instance._compositeLifeCycleState;
        "production" !== "production" ? invariant(instance.isMounted() || compositeLifeCycleState === CompositeLifeCycle.MOUNTING, "replaceState(...): Can only update a mounted or mounting component.") : invariant(instance.isMounted() || compositeLifeCycleState === CompositeLifeCycle.MOUNTING);
        "production" !== "production" ? invariant(ReactCurrentOwner.current == null, "replaceState(...): Cannot update during an existing state transition " + "(such as within `render`). Render methods should be a pure function " + "of props and state.") : invariant(ReactCurrentOwner.current == null);
        "production" !== "production" ? invariant(compositeLifeCycleState !== CompositeLifeCycle.UNMOUNTING, "replaceState(...): Cannot update while unmounting component. This " + "usually means you called setState() on an unmounted component.") : invariant(compositeLifeCycleState !== CompositeLifeCycle.UNMOUNTING)
    }

    function mixSpecIntoComponent(Constructor, spec) {
        if (!spec) {
            return
        }
        "production" !== "production" ? invariant(!ReactLegacyElement.isValidFactory(spec), "ReactCompositeComponent: You're attempting to " + "use a component class as a mixin. Instead, just use a regular object.") : invariant(!ReactLegacyElement.isValidFactory(spec));
        "production" !== "production" ? invariant(!ReactElement.isValidElement(spec), "ReactCompositeComponent: You're attempting to " + "use a component as a mixin. Instead, just use a regular object.") : invariant(!ReactElement.isValidElement(spec));
        var proto = Constructor.prototype;
        if (spec.hasOwnProperty(MIXINS_KEY)) {
            RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins)
        }
        for (var name in spec) {
            if (!spec.hasOwnProperty(name)) {
                continue
            }
            if (name === MIXINS_KEY) {
                continue
            }
            var property = spec[name];
            validateMethodOverride(proto, name);
            if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
                RESERVED_SPEC_KEYS[name](Constructor, property)
            } else {
                var isCompositeComponentMethod = ReactCompositeComponentInterface.hasOwnProperty(name);
                var isAlreadyDefined = proto.hasOwnProperty(name);
                var markedDontBind = property && property.__reactDontBind;
                var isFunction = typeof property === "function";
                var shouldAutoBind = isFunction && !isCompositeComponentMethod && !isAlreadyDefined && !markedDontBind;
                if (shouldAutoBind) {
                    if (!proto.__reactAutoBindMap) {
                        proto.__reactAutoBindMap = {}
                    }
                    proto.__reactAutoBindMap[name] = property;
                    proto[name] = property
                } else {
                    if (isAlreadyDefined) {
                        var specPolicy = ReactCompositeComponentInterface[name];
                        "production" !== "production" ? invariant(isCompositeComponentMethod && (specPolicy === SpecPolicy.DEFINE_MANY_MERGED || specPolicy === SpecPolicy.DEFINE_MANY), "ReactCompositeComponent: Unexpected spec policy %s for key %s " + "when mixing in component specs.", specPolicy, name) : invariant(isCompositeComponentMethod && (specPolicy === SpecPolicy.DEFINE_MANY_MERGED || specPolicy === SpecPolicy.DEFINE_MANY));
                        if (specPolicy === SpecPolicy.DEFINE_MANY_MERGED) {
                            proto[name] = createMergedResultFunction(proto[name], property)
                        } else if (specPolicy === SpecPolicy.DEFINE_MANY) {
                            proto[name] = createChainedFunction(proto[name], property)
                        }
                    } else {
                        proto[name] = property;
                        if ("production" !== "production") {
                            if (typeof property === "function" && spec.displayName) {
                                proto[name].displayName = spec.displayName + "_" + name
                            }
                        }
                    }
                }
            }
        }
    }

    function mixStaticSpecIntoComponent(Constructor, statics) {
        if (!statics) {
            return
        }
        for (var name in statics) {
            var property = statics[name];
            if (!statics.hasOwnProperty(name)) {
                continue
            }
            var isReserved = name in RESERVED_SPEC_KEYS;
            "production" !== "production" ? invariant(!isReserved, "ReactCompositeComponent: You are attempting to define a reserved " + 'property, `%s`, that shouldn\'t be on the "statics" key. Define it ' + "as an instance property instead; it will still be accessible on the " + "constructor.", name) : invariant(!isReserved);
            var isInherited = name in Constructor;
            "production" !== "production" ? invariant(!isInherited, "ReactCompositeComponent: You are attempting to define " + "`%s` on your component more than once. This conflict may be " + "due to a mixin.", name) : invariant(!isInherited);
            Constructor[name] = property
        }
    }

    function mergeObjectsWithNoDuplicateKeys(one, two) {
        "production" !== "production" ? invariant(one && two && typeof one === "object" && typeof two === "object", "mergeObjectsWithNoDuplicateKeys(): Cannot merge non-objects") : invariant(one && two && typeof one === "object" && typeof two === "object");
        mapObject(two, function (value, key) {
            "production" !== "production" ? invariant(one[key] === undefined, "mergeObjectsWithNoDuplicateKeys(): " + "Tried to merge two objects with the same key: `%s`. This conflict " + "may be due to a mixin; in particular, this may be caused by two " + "getInitialState() or getDefaultProps() methods returning objects " + "with clashing keys.", key) : invariant(one[key] === undefined);
            one[key] = value
        });
        return one
    }

    function createMergedResultFunction(one, two) {
        return function mergedResult() {
            var a = one.apply(this, arguments);
            var b = two.apply(this, arguments);
            if (a == null) {
                return b
            } else if (b == null) {
                return a
            }
            return mergeObjectsWithNoDuplicateKeys(a, b)
        }
    }

    function createChainedFunction(one, two) {
        return function chainedFunction() {
            one.apply(this, arguments);
            two.apply(this, arguments)
        }
    }

    var CompositeLifeCycle = keyMirror({MOUNTING: null, UNMOUNTING: null, RECEIVING_PROPS: null});
    var ReactCompositeComponentMixin = {construct: function (element) {
        ReactComponent.Mixin.construct.apply(this, arguments);
        ReactOwner.Mixin.construct.apply(this, arguments);
        this.state = null;
        this._pendingState = null;
        this.context = null;
        this._compositeLifeCycleState = null
    }, isMounted: function () {
        return ReactComponent.Mixin.isMounted.call(this) && this._compositeLifeCycleState !== CompositeLifeCycle.MOUNTING
    }, mountComponent: ReactPerf.measure("ReactCompositeComponent", "mountComponent", function (rootID, transaction, mountDepth) {
        ReactComponent.Mixin.mountComponent.call(this, rootID, transaction, mountDepth);
        this._compositeLifeCycleState = CompositeLifeCycle.MOUNTING;
        if (this.__reactAutoBindMap) {
            this._bindAutoBindMethods()
        }
        this.context = this._processContext(this._currentElement._context);
        this.props = this._processProps(this.props);
        this.state = this.getInitialState ? this.getInitialState() : null;
        "production" !== "production" ? invariant(typeof this.state === "object" && !Array.isArray(this.state), "%s.getInitialState(): must return an object or null", this.constructor.displayName || "ReactCompositeComponent") : invariant(typeof this.state === "object" && !Array.isArray(this.state));
        this._pendingState = null;
        this._pendingForceUpdate = false;
        if (this.componentWillMount) {
            this.componentWillMount();
            if (this._pendingState) {
                this.state = this._pendingState;
                this._pendingState = null
            }
        }
        this._renderedComponent = instantiateReactComponent(this._renderValidatedComponent(), this._currentElement.type);
        this._compositeLifeCycleState = null;
        var markup = this._renderedComponent.mountComponent(rootID, transaction, mountDepth + 1);
        if (this.componentDidMount) {
            transaction.getReactMountReady().enqueue(this.componentDidMount, this)
        }
        return markup
    }), unmountComponent: function () {
        this._compositeLifeCycleState = CompositeLifeCycle.UNMOUNTING;
        if (this.componentWillUnmount) {
            this.componentWillUnmount()
        }
        this._compositeLifeCycleState = null;
        this._renderedComponent.unmountComponent();
        this._renderedComponent = null;
        ReactComponent.Mixin.unmountComponent.call(this)
    }, setState: function (partialState, callback) {
        "production" !== "production" ? invariant(typeof partialState === "object" || partialState == null, "setState(...): takes an object of state variables to update.") : invariant(typeof partialState === "object" || partialState == null);
        if ("production" !== "production") {
            "production" !== "production" ? warning(partialState != null, "setState(...): You passed an undefined or null state object; " + "instead, use forceUpdate().") : null
        }
        this.replaceState(assign({}, this._pendingState || this.state, partialState), callback)
    }, replaceState: function (completeState, callback) {
        validateLifeCycleOnReplaceState(this);
        this._pendingState = completeState;
        if (this._compositeLifeCycleState !== CompositeLifeCycle.MOUNTING) {
            ReactUpdates.enqueueUpdate(this, callback)
        }
    }, _processContext: function (context) {
        var maskedContext = null;
        var contextTypes = this.constructor.contextTypes;
        if (contextTypes) {
            maskedContext = {};
            for (var contextName in contextTypes) {
                maskedContext[contextName] = context[contextName]
            }
            if ("production" !== "production") {
                this._checkPropTypes(contextTypes, maskedContext, ReactPropTypeLocations.context)
            }
        }
        return maskedContext
    }, _processChildContext: function (currentContext) {
        var childContext = this.getChildContext && this.getChildContext();
        var displayName = this.constructor.displayName || "ReactCompositeComponent";
        if (childContext) {
            "production" !== "production" ? invariant(typeof this.constructor.childContextTypes === "object", "%s.getChildContext(): childContextTypes must be defined in order to " + "use getChildContext().", displayName) : invariant(typeof this.constructor.childContextTypes === "object");
            if ("production" !== "production") {
                this._checkPropTypes(this.constructor.childContextTypes, childContext, ReactPropTypeLocations.childContext)
            }
            for (var name in childContext) {
                "production" !== "production" ? invariant(name in this.constructor.childContextTypes, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', displayName, name) : invariant(name in this.constructor.childContextTypes)
            }
            return assign({}, currentContext, childContext)
        }
        return currentContext
    }, _processProps: function (newProps) {
        if ("production" !== "production") {
            var propTypes = this.constructor.propTypes;
            if (propTypes) {
                this._checkPropTypes(propTypes, newProps, ReactPropTypeLocations.prop)
            }
        }
        return newProps
    }, _checkPropTypes: function (propTypes, props, location) {
        var componentName = this.constructor.displayName;
        for (var propName in propTypes) {
            if (propTypes.hasOwnProperty(propName)) {
                var error = propTypes[propName](props, propName, componentName, location);
                if (error instanceof Error) {
                    var addendum = getDeclarationErrorAddendum(this);
                    "production" !== "production" ? warning(false, error.message + addendum) : null
                }
            }
        }
    }, performUpdateIfNecessary: function (transaction) {
        var compositeLifeCycleState = this._compositeLifeCycleState;
        if (compositeLifeCycleState === CompositeLifeCycle.MOUNTING || compositeLifeCycleState === CompositeLifeCycle.RECEIVING_PROPS) {
            return
        }
        if (this._pendingElement == null && this._pendingState == null && !this._pendingForceUpdate) {
            return
        }
        var nextContext = this.context;
        var nextProps = this.props;
        var nextElement = this._currentElement;
        if (this._pendingElement != null) {
            nextElement = this._pendingElement;
            nextContext = this._processContext(nextElement._context);
            nextProps = this._processProps(nextElement.props);
            this._pendingElement = null;
            this._compositeLifeCycleState = CompositeLifeCycle.RECEIVING_PROPS;
            if (this.componentWillReceiveProps) {
                this.componentWillReceiveProps(nextProps, nextContext)
            }
        }
        this._compositeLifeCycleState = null;
        var nextState = this._pendingState || this.state;
        this._pendingState = null;
        var shouldUpdate = this._pendingForceUpdate || !this.shouldComponentUpdate || this.shouldComponentUpdate(nextProps, nextState, nextContext);
        if ("production" !== "production") {
            if (typeof shouldUpdate === "undefined") {
                console.warn((this.constructor.displayName || "ReactCompositeComponent") + ".shouldComponentUpdate(): Returned undefined instead of a " + "boolean value. Make sure to return true or false.")
            }
        }
        if (shouldUpdate) {
            this._pendingForceUpdate = false;
            this._performComponentUpdate(nextElement, nextProps, nextState, nextContext, transaction)
        } else {
            this._currentElement = nextElement;
            this.props = nextProps;
            this.state = nextState;
            this.context = nextContext;
            this._owner = nextElement._owner
        }
    }, _performComponentUpdate: function (nextElement, nextProps, nextState, nextContext, transaction) {
        var prevElement = this._currentElement;
        var prevProps = this.props;
        var prevState = this.state;
        var prevContext = this.context;
        if (this.componentWillUpdate) {
            this.componentWillUpdate(nextProps, nextState, nextContext)
        }
        this._currentElement = nextElement;
        this.props = nextProps;
        this.state = nextState;
        this.context = nextContext;
        this._owner = nextElement._owner;
        this.updateComponent(transaction, prevElement);
        if (this.componentDidUpdate) {
            transaction.getReactMountReady().enqueue(this.componentDidUpdate.bind(this, prevProps, prevState, prevContext), this)
        }
    }, receiveComponent: function (nextElement, transaction) {
        if (nextElement === this._currentElement && nextElement._owner != null) {
            return
        }
        ReactComponent.Mixin.receiveComponent.call(this, nextElement, transaction)
    }, updateComponent: ReactPerf.measure("ReactCompositeComponent", "updateComponent", function (transaction, prevParentElement) {
        ReactComponent.Mixin.updateComponent.call(this, transaction, prevParentElement);
        var prevComponentInstance = this._renderedComponent;
        var prevElement = prevComponentInstance._currentElement;
        var nextElement = this._renderValidatedComponent();
        if (shouldUpdateReactComponent(prevElement, nextElement)) {
            prevComponentInstance.receiveComponent(nextElement, transaction)
        } else {
            var thisID = this._rootNodeID;
            var prevComponentID = prevComponentInstance._rootNodeID;
            prevComponentInstance.unmountComponent();
            this._renderedComponent = instantiateReactComponent(nextElement, this._currentElement.type);
            var nextMarkup = this._renderedComponent.mountComponent(thisID, transaction, this._mountDepth + 1);
            ReactComponent.BackendIDOperations.dangerouslyReplaceNodeWithMarkupByID(prevComponentID, nextMarkup)
        }
    }), forceUpdate: function (callback) {
        var compositeLifeCycleState = this._compositeLifeCycleState;
        "production" !== "production" ? invariant(this.isMounted() || compositeLifeCycleState === CompositeLifeCycle.MOUNTING, "forceUpdate(...): Can only force an update on mounted or mounting " + "components.") : invariant(this.isMounted() || compositeLifeCycleState === CompositeLifeCycle.MOUNTING);
        "production" !== "production" ? invariant(compositeLifeCycleState !== CompositeLifeCycle.UNMOUNTING && ReactCurrentOwner.current == null, "forceUpdate(...): Cannot force an update while unmounting component " + "or within a `render` function.") : invariant(compositeLifeCycleState !== CompositeLifeCycle.UNMOUNTING && ReactCurrentOwner.current == null);
        this._pendingForceUpdate = true;
        ReactUpdates.enqueueUpdate(this, callback)
    }, _renderValidatedComponent: ReactPerf.measure("ReactCompositeComponent", "_renderValidatedComponent", function () {
        var renderedComponent;
        var previousContext = ReactContext.current;
        ReactContext.current = this._processChildContext(this._currentElement._context);
        ReactCurrentOwner.current = this;
        try {
            renderedComponent = this.render();
            if (renderedComponent === null || renderedComponent === false) {
                renderedComponent = ReactEmptyComponent.getEmptyComponent();
                ReactEmptyComponent.registerNullComponentID(this._rootNodeID)
            } else {
                ReactEmptyComponent.deregisterNullComponentID(this._rootNodeID)
            }
        } finally {
            ReactContext.current = previousContext;
            ReactCurrentOwner.current = null
        }
        "production" !== "production" ? invariant(ReactElement.isValidElement(renderedComponent), "%s.render(): A valid ReactComponent must be returned. You may have " + "returned undefined, an array or some other invalid object.", this.constructor.displayName || "ReactCompositeComponent") : invariant(ReactElement.isValidElement(renderedComponent));
        return renderedComponent
    }), _bindAutoBindMethods: function () {
        for (var autoBindKey in this.__reactAutoBindMap) {
            if (!this.__reactAutoBindMap.hasOwnProperty(autoBindKey)) {
                continue
            }
            var method = this.__reactAutoBindMap[autoBindKey];
            this[autoBindKey] = this._bindAutoBindMethod(ReactErrorUtils.guard(method, this.constructor.displayName + "." + autoBindKey))
        }
    }, _bindAutoBindMethod: function (method) {
        var component = this;
        var boundMethod = method.bind(component);
        if ("production" !== "production") {
            boundMethod.__reactBoundContext = component;
            boundMethod.__reactBoundMethod = method;
            boundMethod.__reactBoundArguments = null;
            var componentName = component.constructor.displayName;
            var _bind = boundMethod.bind;
            boundMethod.bind = function (newThis) {
                for (var args = [], $__0 = 1, $__1 = arguments.length; $__0 < $__1; $__0++)args.push(arguments[$__0]);
                if (newThis !== component && newThis !== null) {
                    monitorCodeUse("react_bind_warning", {component: componentName});
                    console.warn("bind(): React component methods may only be bound to the " + "component instance. See " + componentName)
                } else if (!args.length) {
                    monitorCodeUse("react_bind_warning", {component: componentName});
                    console.warn("bind(): You are binding a component method to the component. " + "React does this for you automatically in a high-performance " + "way, so you can safely remove this call. See " + componentName);
                    return boundMethod
                }
                var reboundMethod = _bind.apply(boundMethod, arguments);
                reboundMethod.__reactBoundContext = component;
                reboundMethod.__reactBoundMethod = method;
                reboundMethod.__reactBoundArguments = args;
                return reboundMethod
            }
        }
        return boundMethod
    }};
    var ReactCompositeComponentBase = function () {
    };
    assign(ReactCompositeComponentBase.prototype, ReactComponent.Mixin, ReactOwner.Mixin, ReactPropTransferer.Mixin, ReactCompositeComponentMixin);
    var ReactCompositeComponent = {LifeCycle: CompositeLifeCycle, Base: ReactCompositeComponentBase, createClass: function (spec) {
        var Constructor = function (props) {
        };
        Constructor.prototype = new ReactCompositeComponentBase;
        Constructor.prototype.constructor = Constructor;
        injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));
        mixSpecIntoComponent(Constructor, spec);
        if (Constructor.getDefaultProps) {
            Constructor.defaultProps = Constructor.getDefaultProps()
        }
        "production" !== "production" ? invariant(Constructor.prototype.render, "createClass(...): Class specification must implement a `render` method.") : invariant(Constructor.prototype.render);
        if ("production" !== "production") {
            if (Constructor.prototype.componentShouldUpdate) {
                monitorCodeUse("react_component_should_update_warning", {component: spec.displayName});
                console.warn((spec.displayName || "A component") + " has a method called " + "componentShouldUpdate(). Did you mean shouldComponentUpdate()? " + "The name is phrased as a question because the function is " + "expected to return a value.")
            }
        }
        for (var methodName in ReactCompositeComponentInterface) {
            if (!Constructor.prototype[methodName]) {
                Constructor.prototype[methodName] = null
            }
        }
        if ("production" !== "production") {
            return ReactLegacyElement.wrapFactory(ReactElementValidator.createFactory(Constructor))
        }
        return ReactLegacyElement.wrapFactory(ReactElement.createFactory(Constructor))
    }, injection: {injectMixin: function (mixin) {
        injectedMixins.push(mixin)
    }}};
    module.exports = ReactCompositeComponent
}, {"./Object.assign": 93, "./ReactComponent": 99, "./ReactContext": 102, "./ReactCurrentOwner": 103, "./ReactElement": 119, "./ReactElementValidator": 120, "./ReactEmptyComponent": 121, "./ReactErrorUtils": 122, "./ReactLegacyElement": 128, "./ReactOwner": 134, "./ReactPerf": 135, "./ReactPropTransferer": 136, "./ReactPropTypeLocationNames": 137, "./ReactPropTypeLocations": 138, "./ReactUpdates": 146, "./instantiateReactComponent": 192, "./invariant": 193, "./keyMirror": 199, "./keyOf": 200, "./mapObject": 201, "./monitorCodeUse": 203, "./shouldUpdateReactComponent": 209, "./warning": 212}], 102: [function (require, module, exports) {
    "use strict";
    var assign = require("./Object.assign");
    var ReactContext = {current: {}, withContext: function (newContext, scopedCallback) {
        var result;
        var previousContext = ReactContext.current;
        ReactContext.current = assign({}, previousContext, newContext);
        try {
            result = scopedCallback()
        } finally {
            ReactContext.current = previousContext
        }
        return result
    }};
    module.exports = ReactContext
}, {"./Object.assign": 93}], 103: [function (require, module, exports) {
    "use strict";
    var ReactCurrentOwner = {current: null};
    module.exports = ReactCurrentOwner
}, {}], 104: [function (require, module, exports) {
    "use strict";
    var ReactElement = require("./ReactElement");
    var ReactElementValidator = require("./ReactElementValidator");
    var ReactLegacyElement = require("./ReactLegacyElement");
    var mapObject = require("./mapObject");

    function createDOMFactory(tag) {
        if ("production" !== "production") {
            return ReactLegacyElement.markNonLegacyFactory(ReactElementValidator.createFactory(tag))
        }
        return ReactLegacyElement.markNonLegacyFactory(ReactElement.createFactory(tag))
    }

    var ReactDOM = mapObject({a: "a", abbr: "abbr", address: "address", area: "area", article: "article", aside: "aside", audio: "audio", b: "b", base: "base", bdi: "bdi", bdo: "bdo", big: "big", blockquote: "blockquote", body: "body", br: "br", button: "button", canvas: "canvas", caption: "caption", cite: "cite", code: "code", col: "col", colgroup: "colgroup", data: "data", datalist: "datalist", dd: "dd", del: "del", details: "details", dfn: "dfn", dialog: "dialog", div: "div", dl: "dl", dt: "dt", em: "em", embed: "embed", fieldset: "fieldset", figcaption: "figcaption", figure: "figure", footer: "footer", form: "form", h1: "h1", h2: "h2", h3: "h3", h4: "h4", h5: "h5", h6: "h6", head: "head", header: "header", hr: "hr", html: "html", i: "i", iframe: "iframe", img: "img", input: "input", ins: "ins", kbd: "kbd", keygen: "keygen", label: "label", legend: "legend", li: "li", link: "link", main: "main", map: "map", mark: "mark", menu: "menu", menuitem: "menuitem", meta: "meta", meter: "meter", nav: "nav", noscript: "noscript", object: "object", ol: "ol", optgroup: "optgroup", option: "option", output: "output", p: "p", param: "param", picture: "picture", pre: "pre", progress: "progress", q: "q", rp: "rp", rt: "rt", ruby: "ruby", s: "s", samp: "samp", script: "script", section: "section", select: "select", small: "small", source: "source", span: "span", strong: "strong", style: "style", sub: "sub", summary: "summary", sup: "sup", table: "table", tbody: "tbody", td: "td", textarea: "textarea", tfoot: "tfoot", th: "th", thead: "thead", time: "time", title: "title", tr: "tr", track: "track", u: "u", ul: "ul", "var": "var", video: "video", wbr: "wbr", circle: "circle", defs: "defs", ellipse: "ellipse", g: "g", line: "line", linearGradient: "linearGradient", mask: "mask", path: "path", pattern: "pattern", polygon: "polygon", polyline: "polyline", radialGradient: "radialGradient", rect: "rect", stop: "stop", svg: "svg", text: "text", tspan: "tspan"}, createDOMFactory);
    module.exports = ReactDOM
}, {"./ReactElement": 119, "./ReactElementValidator": 120, "./ReactLegacyElement": 128, "./mapObject": 201}], 105: [function (require, module, exports) {
    "use strict";
    var AutoFocusMixin = require("./AutoFocusMixin");
    var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
    var ReactCompositeComponent = require("./ReactCompositeComponent");
    var ReactElement = require("./ReactElement");
    var ReactDOM = require("./ReactDOM");
    var keyMirror = require("./keyMirror");
    var button = ReactElement.createFactory(ReactDOM.button.type);
    var mouseListenerNames = keyMirror({onClick: true, onDoubleClick: true, onMouseDown: true, onMouseMove: true, onMouseUp: true, onClickCapture: true, onDoubleClickCapture: true, onMouseDownCapture: true, onMouseMoveCapture: true, onMouseUpCapture: true});
    var ReactDOMButton = ReactCompositeComponent.createClass({displayName: "ReactDOMButton", mixins: [AutoFocusMixin, ReactBrowserComponentMixin], render: function () {
        var props = {};
        for (var key in this.props) {
            if (this.props.hasOwnProperty(key) && (!this.props.disabled || !mouseListenerNames[key])) {
                props[key] = this.props[key]
            }
        }
        return button(props, this.props.children)
    }});
    module.exports = ReactDOMButton
}, {"./AutoFocusMixin": 68, "./ReactBrowserComponentMixin": 96, "./ReactCompositeComponent": 101, "./ReactDOM": 104, "./ReactElement": 119, "./keyMirror": 199}], 106: [function (require, module, exports) {
    "use strict";
    var CSSPropertyOperations = require("./CSSPropertyOperations");
    var DOMProperty = require("./DOMProperty");
    var DOMPropertyOperations = require("./DOMPropertyOperations");
    var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
    var ReactComponent = require("./ReactComponent");
    var ReactBrowserEventEmitter = require("./ReactBrowserEventEmitter");
    var ReactMount = require("./ReactMount");
    var ReactMultiChild = require("./ReactMultiChild");
    var ReactPerf = require("./ReactPerf");
    var assign = require("./Object.assign");
    var escapeTextForBrowser = require("./escapeTextForBrowser");
    var invariant = require("./invariant");
    var isEventSupported = require("./isEventSupported");
    var keyOf = require("./keyOf");
    var monitorCodeUse = require("./monitorCodeUse");
    var deleteListener = ReactBrowserEventEmitter.deleteListener;
    var listenTo = ReactBrowserEventEmitter.listenTo;
    var registrationNameModules = ReactBrowserEventEmitter.registrationNameModules;
    var CONTENT_TYPES = {string: true, number: true};
    var STYLE = keyOf({style: null});
    var ELEMENT_NODE_TYPE = 1;

    function assertValidProps(props) {
        if (!props) {
            return
        }
        "production" !== "production" ? invariant(props.children == null || props.dangerouslySetInnerHTML == null, "Can only set one of `children` or `props.dangerouslySetInnerHTML`.") : invariant(props.children == null || props.dangerouslySetInnerHTML == null);
        if ("production" !== "production") {
            if (props.contentEditable && props.children != null) {
                console.warn("A component is `contentEditable` and contains `children` managed by " + "React. It is now your responsibility to guarantee that none of those " + "nodes are unexpectedly modified or duplicated. This is probably not " + "intentional.")
            }
        }
        "production" !== "production" ? invariant(props.style == null || typeof props.style === "object", "The `style` prop expects a mapping from style properties to values, " + "not a string.") : invariant(props.style == null || typeof props.style === "object")
    }

    function putListener(id, registrationName, listener, transaction) {
        if ("production" !== "production") {
            if (registrationName === "onScroll" && !isEventSupported("scroll", true)) {
                monitorCodeUse("react_no_scroll_event");
                console.warn("This browser doesn't support the `onScroll` event")
            }
        }
        var container = ReactMount.findReactContainerForID(id);
        if (container) {
            var doc = container.nodeType === ELEMENT_NODE_TYPE ? container.ownerDocument : container;
            listenTo(registrationName, doc)
        }
        transaction.getPutListenerQueue().enqueuePutListener(id, registrationName, listener)
    }

    var omittedCloseTags = {area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true};
    var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/;
    var validatedTagCache = {};
    var hasOwnProperty = {}.hasOwnProperty;

    function validateDangerousTag(tag) {
        if (!hasOwnProperty.call(validatedTagCache, tag)) {
            "production" !== "production" ? invariant(VALID_TAG_REGEX.test(tag), "Invalid tag: %s", tag) : invariant(VALID_TAG_REGEX.test(tag));
            validatedTagCache[tag] = true
        }
    }

    function ReactDOMComponent(tag) {
        validateDangerousTag(tag);
        this._tag = tag;
        this.tagName = tag.toUpperCase()
    }

    ReactDOMComponent.displayName = "ReactDOMComponent";
    ReactDOMComponent.Mixin = {mountComponent: ReactPerf.measure("ReactDOMComponent", "mountComponent", function (rootID, transaction, mountDepth) {
        ReactComponent.Mixin.mountComponent.call(this, rootID, transaction, mountDepth);
        assertValidProps(this.props);
        var closeTag = omittedCloseTags[this._tag] ? "" : "</" + this._tag + ">";
        return this._createOpenTagMarkupAndPutListeners(transaction) + this._createContentMarkup(transaction) + closeTag
    }), _createOpenTagMarkupAndPutListeners: function (transaction) {
        var props = this.props;
        var ret = "<" + this._tag;
        for (var propKey in props) {
            if (!props.hasOwnProperty(propKey)) {
                continue
            }
            var propValue = props[propKey];
            if (propValue == null) {
                continue
            }
            if (registrationNameModules.hasOwnProperty(propKey)) {
                putListener(this._rootNodeID, propKey, propValue, transaction)
            } else {
                if (propKey === STYLE) {
                    if (propValue) {
                        propValue = props.style = assign({}, props.style)
                    }
                    propValue = CSSPropertyOperations.createMarkupForStyles(propValue)
                }
                var markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
                if (markup) {
                    ret += " " + markup
                }
            }
        }
        if (transaction.renderToStaticMarkup) {
            return ret + ">"
        }
        var markupForID = DOMPropertyOperations.createMarkupForID(this._rootNodeID);
        return ret + " " + markupForID + ">"
    }, _createContentMarkup: function (transaction) {
        var innerHTML = this.props.dangerouslySetInnerHTML;
        if (innerHTML != null) {
            if (innerHTML.__html != null) {
                return innerHTML.__html
            }
        } else {
            var contentToUse = CONTENT_TYPES[typeof this.props.children] ? this.props.children : null;
            var childrenToUse = contentToUse != null ? null : this.props.children;
            if (contentToUse != null) {
                return escapeTextForBrowser(contentToUse)
            } else if (childrenToUse != null) {
                var mountImages = this.mountChildren(childrenToUse, transaction);
                return mountImages.join("")
            }
        }
        return""
    }, receiveComponent: function (nextElement, transaction) {
        if (nextElement === this._currentElement && nextElement._owner != null) {
            return
        }
        ReactComponent.Mixin.receiveComponent.call(this, nextElement, transaction)
    }, updateComponent: ReactPerf.measure("ReactDOMComponent", "updateComponent", function (transaction, prevElement) {
        assertValidProps(this._currentElement.props);
        ReactComponent.Mixin.updateComponent.call(this, transaction, prevElement);
        this._updateDOMProperties(prevElement.props, transaction);
        this._updateDOMChildren(prevElement.props, transaction)
    }), _updateDOMProperties: function (lastProps, transaction) {
        var nextProps = this.props;
        var propKey;
        var styleName;
        var styleUpdates;
        for (propKey in lastProps) {
            if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey)) {
                continue
            }
            if (propKey === STYLE) {
                var lastStyle = lastProps[propKey];
                for (styleName in lastStyle) {
                    if (lastStyle.hasOwnProperty(styleName)) {
                        styleUpdates = styleUpdates || {};
                        styleUpdates[styleName] = ""
                    }
                }
            } else if (registrationNameModules.hasOwnProperty(propKey)) {
                deleteListener(this._rootNodeID, propKey)
            } else if (DOMProperty.isStandardName[propKey] || DOMProperty.isCustomAttribute(propKey)) {
                ReactComponent.BackendIDOperations.deletePropertyByID(this._rootNodeID, propKey)
            }
        }
        for (propKey in nextProps) {
            var nextProp = nextProps[propKey];
            var lastProp = lastProps[propKey];
            if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp) {
                continue
            }
            if (propKey === STYLE) {
                if (nextProp) {
                    nextProp = nextProps.style = assign({}, nextProp)
                }
                if (lastProp) {
                    for (styleName in lastProp) {
                        if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
                            styleUpdates = styleUpdates || {};
                            styleUpdates[styleName] = ""
                        }
                    }
                    for (styleName in nextProp) {
                        if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
                            styleUpdates = styleUpdates || {};
                            styleUpdates[styleName] = nextProp[styleName]
                        }
                    }
                } else {
                    styleUpdates = nextProp
                }
            } else if (registrationNameModules.hasOwnProperty(propKey)) {
                putListener(this._rootNodeID, propKey, nextProp, transaction)
            } else if (DOMProperty.isStandardName[propKey] || DOMProperty.isCustomAttribute(propKey)) {
                ReactComponent.BackendIDOperations.updatePropertyByID(this._rootNodeID, propKey, nextProp)
            }
        }
        if (styleUpdates) {
            ReactComponent.BackendIDOperations.updateStylesByID(this._rootNodeID, styleUpdates)
        }
    }, _updateDOMChildren: function (lastProps, transaction) {
        var nextProps = this.props;
        var lastContent = CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null;
        var nextContent = CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null;
        var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
        var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;
        var lastChildren = lastContent != null ? null : lastProps.children;
        var nextChildren = nextContent != null ? null : nextProps.children;
        var lastHasContentOrHtml = lastContent != null || lastHtml != null;
        var nextHasContentOrHtml = nextContent != null || nextHtml != null;
        if (lastChildren != null && nextChildren == null) {
            this.updateChildren(null, transaction)
        } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
            this.updateTextContent("")
        }
        if (nextContent != null) {
            if (lastContent !== nextContent) {
                this.updateTextContent("" + nextContent)
            }
        } else if (nextHtml != null) {
            if (lastHtml !== nextHtml) {
                ReactComponent.BackendIDOperations.updateInnerHTMLByID(this._rootNodeID, nextHtml)
            }
        } else if (nextChildren != null) {
            this.updateChildren(nextChildren, transaction)
        }
    }, unmountComponent: function () {
        this.unmountChildren();
        ReactBrowserEventEmitter.deleteAllListeners(this._rootNodeID);
        ReactComponent.Mixin.unmountComponent.call(this)
    }};
    assign(ReactDOMComponent.prototype, ReactComponent.Mixin, ReactDOMComponent.Mixin, ReactMultiChild.Mixin, ReactBrowserComponentMixin);
    module.exports = ReactDOMComponent
}, {"./CSSPropertyOperations": 71, "./DOMProperty": 77, "./DOMPropertyOperations": 78, "./Object.assign": 93, "./ReactBrowserComponentMixin": 96, "./ReactBrowserEventEmitter": 97, "./ReactComponent": 99, "./ReactMount": 130, "./ReactMultiChild": 131, "./ReactPerf": 135, "./escapeTextForBrowser": 176, "./invariant": 193, "./isEventSupported": 194, "./keyOf": 200, "./monitorCodeUse": 203}], 107: [function (require, module, exports) {
    "use strict";
    var EventConstants = require("./EventConstants");
    var LocalEventTrapMixin = require("./LocalEventTrapMixin");
    var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
    var ReactCompositeComponent = require("./ReactCompositeComponent");
    var ReactElement = require("./ReactElement");
    var ReactDOM = require("./ReactDOM");
    var form = ReactElement.createFactory(ReactDOM.form.type);
    var ReactDOMForm = ReactCompositeComponent.createClass({displayName: "ReactDOMForm", mixins: [ReactBrowserComponentMixin, LocalEventTrapMixin], render: function () {
        return form(this.props)
    }, componentDidMount: function () {
        this.trapBubbledEvent(EventConstants.topLevelTypes.topReset, "reset");
        this.trapBubbledEvent(EventConstants.topLevelTypes.topSubmit, "submit")
    }});
    module.exports = ReactDOMForm
}, {"./EventConstants": 82, "./LocalEventTrapMixin": 91, "./ReactBrowserComponentMixin": 96, "./ReactCompositeComponent": 101, "./ReactDOM": 104, "./ReactElement": 119}], 108: [function (require, module, exports) {
    "use strict";
    var CSSPropertyOperations = require("./CSSPropertyOperations");
    var DOMChildrenOperations = require("./DOMChildrenOperations");
    var DOMPropertyOperations = require("./DOMPropertyOperations");
    var ReactMount = require("./ReactMount");
    var ReactPerf = require("./ReactPerf");
    var invariant = require("./invariant");
    var setInnerHTML = require("./setInnerHTML");
    var INVALID_PROPERTY_ERRORS = {dangerouslySetInnerHTML: "`dangerouslySetInnerHTML` must be set using `updateInnerHTMLByID()`.", style: "`style` must be set using `updateStylesByID()`."};
    var ReactDOMIDOperations = {updatePropertyByID: ReactPerf.measure("ReactDOMIDOperations", "updatePropertyByID", function (id, name, value) {
        var node = ReactMount.getNode(id);
        "production" !== "production" ? invariant(!INVALID_PROPERTY_ERRORS.hasOwnProperty(name), "updatePropertyByID(...): %s", INVALID_PROPERTY_ERRORS[name]) : invariant(!INVALID_PROPERTY_ERRORS.hasOwnProperty(name));
        if (value != null) {
            DOMPropertyOperations.setValueForProperty(node, name, value)
        } else {
            DOMPropertyOperations.deleteValueForProperty(node, name)
        }
    }), deletePropertyByID: ReactPerf.measure("ReactDOMIDOperations", "deletePropertyByID", function (id, name, value) {
        var node = ReactMount.getNode(id);
        "production" !== "production" ? invariant(!INVALID_PROPERTY_ERRORS.hasOwnProperty(name), "updatePropertyByID(...): %s", INVALID_PROPERTY_ERRORS[name]) : invariant(!INVALID_PROPERTY_ERRORS.hasOwnProperty(name));
        DOMPropertyOperations.deleteValueForProperty(node, name, value)
    }), updateStylesByID: ReactPerf.measure("ReactDOMIDOperations", "updateStylesByID", function (id, styles) {
        var node = ReactMount.getNode(id);
        CSSPropertyOperations.setValueForStyles(node, styles)
    }), updateInnerHTMLByID: ReactPerf.measure("ReactDOMIDOperations", "updateInnerHTMLByID", function (id, html) {
        var node = ReactMount.getNode(id);
        setInnerHTML(node, html)
    }), updateTextContentByID: ReactPerf.measure("ReactDOMIDOperations", "updateTextContentByID", function (id, content) {
        var node = ReactMount.getNode(id);
        DOMChildrenOperations.updateTextContent(node, content)
    }), dangerouslyReplaceNodeWithMarkupByID: ReactPerf.measure("ReactDOMIDOperations", "dangerouslyReplaceNodeWithMarkupByID", function (id, markup) {
        var node = ReactMount.getNode(id);
        DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup(node, markup)
    }), dangerouslyProcessChildrenUpdates: ReactPerf.measure("ReactDOMIDOperations", "dangerouslyProcessChildrenUpdates", function (updates, markup) {
        for (var i = 0; i < updates.length; i++) {
            updates[i].parentNode = ReactMount.getNode(updates[i].parentID)
        }
        DOMChildrenOperations.processUpdates(updates, markup)
    })};
    module.exports = ReactDOMIDOperations
}, {"./CSSPropertyOperations": 71, "./DOMChildrenOperations": 76, "./DOMPropertyOperations": 78, "./ReactMount": 130, "./ReactPerf": 135, "./invariant": 193, "./setInnerHTML": 207}], 109: [function (require, module, exports) {
    "use strict";
    var EventConstants = require("./EventConstants");
    var LocalEventTrapMixin = require("./LocalEventTrapMixin");
    var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
    var ReactCompositeComponent = require("./ReactCompositeComponent");
    var ReactElement = require("./ReactElement");
    var ReactDOM = require("./ReactDOM");
    var img = ReactElement.createFactory(ReactDOM.img.type);
    var ReactDOMImg = ReactCompositeComponent.createClass({displayName: "ReactDOMImg", tagName: "IMG", mixins: [ReactBrowserComponentMixin, LocalEventTrapMixin], render: function () {
        return img(this.props)
    }, componentDidMount: function () {
        this.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, "load");
        this.trapBubbledEvent(EventConstants.topLevelTypes.topError, "error")
    }});
    module.exports = ReactDOMImg
}, {"./EventConstants": 82, "./LocalEventTrapMixin": 91, "./ReactBrowserComponentMixin": 96, "./ReactCompositeComponent": 101, "./ReactDOM": 104, "./ReactElement": 119}], 110: [function (require, module, exports) {
    "use strict";
    var AutoFocusMixin = require("./AutoFocusMixin");
    var DOMPropertyOperations = require("./DOMPropertyOperations");
    var LinkedValueUtils = require("./LinkedValueUtils");
    var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
    var ReactCompositeComponent = require("./ReactCompositeComponent");
    var ReactElement = require("./ReactElement");
    var ReactDOM = require("./ReactDOM");
    var ReactMount = require("./ReactMount");
    var ReactUpdates = require("./ReactUpdates");
    var assign = require("./Object.assign");
    var invariant = require("./invariant");
    var input = ReactElement.createFactory(ReactDOM.input.type);
    var instancesByReactID = {};

    function forceUpdateIfMounted() {
        if (this.isMounted()) {
            this.forceUpdate()
        }
    }

    var ReactDOMInput = ReactCompositeComponent.createClass({displayName: "ReactDOMInput", mixins: [AutoFocusMixin, LinkedValueUtils.Mixin, ReactBrowserComponentMixin], getInitialState: function () {
        var defaultValue = this.props.defaultValue;
        return{initialChecked: this.props.defaultChecked || false, initialValue: defaultValue != null ? defaultValue : null}
    }, render: function () {
        var props = assign({}, this.props);
        props.defaultChecked = null;
        props.defaultValue = null;
        var value = LinkedValueUtils.getValue(this);
        props.value = value != null ? value : this.state.initialValue;
        var checked = LinkedValueUtils.getChecked(this);
        props.checked = checked != null ? checked : this.state.initialChecked;
        props.onChange = this._handleChange;
        return input(props, this.props.children)
    }, componentDidMount: function () {
        var id = ReactMount.getID(this.getDOMNode());
        instancesByReactID[id] = this
    }, componentWillUnmount: function () {
        var rootNode = this.getDOMNode();
        var id = ReactMount.getID(rootNode);
        delete instancesByReactID[id]
    }, componentDidUpdate: function (prevProps, prevState, prevContext) {
        var rootNode = this.getDOMNode();
        if (this.props.checked != null) {
            DOMPropertyOperations.setValueForProperty(rootNode, "checked", this.props.checked || false)
        }
        var value = LinkedValueUtils.getValue(this);
        if (value != null) {
            DOMPropertyOperations.setValueForProperty(rootNode, "value", "" + value)
        }
    }, _handleChange: function (event) {
        var returnValue;
        var onChange = LinkedValueUtils.getOnChange(this);
        if (onChange) {
            returnValue = onChange.call(this, event)
        }
        ReactUpdates.asap(forceUpdateIfMounted, this);
        var name = this.props.name;
        if (this.props.type === "radio" && name != null) {
            var rootNode = this.getDOMNode();
            var queryRoot = rootNode;
            while (queryRoot.parentNode) {
                queryRoot = queryRoot.parentNode
            }
            var group = queryRoot.querySelectorAll("input[name=" + JSON.stringify("" + name) + '][type="radio"]');
            for (var i = 0, groupLen = group.length; i < groupLen; i++) {
                var otherNode = group[i];
                if (otherNode === rootNode || otherNode.form !== rootNode.form) {
                    continue
                }
                var otherID = ReactMount.getID(otherNode);
                "production" !== "production" ? invariant(otherID, "ReactDOMInput: Mixing React and non-React radio inputs with the " + "same `name` is not supported.") : invariant(otherID);
                var otherInstance = instancesByReactID[otherID];
                "production" !== "production" ? invariant(otherInstance, "ReactDOMInput: Unknown radio button ID %s.", otherID) : invariant(otherInstance);
                ReactUpdates.asap(forceUpdateIfMounted, otherInstance)
            }
        }
        return returnValue
    }});
    module.exports = ReactDOMInput
}, {"./AutoFocusMixin": 68, "./DOMPropertyOperations": 78, "./LinkedValueUtils": 90, "./Object.assign": 93, "./ReactBrowserComponentMixin": 96, "./ReactCompositeComponent": 101, "./ReactDOM": 104, "./ReactElement": 119, "./ReactMount": 130, "./ReactUpdates": 146, "./invariant": 193}], 111: [function (require, module, exports) {
    "use strict";
    var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
    var ReactCompositeComponent = require("./ReactCompositeComponent");
    var ReactElement = require("./ReactElement");
    var ReactDOM = require("./ReactDOM");
    var warning = require("./warning");
    var option = ReactElement.createFactory(ReactDOM.option.type);
    var ReactDOMOption = ReactCompositeComponent.createClass({displayName: "ReactDOMOption", mixins: [ReactBrowserComponentMixin], componentWillMount: function () {
        if ("production" !== "production") {
            "production" !== "production" ? warning(this.props.selected == null, "Use the `defaultValue` or `value` props on <select> instead of " + "setting `selected` on <option>.") : null
        }
    }, render: function () {
        return option(this.props, this.props.children)
    }});
    module.exports = ReactDOMOption
}, {"./ReactBrowserComponentMixin": 96, "./ReactCompositeComponent": 101, "./ReactDOM": 104, "./ReactElement": 119, "./warning": 212}], 112: [function (require, module, exports) {
    "use strict";
    var AutoFocusMixin = require("./AutoFocusMixin");
    var LinkedValueUtils = require("./LinkedValueUtils");
    var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
    var ReactCompositeComponent = require("./ReactCompositeComponent");
    var ReactElement = require("./ReactElement");
    var ReactDOM = require("./ReactDOM");
    var ReactUpdates = require("./ReactUpdates");
    var assign = require("./Object.assign");
    var select = ReactElement.createFactory(ReactDOM.select.type);

    function updateWithPendingValueIfMounted() {
        if (this.isMounted()) {
            this.setState({value: this._pendingValue});
            this._pendingValue = 0
        }
    }

    function selectValueType(props, propName, componentName) {
        if (props[propName] == null) {
            return
        }
        if (props.multiple) {
            if (!Array.isArray(props[propName])) {
                return new Error("The `" + propName + "` prop supplied to <select> must be an array if " + "`multiple` is true.")
            }
        } else {
            if (Array.isArray(props[propName])) {
                return new Error("The `" + propName + "` prop supplied to <select> must be a scalar " + "value if `multiple` is false.")
            }
        }
    }

    function updateOptions(component, propValue) {
        var multiple = component.props.multiple;
        var value = propValue != null ? propValue : component.state.value;
        var options = component.getDOMNode().options;
        var selectedValue, i, l;
        if (multiple) {
            selectedValue = {};
            for (i = 0, l = value.length; i < l; ++i) {
                selectedValue["" + value[i]] = true
            }
        } else {
            selectedValue = "" + value
        }
        for (i = 0, l = options.length; i < l; i++) {
            var selected = multiple ? selectedValue.hasOwnProperty(options[i].value) : options[i].value === selectedValue;
            if (selected !== options[i].selected) {
                options[i].selected = selected
            }
        }
    }

    var ReactDOMSelect = ReactCompositeComponent.createClass({displayName: "ReactDOMSelect", mixins: [AutoFocusMixin, LinkedValueUtils.Mixin, ReactBrowserComponentMixin], propTypes: {defaultValue: selectValueType, value: selectValueType}, getInitialState: function () {
        return{value: this.props.defaultValue || (this.props.multiple ? [] : "")}
    }, componentWillMount: function () {
        this._pendingValue = null
    }, componentWillReceiveProps: function (nextProps) {
        if (!this.props.multiple && nextProps.multiple) {
            this.setState({value: [this.state.value]})
        } else if (this.props.multiple && !nextProps.multiple) {
            this.setState({value: this.state.value[0]})
        }
    }, render: function () {
        var props = assign({}, this.props);
        props.onChange = this._handleChange;
        props.value = null;
        return select(props, this.props.children)
    }, componentDidMount: function () {
        updateOptions(this, LinkedValueUtils.getValue(this))
    }, componentDidUpdate: function (prevProps) {
        var value = LinkedValueUtils.getValue(this);
        var prevMultiple = !!prevProps.multiple;
        var multiple = !!this.props.multiple;
        if (value != null || prevMultiple !== multiple) {
            updateOptions(this, value)
        }
    }, _handleChange: function (event) {
        var returnValue;
        var onChange = LinkedValueUtils.getOnChange(this);
        if (onChange) {
            returnValue = onChange.call(this, event)
        }
        var selectedValue;
        if (this.props.multiple) {
            selectedValue = [];
            var options = event.target.options;
            for (var i = 0, l = options.length; i < l; i++) {
                if (options[i].selected) {
                    selectedValue.push(options[i].value)
                }
            }
        } else {
            selectedValue = event.target.value
        }
        this._pendingValue = selectedValue;
        ReactUpdates.asap(updateWithPendingValueIfMounted, this);
        return returnValue
    }});
    module.exports = ReactDOMSelect
}, {"./AutoFocusMixin": 68, "./LinkedValueUtils": 90, "./Object.assign": 93, "./ReactBrowserComponentMixin": 96, "./ReactCompositeComponent": 101, "./ReactDOM": 104, "./ReactElement": 119, "./ReactUpdates": 146}], 113: [function (require, module, exports) {
    "use strict";
    var ExecutionEnvironment = require("./ExecutionEnvironment");
    var getNodeForCharacterOffset = require("./getNodeForCharacterOffset");
    var getTextContentAccessor = require("./getTextContentAccessor");

    function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
        return anchorNode === focusNode && anchorOffset === focusOffset
    }

    function getIEOffsets(node) {
        var selection = document.selection;
        var selectedRange = selection.createRange();
        var selectedLength = selectedRange.text.length;
        var fromStart = selectedRange.duplicate();
        fromStart.moveToElementText(node);
        fromStart.setEndPoint("EndToStart", selectedRange);
        var startOffset = fromStart.text.length;
        var endOffset = startOffset + selectedLength;
        return{start: startOffset, end: endOffset}
    }

    function getModernOffsets(node) {
        var selection = window.getSelection && window.getSelection();
        if (!selection || selection.rangeCount === 0) {
            return null
        }
        var anchorNode = selection.anchorNode;
        var anchorOffset = selection.anchorOffset;
        var focusNode = selection.focusNode;
        var focusOffset = selection.focusOffset;
        var currentRange = selection.getRangeAt(0);
        var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);
        var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;
        var tempRange = currentRange.cloneRange();
        tempRange.selectNodeContents(node);
        tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);
        var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);
        var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
        var end = start + rangeLength;
        var detectionRange = document.createRange();
        detectionRange.setStart(anchorNode, anchorOffset);
        detectionRange.setEnd(focusNode, focusOffset);
        var isBackward = detectionRange.collapsed;
        return{start: isBackward ? end : start, end: isBackward ? start : end}
    }

    function setIEOffsets(node, offsets) {
        var range = document.selection.createRange().duplicate();
        var start, end;
        if (typeof offsets.end === "undefined") {
            start = offsets.start;
            end = start
        } else if (offsets.start > offsets.end) {
            start = offsets.end;
            end = offsets.start
        } else {
            start = offsets.start;
            end = offsets.end
        }
        range.moveToElementText(node);
        range.moveStart("character", start);
        range.setEndPoint("EndToStart", range);
        range.moveEnd("character", end - start);
        range.select()
    }

    function setModernOffsets(node, offsets) {
        if (!window.getSelection) {
            return
        }
        var selection = window.getSelection();
        var length = node[getTextContentAccessor()].length;
        var start = Math.min(offsets.start, length);
        var end = typeof offsets.end === "undefined" ? start : Math.min(offsets.end, length);
        if (!selection.extend && start > end) {
            var temp = end;
            end = start;
            start = temp
        }
        var startMarker = getNodeForCharacterOffset(node, start);
        var endMarker = getNodeForCharacterOffset(node, end);
        if (startMarker && endMarker) {
            var range = document.createRange();
            range.setStart(startMarker.node, startMarker.offset);
            selection.removeAllRanges();
            if (start > end) {
                selection.addRange(range);
                selection.extend(endMarker.node, endMarker.offset)
            } else {
                range.setEnd(endMarker.node, endMarker.offset);
                selection.addRange(range)
            }
        }
    }

    var useIEOffsets = ExecutionEnvironment.canUseDOM && document.selection;
    var ReactDOMSelection = {getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets, setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets};
    module.exports = ReactDOMSelection
}, {"./ExecutionEnvironment": 88, "./getNodeForCharacterOffset": 186, "./getTextContentAccessor": 188}], 114: [function (require, module, exports) {
    "use strict";
    var AutoFocusMixin = require("./AutoFocusMixin");
    var DOMPropertyOperations = require("./DOMPropertyOperations");
    var LinkedValueUtils = require("./LinkedValueUtils");
    var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
    var ReactCompositeComponent = require("./ReactCompositeComponent");
    var ReactElement = require("./ReactElement");
    var ReactDOM = require("./ReactDOM");
    var ReactUpdates = require("./ReactUpdates");
    var assign = require("./Object.assign");
    var invariant = require("./invariant");
    var warning = require("./warning");
    var textarea = ReactElement.createFactory(ReactDOM.textarea.type);

    function forceUpdateIfMounted() {
        if (this.isMounted()) {
            this.forceUpdate()
        }
    }

    var ReactDOMTextarea = ReactCompositeComponent.createClass({displayName: "ReactDOMTextarea", mixins: [AutoFocusMixin, LinkedValueUtils.Mixin, ReactBrowserComponentMixin], getInitialState: function () {
        var defaultValue = this.props.defaultValue;
        var children = this.props.children;
        if (children != null) {
            if ("production" !== "production") {
                "production" !== "production" ? warning(false, "Use the `defaultValue` or `value` props instead of setting " + "children on <textarea>.") : null
            }
            "production" !== "production" ? invariant(defaultValue == null, "If you supply `defaultValue` on a <textarea>, do not pass children.") : invariant(defaultValue == null);
            if (Array.isArray(children)) {
                "production" !== "production" ? invariant(children.length <= 1, "<textarea> can only have at most one child.") : invariant(children.length <= 1);
                children = children[0]
            }
            defaultValue = "" + children
        }
        if (defaultValue == null) {
            defaultValue = ""
        }
        var value = LinkedValueUtils.getValue(this);
        return{initialValue: "" + (value != null ? value : defaultValue)}
    }, render: function () {
        var props = assign({}, this.props);
        "production" !== "production" ? invariant(props.dangerouslySetInnerHTML == null, "`dangerouslySetInnerHTML` does not make sense on <textarea>.") : invariant(props.dangerouslySetInnerHTML == null);
        props.defaultValue = null;
        props.value = null;
        props.onChange = this._handleChange;
        return textarea(props, this.state.initialValue)
    }, componentDidUpdate: function (prevProps, prevState, prevContext) {
        var value = LinkedValueUtils.getValue(this);
        if (value != null) {
            var rootNode = this.getDOMNode();
            DOMPropertyOperations.setValueForProperty(rootNode, "value", "" + value)
        }
    }, _handleChange: function (event) {
        var returnValue;
        var onChange = LinkedValueUtils.getOnChange(this);
        if (onChange) {
            returnValue = onChange.call(this, event)
        }
        ReactUpdates.asap(forceUpdateIfMounted, this);
        return returnValue
    }});
    module.exports = ReactDOMTextarea
}, {"./AutoFocusMixin": 68, "./DOMPropertyOperations": 78, "./LinkedValueUtils": 90, "./Object.assign": 93, "./ReactBrowserComponentMixin": 96, "./ReactCompositeComponent": 101, "./ReactDOM": 104, "./ReactElement": 119, "./ReactUpdates": 146, "./invariant": 193, "./warning": 212}], 115: [function (require, module, exports) {
    "use strict";
    var ReactUpdates = require("./ReactUpdates");
    var Transaction = require("./Transaction");
    var assign = require("./Object.assign");
    var emptyFunction = require("./emptyFunction");
    var RESET_BATCHED_UPDATES = {initialize: emptyFunction, close: function () {
        ReactDefaultBatchingStrategy.isBatchingUpdates = false
    }};
    var FLUSH_BATCHED_UPDATES = {initialize: emptyFunction, close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)};
    var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];

    function ReactDefaultBatchingStrategyTransaction() {
        this.reinitializeTransaction()
    }

    assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction.Mixin, {getTransactionWrappers: function () {
        return TRANSACTION_WRAPPERS
    }});
    var transaction = new ReactDefaultBatchingStrategyTransaction;
    var ReactDefaultBatchingStrategy = {isBatchingUpdates: false, batchedUpdates: function (callback, a, b) {
        var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;
        ReactDefaultBatchingStrategy.isBatchingUpdates = true;
        if (alreadyBatchingUpdates) {
            callback(a, b)
        } else {
            transaction.perform(callback, null, a, b)
        }
    }};
    module.exports = ReactDefaultBatchingStrategy
}, {"./Object.assign": 93, "./ReactUpdates": 146, "./Transaction": 162, "./emptyFunction": 174}], 116: [function (require, module, exports) {
    "use strict";
    var BeforeInputEventPlugin = require("./BeforeInputEventPlugin");
    var ChangeEventPlugin = require("./ChangeEventPlugin");
    var ClientReactRootIndex = require("./ClientReactRootIndex");
    var CompositionEventPlugin = require("./CompositionEventPlugin");
    var DefaultEventPluginOrder = require("./DefaultEventPluginOrder");
    var EnterLeaveEventPlugin = require("./EnterLeaveEventPlugin");
    var ExecutionEnvironment = require("./ExecutionEnvironment");
    var HTMLDOMPropertyConfig = require("./HTMLDOMPropertyConfig");
    var MobileSafariClickEventPlugin = require("./MobileSafariClickEventPlugin");
    var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
    var ReactComponentBrowserEnvironment = require("./ReactComponentBrowserEnvironment");
    var ReactDefaultBatchingStrategy = require("./ReactDefaultBatchingStrategy");
    var ReactDOMComponent = require("./ReactDOMComponent");
    var ReactDOMButton = require("./ReactDOMButton");
    var ReactDOMForm = require("./ReactDOMForm");
    var ReactDOMImg = require("./ReactDOMImg");
    var ReactDOMInput = require("./ReactDOMInput");
    var ReactDOMOption = require("./ReactDOMOption");
    var ReactDOMSelect = require("./ReactDOMSelect");
    var ReactDOMTextarea = require("./ReactDOMTextarea");
    var ReactEventListener = require("./ReactEventListener");
    var ReactInjection = require("./ReactInjection");
    var ReactInstanceHandles = require("./ReactInstanceHandles");
    var ReactMount = require("./ReactMount");
    var SelectEventPlugin = require("./SelectEventPlugin");
    var ServerReactRootIndex = require("./ServerReactRootIndex");
    var SimpleEventPlugin = require("./SimpleEventPlugin");
    var SVGDOMPropertyConfig = require("./SVGDOMPropertyConfig");
    var createFullPageComponent = require("./createFullPageComponent");

    function inject() {
        ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);
        ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
        ReactInjection.EventPluginHub.injectInstanceHandle(ReactInstanceHandles);
        ReactInjection.EventPluginHub.injectMount(ReactMount);
        ReactInjection.EventPluginHub.injectEventPluginsByName({SimpleEventPlugin: SimpleEventPlugin, EnterLeaveEventPlugin: EnterLeaveEventPlugin, ChangeEventPlugin: ChangeEventPlugin, CompositionEventPlugin: CompositionEventPlugin, MobileSafariClickEventPlugin: MobileSafariClickEventPlugin, SelectEventPlugin: SelectEventPlugin, BeforeInputEventPlugin: BeforeInputEventPlugin});
        ReactInjection.NativeComponent.injectGenericComponentClass(ReactDOMComponent);
        ReactInjection.NativeComponent.injectComponentClasses({button: ReactDOMButton, form: ReactDOMForm, img: ReactDOMImg, input: ReactDOMInput, option: ReactDOMOption, select: ReactDOMSelect, textarea: ReactDOMTextarea, html: createFullPageComponent("html"), head: createFullPageComponent("head"), body: createFullPageComponent("body")});
        ReactInjection.CompositeComponent.injectMixin(ReactBrowserComponentMixin);
        ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
        ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);
        ReactInjection.EmptyComponent.injectEmptyComponent("noscript");
        ReactInjection.Updates.injectReconcileTransaction(ReactComponentBrowserEnvironment.ReactReconcileTransaction);
        ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);
        ReactInjection.RootIndex.injectCreateReactRootIndex(ExecutionEnvironment.canUseDOM ? ClientReactRootIndex.createReactRootIndex : ServerReactRootIndex.createReactRootIndex);
        ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);
        if ("production" !== "production") {
            var url = ExecutionEnvironment.canUseDOM && window.location.href || "";
            if (/[?&]react_perf\b/.test(url)) {
                var ReactDefaultPerf = require("./ReactDefaultPerf");
                ReactDefaultPerf.start()
            }
        }
    }

    module.exports = {inject: inject}
}, {"./BeforeInputEventPlugin": 69, "./ChangeEventPlugin": 73, "./ClientReactRootIndex": 74, "./CompositionEventPlugin": 75, "./DefaultEventPluginOrder": 80, "./EnterLeaveEventPlugin": 81, "./ExecutionEnvironment": 88, "./HTMLDOMPropertyConfig": 89, "./MobileSafariClickEventPlugin": 92, "./ReactBrowserComponentMixin": 96, "./ReactComponentBrowserEnvironment": 100, "./ReactDOMButton": 105, "./ReactDOMComponent": 106, "./ReactDOMForm": 107, "./ReactDOMImg": 109, "./ReactDOMInput": 110, "./ReactDOMOption": 111, "./ReactDOMSelect": 112, "./ReactDOMTextarea": 114, "./ReactDefaultBatchingStrategy": 115, "./ReactDefaultPerf": 117, "./ReactEventListener": 124, "./ReactInjection": 125, "./ReactInstanceHandles": 127, "./ReactMount": 130, "./SVGDOMPropertyConfig": 147, "./SelectEventPlugin": 148, "./ServerReactRootIndex": 149, "./SimpleEventPlugin": 150, "./createFullPageComponent": 170}], 117: [function (require, module, exports) {
    "use strict";
    var DOMProperty = require("./DOMProperty");
    var ReactDefaultPerfAnalysis = require("./ReactDefaultPerfAnalysis");
    var ReactMount = require("./ReactMount");
    var ReactPerf = require("./ReactPerf");
    var performanceNow = require("./performanceNow");

    function roundFloat(val) {
        return Math.floor(val * 100) / 100
    }

    function addValue(obj, key, val) {
        obj[key] = (obj[key] || 0) + val
    }

    var ReactDefaultPerf = {_allMeasurements: [], _mountStack: [0], _injected: false, start: function () {
        if (!ReactDefaultPerf._injected) {
            ReactPerf.injection.injectMeasure(ReactDefaultPerf.measure)
        }
        ReactDefaultPerf._allMeasurements.length = 0;
        ReactPerf.enableMeasure = true
    }, stop: function () {
        ReactPerf.enableMeasure = false
    }, getLastMeasurements: function () {
        return ReactDefaultPerf._allMeasurements
    }, printExclusive: function (measurements) {
        measurements = measurements || ReactDefaultPerf._allMeasurements;
        var summary = ReactDefaultPerfAnalysis.getExclusiveSummary(measurements);
        console.table(summary.map(function (item) {
            return{"Component class name": item.componentName, "Total inclusive time (ms)": roundFloat(item.inclusive), "Exclusive mount time (ms)": roundFloat(item.exclusive), "Exclusive render time (ms)": roundFloat(item.render), "Mount time per instance (ms)": roundFloat(item.exclusive / item.count), "Render time per instance (ms)": roundFloat(item.render / item.count), Instances: item.count}
        }))
    }, printInclusive: function (measurements) {
        measurements = measurements || ReactDefaultPerf._allMeasurements;
        var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(measurements);
        console.table(summary.map(function (item) {
            return{"Owner > component": item.componentName, "Inclusive time (ms)": roundFloat(item.time), Instances: item.count}
        }));
        console.log("Total time:", ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + " ms")
    }, getMeasurementsSummaryMap: function (measurements) {
        var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(measurements, true);
        return summary.map(function (item) {
            return{"Owner > component": item.componentName, "Wasted time (ms)": item.time, Instances: item.count}
        })
    }, printWasted: function (measurements) {
        measurements = measurements || ReactDefaultPerf._allMeasurements;
        console.table(ReactDefaultPerf.getMeasurementsSummaryMap(measurements));
        console.log("Total time:", ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + " ms")
    }, printDOM: function (measurements) {
        measurements = measurements || ReactDefaultPerf._allMeasurements;
        var summary = ReactDefaultPerfAnalysis.getDOMSummary(measurements);
        console.table(summary.map(function (item) {
            var result = {};
            result[DOMProperty.ID_ATTRIBUTE_NAME] = item.id;
            result["type"] = item.type;
            result["args"] = JSON.stringify(item.args);
            return result
        }));
        console.log("Total time:", ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + " ms")
    }, _recordWrite: function (id, fnName, totalTime, args) {
        var writes = ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1].writes;
        writes[id] = writes[id] || [];
        writes[id].push({type: fnName, time: totalTime, args: args})
    }, measure: function (moduleName, fnName, func) {
        return function () {
            for (var args = [], $__0 = 0, $__1 = arguments.length; $__0 < $__1; $__0++)args.push(arguments[$__0]);
            var totalTime;
            var rv;
            var start;
            if (fnName === "_renderNewRootComponent" || fnName === "flushBatchedUpdates") {
                ReactDefaultPerf._allMeasurements.push({exclusive: {}, inclusive: {}, render: {}, counts: {}, writes: {}, displayNames: {}, totalTime: 0});
                start = performanceNow();
                rv = func.apply(this, args);
                ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1].totalTime = performanceNow() - start;
                return rv
            } else if (moduleName === "ReactDOMIDOperations" || moduleName === "ReactComponentBrowserEnvironment") {
                start = performanceNow();
                rv = func.apply(this, args);
                totalTime = performanceNow() - start;
                if (fnName === "mountImageIntoNode") {
                    var mountID = ReactMount.getID(args[1]);
                    ReactDefaultPerf._recordWrite(mountID, fnName, totalTime, args[0])
                } else if (fnName === "dangerouslyProcessChildrenUpdates") {
                    args[0].forEach(function (update) {
                        var writeArgs = {};
                        if (update.fromIndex !== null) {
                            writeArgs.fromIndex = update.fromIndex
                        }
                        if (update.toIndex !== null) {
                            writeArgs.toIndex = update.toIndex
                        }
                        if (update.textContent !== null) {
                            writeArgs.textContent = update.textContent
                        }
                        if (update.markupIndex !== null) {
                            writeArgs.markup = args[1][update.markupIndex]
                        }
                        ReactDefaultPerf._recordWrite(update.parentID, update.type, totalTime, writeArgs)
                    })
                } else {
                    ReactDefaultPerf._recordWrite(args[0], fnName, totalTime, Array.prototype.slice.call(args, 1))
                }
                return rv
            } else if (moduleName === "ReactCompositeComponent" && (fnName === "mountComponent" || fnName === "updateComponent" || fnName === "_renderValidatedComponent")) {
                var rootNodeID = fnName === "mountComponent" ? args[0] : this._rootNodeID;
                var isRender = fnName === "_renderValidatedComponent";
                var isMount = fnName === "mountComponent";
                var mountStack = ReactDefaultPerf._mountStack;
                var entry = ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1];
                if (isRender) {
                    addValue(entry.counts, rootNodeID, 1)
                } else if (isMount) {
                    mountStack.push(0)
                }
                start = performanceNow();
                rv = func.apply(this, args);
                totalTime = performanceNow() - start;
                if (isRender) {
                    addValue(entry.render, rootNodeID, totalTime)
                } else if (isMount) {
                    var subMountTime = mountStack.pop();
                    mountStack[mountStack.length - 1] += totalTime;
                    addValue(entry.exclusive, rootNodeID, totalTime - subMountTime);
                    addValue(entry.inclusive, rootNodeID, totalTime)
                } else {
                    addValue(entry.inclusive, rootNodeID, totalTime)
                }
                entry.displayNames[rootNodeID] = {current: this.constructor.displayName, owner: this._owner ? this._owner.constructor.displayName : "<root>"};
                return rv
            } else {
                return func.apply(this, args)
            }
        }
    }};
    module.exports = ReactDefaultPerf
}, {"./DOMProperty": 77, "./ReactDefaultPerfAnalysis": 118, "./ReactMount": 130, "./ReactPerf": 135, "./performanceNow": 206}], 118: [function (require, module, exports) {
    var assign = require("./Object.assign");
    var DONT_CARE_THRESHOLD = 1.2;
    var DOM_OPERATION_TYPES = {mountImageIntoNode: "set innerHTML", INSERT_MARKUP: "set innerHTML", MOVE_EXISTING: "move", REMOVE_NODE: "remove", TEXT_CONTENT: "set textContent", updatePropertyByID: "update attribute", deletePropertyByID: "delete attribute", updateStylesByID: "update styles", updateInnerHTMLByID: "set innerHTML", dangerouslyReplaceNodeWithMarkupByID: "replace"};

    function getTotalTime(measurements) {
        var totalTime = 0;
        for (var i = 0; i < measurements.length; i++) {
            var measurement = measurements[i];
            totalTime += measurement.totalTime
        }
        return totalTime
    }

    function getDOMSummary(measurements) {
        var items = [];
        for (var i = 0; i < measurements.length; i++) {
            var measurement = measurements[i];
            var id;
            for (id in measurement.writes) {
                measurement.writes[id].forEach(function (write) {
                    items.push({id: id, type: DOM_OPERATION_TYPES[write.type] || write.type, args: write.args})
                })
            }
        }
        return items
    }

    function getExclusiveSummary(measurements) {
        var candidates = {};
        var displayName;
        for (var i = 0; i < measurements.length; i++) {
            var measurement = measurements[i];
            var allIDs = assign({}, measurement.exclusive, measurement.inclusive);
            for (var id in allIDs) {
                displayName = measurement.displayNames[id].current;
                candidates[displayName] = candidates[displayName] || {componentName: displayName, inclusive: 0, exclusive: 0, render: 0, count: 0};
                if (measurement.render[id]) {
                    candidates[displayName].render += measurement.render[id]
                }
                if (measurement.exclusive[id]) {
                    candidates[displayName].exclusive += measurement.exclusive[id]
                }
                if (measurement.inclusive[id]) {
                    candidates[displayName].inclusive += measurement.inclusive[id]
                }
                if (measurement.counts[id]) {
                    candidates[displayName].count += measurement.counts[id]
                }
            }
        }
        var arr = [];
        for (displayName in candidates) {
            if (candidates[displayName].exclusive >= DONT_CARE_THRESHOLD) {
                arr.push(candidates[displayName])
            }
        }
        arr.sort(function (a, b) {
            return b.exclusive - a.exclusive
        });
        return arr
    }

    function getInclusiveSummary(measurements, onlyClean) {
        var candidates = {};
        var inclusiveKey;
        for (var i = 0; i < measurements.length; i++) {
            var measurement = measurements[i];
            var allIDs = assign({}, measurement.exclusive, measurement.inclusive);
            var cleanComponents;
            if (onlyClean) {
                cleanComponents = getUnchangedComponents(measurement)
            }
            for (var id in allIDs) {
                if (onlyClean && !cleanComponents[id]) {
                    continue
                }
                var displayName = measurement.displayNames[id];
                inclusiveKey = displayName.owner + " > " + displayName.current;
                candidates[inclusiveKey] = candidates[inclusiveKey] || {componentName: inclusiveKey, time: 0, count: 0};
                if (measurement.inclusive[id]) {
                    candidates[inclusiveKey].time += measurement.inclusive[id]
                }
                if (measurement.counts[id]) {
                    candidates[inclusiveKey].count += measurement.counts[id]
                }
            }
        }
        var arr = [];
        for (inclusiveKey in candidates) {
            if (candidates[inclusiveKey].time >= DONT_CARE_THRESHOLD) {
                arr.push(candidates[inclusiveKey])
            }
        }
        arr.sort(function (a, b) {
            return b.time - a.time
        });
        return arr
    }

    function getUnchangedComponents(measurement) {
        var cleanComponents = {};
        var dirtyLeafIDs = Object.keys(measurement.writes);
        var allIDs = assign({}, measurement.exclusive, measurement.inclusive);
        for (var id in allIDs) {
            var isDirty = false;
            for (var i = 0; i < dirtyLeafIDs.length; i++) {
                if (dirtyLeafIDs[i].indexOf(id) === 0) {
                    isDirty = true;
                    break
                }
            }
            if (!isDirty && measurement.counts[id] > 0) {
                cleanComponents[id] = true
            }
        }
        return cleanComponents
    }

    var ReactDefaultPerfAnalysis = {getExclusiveSummary: getExclusiveSummary, getInclusiveSummary: getInclusiveSummary, getDOMSummary: getDOMSummary, getTotalTime: getTotalTime};
    module.exports = ReactDefaultPerfAnalysis
}, {"./Object.assign": 93}], 119: [function (require, module, exports) {
    "use strict";
    var ReactContext = require("./ReactContext");
    var ReactCurrentOwner = require("./ReactCurrentOwner");
    var warning = require("./warning");
    var RESERVED_PROPS = {key: true, ref: true};

    function defineWarningProperty(object, key) {
        Object.defineProperty(object, key, {configurable: false, enumerable: true, get: function () {
            if (!this._store) {
                return null
            }
            return this._store[key]
        }, set: function (value) {
            "production" !== "production" ? warning(false, "Don't set the " + key + " property of the component. " + "Mutate the existing props object instead.") : null;
            this._store[key] = value
        }})
    }

    var useMutationMembrane = false;

    function defineMutationMembrane(prototype) {
        try {
            var pseudoFrozenProperties = {props: true};
            for (var key in pseudoFrozenProperties) {
                defineWarningProperty(prototype, key)
            }
            useMutationMembrane = true
        } catch (x) {
        }
    }

    var ReactElement = function (type, key, ref, owner, context, props) {
        this.type = type;
        this.key = key;
        this.ref = ref;
        this._owner = owner;
        this._context = context;
        if ("production" !== "production") {
            this._store = {validated: false, props: props};
            if (useMutationMembrane) {
                Object.freeze(this);
                return
            }
        }
        this.props = props
    };
    ReactElement.prototype = {_isReactElement: true};
    if ("production" !== "production") {
        defineMutationMembrane(ReactElement.prototype)
    }
    ReactElement.createElement = function (type, config, children) {
        var propName;
        var props = {};
        var key = null;
        var ref = null;
        if (config != null) {
            ref = config.ref === undefined ? null : config.ref;
            if ("production" !== "production") {
                "production" !== "production" ? warning(config.key !== null, "createElement(...): Encountered component with a `key` of null. In " + "a future version, this will be treated as equivalent to the string " + "'null'; instead, provide an explicit key or use undefined.") : null
            }
            key = config.key == null ? null : "" + config.key;
            for (propName in config) {
                if (config.hasOwnProperty(propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                    props[propName] = config[propName]
                }
            }
        }
        var childrenLength = arguments.length - 2;
        if (childrenLength === 1) {
            props.children = children
        } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i = 0; i < childrenLength; i++) {
                childArray[i] = arguments[i + 2]
            }
            props.children = childArray
        }
        if (type.defaultProps) {
            var defaultProps = type.defaultProps;
            for (propName in defaultProps) {
                if (typeof props[propName] === "undefined") {
                    props[propName] = defaultProps[propName]
                }
            }
        }
        return new ReactElement(type, key, ref, ReactCurrentOwner.current, ReactContext.current, props)
    };
    ReactElement.createFactory = function (type) {
        var factory = ReactElement.createElement.bind(null, type);
        factory.type = type;
        return factory
    };
    ReactElement.cloneAndReplaceProps = function (oldElement, newProps) {
        var newElement = new ReactElement(oldElement.type, oldElement.key, oldElement.ref, oldElement._owner, oldElement._context, newProps);
        if ("production" !== "production") {
            newElement._store.validated = oldElement._store.validated
        }
        return newElement
    };
    ReactElement.isValidElement = function (object) {
        var isElement = !!(object && object._isReactElement);
        return isElement
    };
    module.exports = ReactElement
}, {"./ReactContext": 102, "./ReactCurrentOwner": 103, "./warning": 212}], 120: [function (require, module, exports) {
    "use strict";
    var ReactElement = require("./ReactElement");
    var ReactPropTypeLocations = require("./ReactPropTypeLocations");
    var ReactCurrentOwner = require("./ReactCurrentOwner");
    var monitorCodeUse = require("./monitorCodeUse");
    var ownerHasKeyUseWarning = {react_key_warning: {}, react_numeric_key_warning: {}};
    var ownerHasMonitoredObjectMap = {};
    var loggedTypeFailures = {};
    var NUMERIC_PROPERTY_REGEX = /^\d+$/;

    function getCurrentOwnerDisplayName() {
        var current = ReactCurrentOwner.current;
        return current && current.constructor.displayName || undefined
    }

    function validateExplicitKey(component, parentType) {
        if (component._store.validated || component.key != null) {
            return
        }
        component._store.validated = true;
        warnAndMonitorForKeyUse("react_key_warning", 'Each child in an array should have a unique "key" prop.', component, parentType)
    }

    function validatePropertyKey(name, component, parentType) {
        if (!NUMERIC_PROPERTY_REGEX.test(name)) {
            return
        }
        warnAndMonitorForKeyUse("react_numeric_key_warning", "Child objects should have non-numeric keys so ordering is preserved.", component, parentType)
    }

    function warnAndMonitorForKeyUse(warningID, message, component, parentType) {
        var ownerName = getCurrentOwnerDisplayName();
        var parentName = parentType.displayName;
        var useName = ownerName || parentName;
        var memoizer = ownerHasKeyUseWarning[warningID];
        if (memoizer.hasOwnProperty(useName)) {
            return
        }
        memoizer[useName] = true;
        message += ownerName ? " Check the render method of " + ownerName + "." : " Check the renderComponent call using <" + parentName + ">.";
        var childOwnerName = null;
        if (component._owner && component._owner !== ReactCurrentOwner.current) {
            childOwnerName = component._owner.constructor.displayName;
            message += " It was passed a child from " + childOwnerName + "."
        }
        message += " See http://fb.me/react-warning-keys for more information.";
        monitorCodeUse(warningID, {component: useName, componentOwner: childOwnerName});
        console.warn(message)
    }

    function monitorUseOfObjectMap() {
        var currentName = getCurrentOwnerDisplayName() || "";
        if (ownerHasMonitoredObjectMap.hasOwnProperty(currentName)) {
            return
        }
        ownerHasMonitoredObjectMap[currentName] = true;
        monitorCodeUse("react_object_map_children")
    }

    function validateChildKeys(component, parentType) {
        if (Array.isArray(component)) {
            for (var i = 0; i < component.length; i++) {
                var child = component[i];
                if (ReactElement.isValidElement(child)) {
                    validateExplicitKey(child, parentType)
                }
            }
        } else if (ReactElement.isValidElement(component)) {
            component._store.validated = true
        } else if (component && typeof component === "object") {
            monitorUseOfObjectMap();
            for (var name in component) {
                validatePropertyKey(name, component[name], parentType)
            }
        }
    }

    function checkPropTypes(componentName, propTypes, props, location) {
        for (var propName in propTypes) {
            if (propTypes.hasOwnProperty(propName)) {
                var error;
                try {
                    error = propTypes[propName](props, propName, componentName, location)
                } catch (ex) {
                    error = ex
                }
                if (error instanceof Error && !(error.message in loggedTypeFailures)) {
                    loggedTypeFailures[error.message] = true;
                    monitorCodeUse("react_failed_descriptor_type_check", {message: error.message})
                }
            }
        }
    }

    var ReactElementValidator = {createElement: function (type, props, children) {
        var element = ReactElement.createElement.apply(this, arguments);
        if (element == null) {
            return element
        }
        for (var i = 2; i < arguments.length; i++) {
            validateChildKeys(arguments[i], type)
        }
        var name = type.displayName;
        if (type.propTypes) {
            checkPropTypes(name, type.propTypes, element.props, ReactPropTypeLocations.prop)
        }
        if (type.contextTypes) {
            checkPropTypes(name, type.contextTypes, element._context, ReactPropTypeLocations.context)
        }
        return element
    }, createFactory: function (type) {
        var validatedFactory = ReactElementValidator.createElement.bind(null, type);
        validatedFactory.type = type;
        return validatedFactory
    }};
    module.exports = ReactElementValidator
}, {"./ReactCurrentOwner": 103, "./ReactElement": 119, "./ReactPropTypeLocations": 138, "./monitorCodeUse": 203}], 121: [function (require, module, exports) {
    "use strict";
    var ReactElement = require("./ReactElement");
    var invariant = require("./invariant");
    var component;
    var nullComponentIdsRegistry = {};
    var ReactEmptyComponentInjection = {injectEmptyComponent: function (emptyComponent) {
        component = ReactElement.createFactory(emptyComponent)
    }};

    function getEmptyComponent() {
        "production" !== "production" ? invariant(component, "Trying to return null from a render, but no null placeholder component " + "was injected.") : invariant(component);
        return component()
    }

    function registerNullComponentID(id) {
        nullComponentIdsRegistry[id] = true
    }

    function deregisterNullComponentID(id) {
        delete nullComponentIdsRegistry[id]
    }

    function isNullComponentID(id) {
        return nullComponentIdsRegistry[id]
    }

    var ReactEmptyComponent = {deregisterNullComponentID: deregisterNullComponentID, getEmptyComponent: getEmptyComponent, injection: ReactEmptyComponentInjection, isNullComponentID: isNullComponentID, registerNullComponentID: registerNullComponentID};
    module.exports = ReactEmptyComponent
}, {"./ReactElement": 119, "./invariant": 193}], 122: [function (require, module, exports) {
    "use strict";
    var ReactErrorUtils = {guard: function (func, name) {
        return func
    }};
    module.exports = ReactErrorUtils
}, {}], 123: [function (require, module, exports) {
    "use strict";
    var EventPluginHub = require("./EventPluginHub");

    function runEventQueueInBatch(events) {
        EventPluginHub.enqueueEvents(events);
        EventPluginHub.processEventQueue()
    }

    var ReactEventEmitterMixin = {handleTopLevel: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
        var events = EventPluginHub.extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent);
        runEventQueueInBatch(events)
    }};
    module.exports = ReactEventEmitterMixin
}, {"./EventPluginHub": 84}], 124: [function (require, module, exports) {
    "use strict";
    var EventListener = require("./EventListener");
    var ExecutionEnvironment = require("./ExecutionEnvironment");
    var PooledClass = require("./PooledClass");
    var ReactInstanceHandles = require("./ReactInstanceHandles");
    var ReactMount = require("./ReactMount");
    var ReactUpdates = require("./ReactUpdates");
    var assign = require("./Object.assign");
    var getEventTarget = require("./getEventTarget");
    var getUnboundedScrollPosition = require("./getUnboundedScrollPosition");

    function findParent(node) {
        var nodeID = ReactMount.getID(node);
        var rootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);
        var container = ReactMount.findReactContainerForID(rootID);
        var parent = ReactMount.getFirstReactDOM(container);
        return parent
    }

    function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
        this.topLevelType = topLevelType;
        this.nativeEvent = nativeEvent;
        this.ancestors = []
    }

    assign(TopLevelCallbackBookKeeping.prototype, {destructor: function () {
        this.topLevelType = null;
        this.nativeEvent = null;
        this.ancestors.length = 0
    }});
    PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);
    function handleTopLevelImpl(bookKeeping) {
        var topLevelTarget = ReactMount.getFirstReactDOM(getEventTarget(bookKeeping.nativeEvent)) || window;
        var ancestor = topLevelTarget;
        while (ancestor) {
            bookKeeping.ancestors.push(ancestor);
            ancestor = findParent(ancestor)
        }
        for (var i = 0, l = bookKeeping.ancestors.length; i < l; i++) {
            topLevelTarget = bookKeeping.ancestors[i];
            var topLevelTargetID = ReactMount.getID(topLevelTarget) || "";
            ReactEventListener._handleTopLevel(bookKeeping.topLevelType, topLevelTarget, topLevelTargetID, bookKeeping.nativeEvent)
        }
    }

    function scrollValueMonitor(cb) {
        var scrollPosition = getUnboundedScrollPosition(window);
        cb(scrollPosition)
    }

    var ReactEventListener = {_enabled: true, _handleTopLevel: null, WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null, setHandleTopLevel: function (handleTopLevel) {
        ReactEventListener._handleTopLevel = handleTopLevel
    }, setEnabled: function (enabled) {
        ReactEventListener._enabled = !!enabled
    }, isEnabled: function () {
        return ReactEventListener._enabled
    }, trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {
        var element = handle;
        if (!element) {
            return
        }
        return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType))
    }, trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {
        var element = handle;
        if (!element) {
            return
        }
        return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType))
    }, monitorScrollValue: function (refresh) {
        var callback = scrollValueMonitor.bind(null, refresh);
        EventListener.listen(window, "scroll", callback);
        EventListener.listen(window, "resize", callback)
    }, dispatchEvent: function (topLevelType, nativeEvent) {
        if (!ReactEventListener._enabled) {
            return
        }
        var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
        try {
            ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping)
        } finally {
            TopLevelCallbackBookKeeping.release(bookKeeping)
        }
    }};
    module.exports = ReactEventListener
}, {"./EventListener": 83, "./ExecutionEnvironment": 88, "./Object.assign": 93, "./PooledClass": 94, "./ReactInstanceHandles": 127, "./ReactMount": 130, "./ReactUpdates": 146, "./getEventTarget": 184, "./getUnboundedScrollPosition": 189}], 125: [function (require, module, exports) {
    "use strict";
    var DOMProperty = require("./DOMProperty");
    var EventPluginHub = require("./EventPluginHub");
    var ReactComponent = require("./ReactComponent");
    var ReactCompositeComponent = require("./ReactCompositeComponent");
    var ReactEmptyComponent = require("./ReactEmptyComponent");
    var ReactBrowserEventEmitter = require("./ReactBrowserEventEmitter");
    var ReactNativeComponent = require("./ReactNativeComponent");
    var ReactPerf = require("./ReactPerf");
    var ReactRootIndex = require("./ReactRootIndex");
    var ReactUpdates = require("./ReactUpdates");
    var ReactInjection = {Component: ReactComponent.injection, CompositeComponent: ReactCompositeComponent.injection, DOMProperty: DOMProperty.injection, EmptyComponent: ReactEmptyComponent.injection, EventPluginHub: EventPluginHub.injection, EventEmitter: ReactBrowserEventEmitter.injection, NativeComponent: ReactNativeComponent.injection, Perf: ReactPerf.injection, RootIndex: ReactRootIndex.injection, Updates: ReactUpdates.injection};
    module.exports = ReactInjection
}, {"./DOMProperty": 77, "./EventPluginHub": 84, "./ReactBrowserEventEmitter": 97, "./ReactComponent": 99, "./ReactCompositeComponent": 101, "./ReactEmptyComponent": 121, "./ReactNativeComponent": 133, "./ReactPerf": 135, "./ReactRootIndex": 142, "./ReactUpdates": 146}], 126: [function (require, module, exports) {
    "use strict";
    var ReactDOMSelection = require("./ReactDOMSelection");
    var containsNode = require("./containsNode");
    var focusNode = require("./focusNode");
    var getActiveElement = require("./getActiveElement");

    function isInDocument(node) {
        return containsNode(document.documentElement, node)
    }

    var ReactInputSelection = {hasSelectionCapabilities: function (elem) {
        return elem && (elem.nodeName === "INPUT" && elem.type === "text" || elem.nodeName === "TEXTAREA" || elem.contentEditable === "true")
    }, getSelectionInformation: function () {
        var focusedElem = getActiveElement();
        return{focusedElem: focusedElem, selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null}
    }, restoreSelection: function (priorSelectionInformation) {
        var curFocusedElem = getActiveElement();
        var priorFocusedElem = priorSelectionInformation.focusedElem;
        var priorSelectionRange = priorSelectionInformation.selectionRange;
        if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
            if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
                ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange)
            }
            focusNode(priorFocusedElem)
        }
    }, getSelection: function (input) {
        var selection;
        if ("selectionStart"in input) {
            selection = {start: input.selectionStart, end: input.selectionEnd}
        } else if (document.selection && input.nodeName === "INPUT") {
            var range = document.selection.createRange();
            if (range.parentElement() === input) {
                selection = {start: -range.moveStart("character", -input.value.length), end: -range.moveEnd("character", -input.value.length)}
            }
        } else {
            selection = ReactDOMSelection.getOffsets(input)
        }
        return selection || {start: 0, end: 0}
    }, setSelection: function (input, offsets) {
        var start = offsets.start;
        var end = offsets.end;
        if (typeof end === "undefined") {
            end = start
        }
        if ("selectionStart"in input) {
            input.selectionStart = start;
            input.selectionEnd = Math.min(end, input.value.length)
        } else if (document.selection && input.nodeName === "INPUT") {
            var range = input.createTextRange();
            range.collapse(true);
            range.moveStart("character", start);
            range.moveEnd("character", end - start);
            range.select()
        } else {
            ReactDOMSelection.setOffsets(input, offsets)
        }
    }};
    module.exports = ReactInputSelection
}, {"./ReactDOMSelection": 113, "./containsNode": 168, "./focusNode": 178, "./getActiveElement": 180}], 127: [function (require, module, exports) {
    "use strict";
    var ReactRootIndex = require("./ReactRootIndex");
    var invariant = require("./invariant");
    var SEPARATOR = ".";
    var SEPARATOR_LENGTH = SEPARATOR.length;
    var MAX_TREE_DEPTH = 100;

    function getReactRootIDString(index) {
        return SEPARATOR + index.toString(36)
    }

    function isBoundary(id, index) {
        return id.charAt(index) === SEPARATOR || index === id.length
    }

    function isValidID(id) {
        return id === "" || id.charAt(0) === SEPARATOR && id.charAt(id.length - 1) !== SEPARATOR
    }

    function isAncestorIDOf(ancestorID, descendantID) {
        return descendantID.indexOf(ancestorID) === 0 && isBoundary(descendantID, ancestorID.length)
    }

    function getParentID(id) {
        return id ? id.substr(0, id.lastIndexOf(SEPARATOR)) : ""
    }

    function getNextDescendantID(ancestorID, destinationID) {
        "production" !== "production" ? invariant(isValidID(ancestorID) && isValidID(destinationID), "getNextDescendantID(%s, %s): Received an invalid React DOM ID.", ancestorID, destinationID) : invariant(isValidID(ancestorID) && isValidID(destinationID));
        "production" !== "production" ? invariant(isAncestorIDOf(ancestorID, destinationID), "getNextDescendantID(...): React has made an invalid assumption about " + "the DOM hierarchy. Expected `%s` to be an ancestor of `%s`.", ancestorID, destinationID) : invariant(isAncestorIDOf(ancestorID, destinationID));
        if (ancestorID === destinationID) {
            return ancestorID
        }
        var start = ancestorID.length + SEPARATOR_LENGTH;
        for (var i = start; i < destinationID.length; i++) {
            if (isBoundary(destinationID, i)) {
                break
            }
        }
        return destinationID.substr(0, i)
    }

    function getFirstCommonAncestorID(oneID, twoID) {
        var minLength = Math.min(oneID.length, twoID.length);
        if (minLength === 0) {
            return""
        }
        var lastCommonMarkerIndex = 0;
        for (var i = 0; i <= minLength; i++) {
            if (isBoundary(oneID, i) && isBoundary(twoID, i)) {
                lastCommonMarkerIndex = i
            } else if (oneID.charAt(i) !== twoID.charAt(i)) {
                break
            }
        }
        var longestCommonID = oneID.substr(0, lastCommonMarkerIndex);
        "production" !== "production" ? invariant(isValidID(longestCommonID), "getFirstCommonAncestorID(%s, %s): Expected a valid React DOM ID: %s", oneID, twoID, longestCommonID) : invariant(isValidID(longestCommonID));
        return longestCommonID
    }

    function traverseParentPath(start, stop, cb, arg, skipFirst, skipLast) {
        start = start || "";
        stop = stop || "";
        "production" !== "production" ? invariant(start !== stop, "traverseParentPath(...): Cannot traverse from and to the same ID, `%s`.", start) : invariant(start !== stop);
        var traverseUp = isAncestorIDOf(stop, start);
        "production" !== "production" ? invariant(traverseUp || isAncestorIDOf(start, stop), "traverseParentPath(%s, %s, ...): Cannot traverse from two IDs that do " + "not have a parent path.", start, stop) : invariant(traverseUp || isAncestorIDOf(start, stop));
        var depth = 0;
        var traverse = traverseUp ? getParentID : getNextDescendantID;
        for (var id = start; ; id = traverse(id, stop)) {
            var ret;
            if ((!skipFirst || id !== start) && (!skipLast || id !== stop)) {
                ret = cb(id, traverseUp, arg)
            }
            if (ret === false || id === stop) {
                break
            }
            "production" !== "production" ? invariant(depth++ < MAX_TREE_DEPTH, "traverseParentPath(%s, %s, ...): Detected an infinite loop while " + "traversing the React DOM ID tree. This may be due to malformed IDs: %s", start, stop) : invariant(depth++ < MAX_TREE_DEPTH)
        }
    }

    var ReactInstanceHandles = {createReactRootID: function () {
        return getReactRootIDString(ReactRootIndex.createReactRootIndex())
    }, createReactID: function (rootID, name) {
        return rootID + name
    }, getReactRootIDFromNodeID: function (id) {
        if (id && id.charAt(0) === SEPARATOR && id.length > 1) {
            var index = id.indexOf(SEPARATOR, 1);
            return index > -1 ? id.substr(0, index) : id
        }
        return null
    }, traverseEnterLeave: function (leaveID, enterID, cb, upArg, downArg) {
        var ancestorID = getFirstCommonAncestorID(leaveID, enterID);
        if (ancestorID !== leaveID) {
            traverseParentPath(leaveID, ancestorID, cb, upArg, false, true)
        }
        if (ancestorID !== enterID) {
            traverseParentPath(ancestorID, enterID, cb, downArg, true, false)
        }
    }, traverseTwoPhase: function (targetID, cb, arg) {
        if (targetID) {
            traverseParentPath("", targetID, cb, arg, true, false);
            traverseParentPath(targetID, "", cb, arg, false, true)
        }
    }, traverseAncestors: function (targetID, cb, arg) {
        traverseParentPath("", targetID, cb, arg, true, false)
    }, _getFirstCommonAncestorID: getFirstCommonAncestorID, _getNextDescendantID: getNextDescendantID, isAncestorIDOf: isAncestorIDOf, SEPARATOR: SEPARATOR};
    module.exports = ReactInstanceHandles
}, {"./ReactRootIndex": 142, "./invariant": 193}], 128: [function (require, module, exports) {
    "use strict";
    var ReactCurrentOwner = require("./ReactCurrentOwner");
    var invariant = require("./invariant");
    var monitorCodeUse = require("./monitorCodeUse");
    var warning = require("./warning");
    var legacyFactoryLogs = {};

    function warnForLegacyFactoryCall() {
        if (!ReactLegacyElementFactory._isLegacyCallWarningEnabled) {
            return
        }
        var owner = ReactCurrentOwner.current;
        var name = owner && owner.constructor ? owner.constructor.displayName : "";
        if (!name) {
            name = "Something"
        }
        if (legacyFactoryLogs.hasOwnProperty(name)) {
            return
        }
        legacyFactoryLogs[name] = true;
        "production" !== "production" ? warning(false, name + " is calling a React component directly. " + "Use a factory or JSX instead. See: http://fb.me/react-legacyfactory") : null;
        monitorCodeUse("react_legacy_factory_call", {version: 3, name: name})
    }

    function warnForPlainFunctionType(type) {
        var isReactClass = type.prototype && typeof type.prototype.mountComponent === "function" && typeof type.prototype.receiveComponent === "function";
        if (isReactClass) {
            "production" !== "production" ? warning(false, "Did not expect to get a React class here. Use `Component` instead " + "of `Component.type` or `this.constructor`.") : null
        } else {
            if (!type._reactWarnedForThisType) {
                try {
                    type._reactWarnedForThisType = true
                } catch (x) {
                }
                monitorCodeUse("react_non_component_in_jsx", {version: 3, name: type.name})
            }
            "production" !== "production" ? warning(false, "This JSX uses a plain function. Only React components are " + "valid in React's JSX transform.") : null
        }
    }

    function warnForNonLegacyFactory(type) {
        "production" !== "production" ? warning(false, "Do not pass React.DOM." + type.type + " to JSX or createFactory. " + 'Use the string "' + type.type + '" instead.') : null
    }

    function proxyStaticMethods(target, source) {
        if (typeof source !== "function") {
            return
        }
        for (var key in source) {
            if (source.hasOwnProperty(key)) {
                var value = source[key];
                if (typeof value === "function") {
                    var bound = value.bind(source);
                    for (var k in value) {
                        if (value.hasOwnProperty(k)) {
                            bound[k] = value[k]
                        }
                    }
                    target[key] = bound
                } else {
                    target[key] = value
                }
            }
        }
    }

    var LEGACY_MARKER = {};
    var NON_LEGACY_MARKER = {};
    var ReactLegacyElementFactory = {};
    ReactLegacyElementFactory.wrapCreateFactory = function (createFactory) {
        var legacyCreateFactory = function (type) {
            if (typeof type !== "function") {
                return createFactory(type)
            }
            if (type.isReactNonLegacyFactory) {
                if ("production" !== "production") {
                    warnForNonLegacyFactory(type)
                }
                return createFactory(type.type)
            }
            if (type.isReactLegacyFactory) {
                return createFactory(type.type)
            }
            if ("production" !== "production") {
                warnForPlainFunctionType(type)
            }
            return type
        };
        return legacyCreateFactory
    };
    ReactLegacyElementFactory.wrapCreateElement = function (createElement) {
        var legacyCreateElement = function (type, props, children) {
            if (typeof type !== "function") {
                return createElement.apply(this, arguments)
            }
            var args;
            if (type.isReactNonLegacyFactory) {
                if ("production" !== "production") {
                    warnForNonLegacyFactory(type)
                }
                args = Array.prototype.slice.call(arguments, 0);
                args[0] = type.type;
                return createElement.apply(this, args)
            }
            if (type.isReactLegacyFactory) {
                if (type._isMockFunction) {
                    type.type._mockedReactClassConstructor = type
                }
                args = Array.prototype.slice.call(arguments, 0);
                args[0] = type.type;
                return createElement.apply(this, args)
            }
            if ("production" !== "production") {
                warnForPlainFunctionType(type)
            }
            return type.apply(null, Array.prototype.slice.call(arguments, 1))
        };
        return legacyCreateElement
    };
    ReactLegacyElementFactory.wrapFactory = function (factory) {
        "production" !== "production" ? invariant(typeof factory === "function", "This is suppose to accept a element factory") : invariant(typeof factory === "function");
        var legacyElementFactory = function (config, children) {
            if ("production" !== "production") {
                warnForLegacyFactoryCall()
            }
            return factory.apply(this, arguments)
        };
        proxyStaticMethods(legacyElementFactory, factory.type);
        legacyElementFactory.isReactLegacyFactory = LEGACY_MARKER;
        legacyElementFactory.type = factory.type;
        return legacyElementFactory
    };
    ReactLegacyElementFactory.markNonLegacyFactory = function (factory) {
        factory.isReactNonLegacyFactory = NON_LEGACY_MARKER;
        return factory
    };
    ReactLegacyElementFactory.isValidFactory = function (factory) {
        return typeof factory === "function" && factory.isReactLegacyFactory === LEGACY_MARKER
    };
    ReactLegacyElementFactory.isValidClass = function (factory) {
        if ("production" !== "production") {
            "production" !== "production" ? warning(false, "isValidClass is deprecated and will be removed in a future release. " + "Use a more specific validator instead.") : null
        }
        return ReactLegacyElementFactory.isValidFactory(factory)
    };
    ReactLegacyElementFactory._isLegacyCallWarningEnabled = true;
    module.exports = ReactLegacyElementFactory
}, {"./ReactCurrentOwner": 103, "./invariant": 193, "./monitorCodeUse": 203, "./warning": 212}], 129: [function (require, module, exports) {
    "use strict";
    var adler32 = require("./adler32");
    var ReactMarkupChecksum = {CHECKSUM_ATTR_NAME: "data-react-checksum", addChecksumToMarkup: function (markup) {
        var checksum = adler32(markup);
        return markup.replace(">", " " + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '">')
    }, canReuseMarkup: function (markup, element) {
        var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
        existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
        var markupChecksum = adler32(markup);
        return markupChecksum === existingChecksum
    }};
    module.exports = ReactMarkupChecksum
}, {"./adler32": 165}], 130: [function (require, module, exports) {
    "use strict";
    var DOMProperty = require("./DOMProperty");
    var ReactBrowserEventEmitter = require("./ReactBrowserEventEmitter");
    var ReactCurrentOwner = require("./ReactCurrentOwner");
    var ReactElement = require("./ReactElement");
    var ReactLegacyElement = require("./ReactLegacyElement");
    var ReactInstanceHandles = require("./ReactInstanceHandles");
    var ReactPerf = require("./ReactPerf");
    var containsNode = require("./containsNode");
    var deprecated = require("./deprecated");
    var getReactRootElementInContainer = require("./getReactRootElementInContainer");
    var instantiateReactComponent = require("./instantiateReactComponent");
    var invariant = require("./invariant");
    var shouldUpdateReactComponent = require("./shouldUpdateReactComponent");
    var warning = require("./warning");
    var createElement = ReactLegacyElement.wrapCreateElement(ReactElement.createElement);
    var SEPARATOR = ReactInstanceHandles.SEPARATOR;
    var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
    var nodeCache = {};
    var ELEMENT_NODE_TYPE = 1;
    var DOC_NODE_TYPE = 9;
    var instancesByReactRootID = {};
    var containersByReactRootID = {};
    if ("production" !== "production") {
        var rootElementsByReactRootID = {}
    }
    var findComponentRootReusableArray = [];

    function getReactRootID(container) {
        var rootElement = getReactRootElementInContainer(container);
        return rootElement && ReactMount.getID(rootElement)
    }

    function getID(node) {
        var id = internalGetID(node);
        if (id) {
            if (nodeCache.hasOwnProperty(id)) {
                var cached = nodeCache[id];
                if (cached !== node) {
                    "production" !== "production" ? invariant(!isValid(cached, id), "ReactMount: Two valid but unequal nodes with the same `%s`: %s", ATTR_NAME, id) : invariant(!isValid(cached, id));
                    nodeCache[id] = node
                }
            } else {
                nodeCache[id] = node
            }
        }
        return id
    }

    function internalGetID(node) {
        return node && node.getAttribute && node.getAttribute(ATTR_NAME) || ""
    }

    function setID(node, id) {
        var oldID = internalGetID(node);
        if (oldID !== id) {
            delete nodeCache[oldID]
        }
        node.setAttribute(ATTR_NAME, id);
        nodeCache[id] = node
    }

    function getNode(id) {
        if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {
            nodeCache[id] = ReactMount.findReactNodeByID(id)
        }
        return nodeCache[id]
    }

    function isValid(node, id) {
        if (node) {
            "production" !== "production" ? invariant(internalGetID(node) === id, "ReactMount: Unexpected modification of `%s`", ATTR_NAME) : invariant(internalGetID(node) === id);
            var container = ReactMount.findReactContainerForID(id);
            if (container && containsNode(container, node)) {
                return true
            }
        }
        return false
    }

    function purgeID(id) {
        delete nodeCache[id]
    }

    var deepestNodeSoFar = null;

    function findDeepestCachedAncestorImpl(ancestorID) {
        var ancestor = nodeCache[ancestorID];
        if (ancestor && isValid(ancestor, ancestorID)) {
            deepestNodeSoFar = ancestor
        } else {
            return false
        }
    }

    function findDeepestCachedAncestor(targetID) {
        deepestNodeSoFar = null;
        ReactInstanceHandles.traverseAncestors(targetID, findDeepestCachedAncestorImpl);
        var foundNode = deepestNodeSoFar;
        deepestNodeSoFar = null;
        return foundNode
    }

    var ReactMount = {_instancesByReactRootID: instancesByReactRootID, scrollMonitor: function (container, renderCallback) {
        renderCallback()
    }, _updateRootComponent: function (prevComponent, nextComponent, container, callback) {
        var nextProps = nextComponent.props;
        ReactMount.scrollMonitor(container, function () {
            prevComponent.replaceProps(nextProps, callback)
        });
        if ("production" !== "production") {
            rootElementsByReactRootID[getReactRootID(container)] = getReactRootElementInContainer(container)
        }
        return prevComponent
    }, _registerComponent: function (nextComponent, container) {
        "production" !== "production" ? invariant(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE), "_registerComponent(...): Target container is not a DOM element.") : invariant(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE));
        ReactBrowserEventEmitter.ensureScrollValueMonitoring();
        var reactRootID = ReactMount.registerContainer(container);
        instancesByReactRootID[reactRootID] = nextComponent;
        return reactRootID
    }, _renderNewRootComponent: ReactPerf.measure("ReactMount", "_renderNewRootComponent", function (nextComponent, container, shouldReuseMarkup) {
        "production" !== "production" ? warning(ReactCurrentOwner.current == null, "_renderNewRootComponent(): Render methods should be a pure function " + "of props and state; triggering nested component updates from " + "render is not allowed. If necessary, trigger nested updates in " + "componentDidUpdate.") : null;
        var componentInstance = instantiateReactComponent(nextComponent, null);
        var reactRootID = ReactMount._registerComponent(componentInstance, container);
        componentInstance.mountComponentIntoNode(reactRootID, container, shouldReuseMarkup);
        if ("production" !== "production") {
            rootElementsByReactRootID[reactRootID] = getReactRootElementInContainer(container)
        }
        return componentInstance
    }), render: function (nextElement, container, callback) {
        "production" !== "production" ? invariant(ReactElement.isValidElement(nextElement), "renderComponent(): Invalid component element.%s", typeof nextElement === "string" ? " Instead of passing an element string, make sure to instantiate " + "it by passing it to React.createElement." : ReactLegacyElement.isValidFactory(nextElement) ? " Instead of passing a component class, make sure to instantiate " + "it by passing it to React.createElement." : typeof nextElement.props !== "undefined" ? " This may be caused by unintentionally loading two independent " + "copies of React." : "") : invariant(ReactElement.isValidElement(nextElement));
        var prevComponent = instancesByReactRootID[getReactRootID(container)];
        if (prevComponent) {
            var prevElement = prevComponent._currentElement;
            if (shouldUpdateReactComponent(prevElement, nextElement)) {
                return ReactMount._updateRootComponent(prevComponent, nextElement, container, callback)
            } else {
                ReactMount.unmountComponentAtNode(container)
            }
        }
        var reactRootElement = getReactRootElementInContainer(container);
        var containerHasReactMarkup = reactRootElement && ReactMount.isRenderedByReact(reactRootElement);
        var shouldReuseMarkup = containerHasReactMarkup && !prevComponent;
        var component = ReactMount._renderNewRootComponent(nextElement, container, shouldReuseMarkup);
        callback && callback.call(component);
        return component
    }, constructAndRenderComponent: function (constructor, props, container) {
        var element = createElement(constructor, props);
        return ReactMount.render(element, container)
    }, constructAndRenderComponentByID: function (constructor, props, id) {
        var domNode = document.getElementById(id);
        "production" !== "production" ? invariant(domNode, 'Tried to get element with id of "%s" but it is not present on the page.', id) : invariant(domNode);
        return ReactMount.constructAndRenderComponent(constructor, props, domNode)
    }, registerContainer: function (container) {
        var reactRootID = getReactRootID(container);
        if (reactRootID) {
            reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID)
        }
        if (!reactRootID) {
            reactRootID = ReactInstanceHandles.createReactRootID()
        }
        containersByReactRootID[reactRootID] = container;
        return reactRootID
    }, unmountComponentAtNode: function (container) {
        "production" !== "production" ? warning(ReactCurrentOwner.current == null, "unmountComponentAtNode(): Render methods should be a pure function of " + "props and state; triggering nested component updates from render is " + "not allowed. If necessary, trigger nested updates in " + "componentDidUpdate.") : null;
        var reactRootID = getReactRootID(container);
        var component = instancesByReactRootID[reactRootID];
        if (!component) {
            return false
        }
        ReactMount.unmountComponentFromNode(component, container);
        delete instancesByReactRootID[reactRootID];
        delete containersByReactRootID[reactRootID];
        if ("production" !== "production") {
            delete rootElementsByReactRootID[reactRootID]
        }
        return true
    }, unmountComponentFromNode: function (instance, container) {
        instance.unmountComponent();
        if (container.nodeType === DOC_NODE_TYPE) {
            container = container.documentElement
        }
        while (container.lastChild) {
            container.removeChild(container.lastChild)
        }
    }, findReactContainerForID: function (id) {
        var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(id);
        var container = containersByReactRootID[reactRootID];
        if ("production" !== "production") {
            var rootElement = rootElementsByReactRootID[reactRootID];
            if (rootElement && rootElement.parentNode !== container) {
                "production" !== "production" ? invariant(internalGetID(rootElement) === reactRootID, "ReactMount: Root element ID differed from reactRootID.") : invariant(internalGetID(rootElement) === reactRootID);
                var containerChild = container.firstChild;
                if (containerChild && reactRootID === internalGetID(containerChild)) {
                    rootElementsByReactRootID[reactRootID] = containerChild
                } else {
                    console.warn("ReactMount: Root element has been removed from its original " + "container. New container:", rootElement.parentNode)
                }
            }
        }
        return container
    }, findReactNodeByID: function (id) {
        var reactRoot = ReactMount.findReactContainerForID(id);
        return ReactMount.findComponentRoot(reactRoot, id)
    }, isRenderedByReact: function (node) {
        if (node.nodeType !== 1) {
            return false
        }
        var id = ReactMount.getID(node);
        return id ? id.charAt(0) === SEPARATOR : false
    }, getFirstReactDOM: function (node) {
        var current = node;
        while (current && current.parentNode !== current) {
            if (ReactMount.isRenderedByReact(current)) {
                return current
            }
            current = current.parentNode
        }
        return null
    }, findComponentRoot: function (ancestorNode, targetID) {
        var firstChildren = findComponentRootReusableArray;
        var childIndex = 0;
        var deepestAncestor = findDeepestCachedAncestor(targetID) || ancestorNode;
        firstChildren[0] = deepestAncestor.firstChild;
        firstChildren.length = 1;
        while (childIndex < firstChildren.length) {
            var child = firstChildren[childIndex++];
            var targetChild;
            while (child) {
                var childID = ReactMount.getID(child);
                if (childID) {
                    if (targetID === childID) {
                        targetChild = child
                    } else if (ReactInstanceHandles.isAncestorIDOf(childID, targetID)) {
                        firstChildren.length = childIndex = 0;
                        firstChildren.push(child.firstChild)
                    }
                } else {
                    firstChildren.push(child.firstChild)
                }
                child = child.nextSibling
            }
            if (targetChild) {
                firstChildren.length = 0;
                return targetChild
            }
        }
        firstChildren.length = 0;
        "production" !== "production" ? invariant(false, "findComponentRoot(..., %s): Unable to find element. This probably " + "means the DOM was unexpectedly mutated (e.g., by the browser), " + "usually due to forgetting a <tbody> when using tables, nesting tags " + "like <form>, <p>, or <a>, or using non-SVG elements in an <svg> " + "parent. " + "Try inspecting the child nodes of the element with React ID `%s`.", targetID, ReactMount.getID(ancestorNode)) : invariant(false)
    }, getReactRootID: getReactRootID, getID: getID, setID: setID, getNode: getNode, purgeID: purgeID};
    ReactMount.renderComponent = deprecated("ReactMount", "renderComponent", "render", this, ReactMount.render);
    module.exports = ReactMount
}, {"./DOMProperty": 77, "./ReactBrowserEventEmitter": 97, "./ReactCurrentOwner": 103, "./ReactElement": 119, "./ReactInstanceHandles": 127, "./ReactLegacyElement": 128, "./ReactPerf": 135, "./containsNode": 168, "./deprecated": 173, "./getReactRootElementInContainer": 187, "./instantiateReactComponent": 192, "./invariant": 193, "./shouldUpdateReactComponent": 209, "./warning": 212}], 131: [function (require, module, exports) {
    "use strict";
    var ReactComponent = require("./ReactComponent");
    var ReactMultiChildUpdateTypes = require("./ReactMultiChildUpdateTypes");
    var flattenChildren = require("./flattenChildren");
    var instantiateReactComponent = require("./instantiateReactComponent");
    var shouldUpdateReactComponent = require("./shouldUpdateReactComponent");
    var updateDepth = 0;
    var updateQueue = [];
    var markupQueue = [];

    function enqueueMarkup(parentID, markup, toIndex) {
        updateQueue.push({parentID: parentID, parentNode: null, type: ReactMultiChildUpdateTypes.INSERT_MARKUP, markupIndex: markupQueue.push(markup) - 1, textContent: null, fromIndex: null, toIndex: toIndex})
    }

    function enqueueMove(parentID, fromIndex, toIndex) {
        updateQueue.push({parentID: parentID, parentNode: null, type: ReactMultiChildUpdateTypes.MOVE_EXISTING, markupIndex: null, textContent: null, fromIndex: fromIndex, toIndex: toIndex})
    }

    function enqueueRemove(parentID, fromIndex) {
        updateQueue.push({parentID: parentID, parentNode: null, type: ReactMultiChildUpdateTypes.REMOVE_NODE, markupIndex: null, textContent: null, fromIndex: fromIndex, toIndex: null})
    }

    function enqueueTextContent(parentID, textContent) {
        updateQueue.push({parentID: parentID, parentNode: null, type: ReactMultiChildUpdateTypes.TEXT_CONTENT, markupIndex: null, textContent: textContent, fromIndex: null, toIndex: null})
    }

    function processQueue() {
        if (updateQueue.length) {
            ReactComponent.BackendIDOperations.dangerouslyProcessChildrenUpdates(updateQueue, markupQueue);
            clearQueue()
        }
    }

    function clearQueue() {
        updateQueue.length = 0;
        markupQueue.length = 0
    }

    var ReactMultiChild = {Mixin: {mountChildren: function (nestedChildren, transaction) {
        var children = flattenChildren(nestedChildren);
        var mountImages = [];
        var index = 0;
        this._renderedChildren = children;
        for (var name in children) {
            var child = children[name];
            if (children.hasOwnProperty(name)) {
                var childInstance = instantiateReactComponent(child, null);
                children[name] = childInstance;
                var rootID = this._rootNodeID + name;
                var mountImage = childInstance.mountComponent(rootID, transaction, this._mountDepth + 1);
                childInstance._mountIndex = index;
                mountImages.push(mountImage);
                index++
            }
        }
        return mountImages
    }, updateTextContent: function (nextContent) {
        updateDepth++;
        var errorThrown = true;
        try {
            var prevChildren = this._renderedChildren;
            for (var name in prevChildren) {
                if (prevChildren.hasOwnProperty(name)) {
                    this._unmountChildByName(prevChildren[name], name)
                }
            }
            this.setTextContent(nextContent);
            errorThrown = false
        } finally {
            updateDepth--;
            if (!updateDepth) {
                errorThrown ? clearQueue() : processQueue()
            }
        }
    }, updateChildren: function (nextNestedChildren, transaction) {
        updateDepth++;
        var errorThrown = true;
        try {
            this._updateChildren(nextNestedChildren, transaction);
            errorThrown = false
        } finally {
            updateDepth--;
            if (!updateDepth) {
                errorThrown ? clearQueue() : processQueue()
            }
        }
    }, _updateChildren: function (nextNestedChildren, transaction) {
        var nextChildren = flattenChildren(nextNestedChildren);
        var prevChildren = this._renderedChildren;
        if (!nextChildren && !prevChildren) {
            return
        }
        var name;
        var lastIndex = 0;
        var nextIndex = 0;
        for (name in nextChildren) {
            if (!nextChildren.hasOwnProperty(name)) {
                continue
            }
            var prevChild = prevChildren && prevChildren[name];
            var prevElement = prevChild && prevChild._currentElement;
            var nextElement = nextChildren[name];
            if (shouldUpdateReactComponent(prevElement, nextElement)) {
                this.moveChild(prevChild, nextIndex, lastIndex);
                lastIndex = Math.max(prevChild._mountIndex, lastIndex);
                prevChild.receiveComponent(nextElement, transaction);
                prevChild._mountIndex = nextIndex
            } else {
                if (prevChild) {
                    lastIndex = Math.max(prevChild._mountIndex, lastIndex);
                    this._unmountChildByName(prevChild, name)
                }
                var nextChildInstance = instantiateReactComponent(nextElement, null);
                this._mountChildByNameAtIndex(nextChildInstance, name, nextIndex, transaction)
            }
            nextIndex++
        }
        for (name in prevChildren) {
            if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren[name])) {
                this._unmountChildByName(prevChildren[name], name)
            }
        }
    }, unmountChildren: function () {
        var renderedChildren = this._renderedChildren;
        for (var name in renderedChildren) {
            var renderedChild = renderedChildren[name];
            if (renderedChild.unmountComponent) {
                renderedChild.unmountComponent()
            }
        }
        this._renderedChildren = null
    }, moveChild: function (child, toIndex, lastIndex) {
        if (child._mountIndex < lastIndex) {
            enqueueMove(this._rootNodeID, child._mountIndex, toIndex)
        }
    }, createChild: function (child, mountImage) {
        enqueueMarkup(this._rootNodeID, mountImage, child._mountIndex)
    }, removeChild: function (child) {
        enqueueRemove(this._rootNodeID, child._mountIndex)
    }, setTextContent: function (textContent) {
        enqueueTextContent(this._rootNodeID, textContent)
    }, _mountChildByNameAtIndex: function (child, name, index, transaction) {
        var rootID = this._rootNodeID + name;
        var mountImage = child.mountComponent(rootID, transaction, this._mountDepth + 1);
        child._mountIndex = index;
        this.createChild(child, mountImage);
        this._renderedChildren = this._renderedChildren || {};
        this._renderedChildren[name] = child
    }, _unmountChildByName: function (child, name) {
        this.removeChild(child);
        child._mountIndex = null;
        child.unmountComponent();
        delete this._renderedChildren[name]
    }}};
    module.exports = ReactMultiChild
}, {"./ReactComponent": 99, "./ReactMultiChildUpdateTypes": 132, "./flattenChildren": 177, "./instantiateReactComponent": 192, "./shouldUpdateReactComponent": 209}], 132: [function (require, module, exports) {
    "use strict";
    var keyMirror = require("./keyMirror");
    var ReactMultiChildUpdateTypes = keyMirror({INSERT_MARKUP: null, MOVE_EXISTING: null, REMOVE_NODE: null, TEXT_CONTENT: null});
    module.exports = ReactMultiChildUpdateTypes
}, {"./keyMirror": 199}], 133: [function (require, module, exports) {
    "use strict";
    var assign = require("./Object.assign");
    var invariant = require("./invariant");
    var genericComponentClass = null;
    var tagToComponentClass = {};
    var ReactNativeComponentInjection = {injectGenericComponentClass: function (componentClass) {
        genericComponentClass = componentClass
    }, injectComponentClasses: function (componentClasses) {
        assign(tagToComponentClass, componentClasses)
    }};

    function createInstanceForTag(tag, props, parentType) {
        var componentClass = tagToComponentClass[tag];
        if (componentClass == null) {
            "production" !== "production" ? invariant(genericComponentClass, "There is no registered component for the tag %s", tag) : invariant(genericComponentClass);
            return new genericComponentClass(tag, props)
        }
        if (parentType === tag) {
            "production" !== "production" ? invariant(genericComponentClass, "There is no registered component for the tag %s", tag) : invariant(genericComponentClass);
            return new genericComponentClass(tag, props)
        }
        return new componentClass.type(props)
    }

    var ReactNativeComponent = {createInstanceForTag: createInstanceForTag, injection: ReactNativeComponentInjection};
    module.exports = ReactNativeComponent
}, {"./Object.assign": 93, "./invariant": 193}], 134: [function (require, module, exports) {
    "use strict";
    var emptyObject = require("./emptyObject");
    var invariant = require("./invariant");
    var ReactOwner = {isValidOwner: function (object) {
        return!!(object && typeof object.attachRef === "function" && typeof object.detachRef === "function")
    }, addComponentAsRefTo: function (component, ref, owner) {
        "production" !== "production" ? invariant(ReactOwner.isValidOwner(owner), "addComponentAsRefTo(...): Only a ReactOwner can have refs. This " + "usually means that you're trying to add a ref to a component that " + "doesn't have an owner (that is, was not created inside of another " + "component's `render` method). Try rendering this component inside of " + "a new top-level component which will hold the ref.") : invariant(ReactOwner.isValidOwner(owner));
        owner.attachRef(ref, component)
    }, removeComponentAsRefFrom: function (component, ref, owner) {
        "production" !== "production" ? invariant(ReactOwner.isValidOwner(owner), "removeComponentAsRefFrom(...): Only a ReactOwner can have refs. This " + "usually means that you're trying to remove a ref to a component that " + "doesn't have an owner (that is, was not created inside of another " + "component's `render` method). Try rendering this component inside of " + "a new top-level component which will hold the ref.") : invariant(ReactOwner.isValidOwner(owner));
        if (owner.refs[ref] === component) {
            owner.detachRef(ref)
        }
    }, Mixin: {construct: function () {
        this.refs = emptyObject
    }, attachRef: function (ref, component) {
        "production" !== "production" ? invariant(component.isOwnedBy(this), "attachRef(%s, ...): Only a component's owner can store a ref to it.", ref) : invariant(component.isOwnedBy(this));
        var refs = this.refs === emptyObject ? this.refs = {} : this.refs;
        refs[ref] = component
    }, detachRef: function (ref) {
        delete this.refs[ref]
    }}};
    module.exports = ReactOwner
}, {"./emptyObject": 175, "./invariant": 193}], 135: [function (require, module, exports) {
    "use strict";
    var ReactPerf = {enableMeasure: false, storedMeasure: _noMeasure, measure: function (objName, fnName, func) {
        if ("production" !== "production") {
            var measuredFunc = null;
            var wrapper = function () {
                if (ReactPerf.enableMeasure) {
                    if (!measuredFunc) {
                        measuredFunc = ReactPerf.storedMeasure(objName, fnName, func)
                    }
                    return measuredFunc.apply(this, arguments)
                }
                return func.apply(this, arguments)
            };
            wrapper.displayName = objName + "_" + fnName;
            return wrapper
        }
        return func
    }, injection: {injectMeasure: function (measure) {
        ReactPerf.storedMeasure = measure
    }}};

    function _noMeasure(objName, fnName, func) {
        return func
    }

    module.exports = ReactPerf
}, {}], 136: [function (require, module, exports) {
    "use strict";
    var assign = require("./Object.assign");
    var emptyFunction = require("./emptyFunction");
    var invariant = require("./invariant");
    var joinClasses = require("./joinClasses");
    var warning = require("./warning");
    var didWarn = false;

    function createTransferStrategy(mergeStrategy) {
        return function (props, key, value) {
            if (!props.hasOwnProperty(key)) {
                props[key] = value
            } else {
                props[key] = mergeStrategy(props[key], value)
            }
        }
    }

    var transferStrategyMerge = createTransferStrategy(function (a, b) {
        return assign({}, b, a)
    });
    var TransferStrategies = {children: emptyFunction, className: createTransferStrategy(joinClasses), style: transferStrategyMerge};

    function transferInto(props, newProps) {
        for (var thisKey in newProps) {
            if (!newProps.hasOwnProperty(thisKey)) {
                continue
            }
            var transferStrategy = TransferStrategies[thisKey];
            if (transferStrategy && TransferStrategies.hasOwnProperty(thisKey)) {
                transferStrategy(props, thisKey, newProps[thisKey])
            } else if (!props.hasOwnProperty(thisKey)) {
                props[thisKey] = newProps[thisKey]
            }
        }
        return props
    }

    var ReactPropTransferer = {TransferStrategies: TransferStrategies, mergeProps: function (oldProps, newProps) {
        return transferInto(assign({}, oldProps), newProps)
    }, Mixin: {transferPropsTo: function (element) {
        "production" !== "production" ? invariant(element._owner === this, "%s: You can't call transferPropsTo() on a component that you " + "don't own, %s. This usually means you are calling " + "transferPropsTo() on a component passed in as props or children.", this.constructor.displayName, typeof element.type === "string" ? element.type : element.type.displayName) : invariant(element._owner === this);
        if ("production" !== "production") {
            if (!didWarn) {
                didWarn = true;
                "production" !== "production" ? warning(false, "transferPropsTo is deprecated. " + "See http://fb.me/react-transferpropsto for more information.") : null
            }
        }
        transferInto(element.props, this.props);
        return element
    }}};
    module.exports = ReactPropTransferer
}, {"./Object.assign": 93, "./emptyFunction": 174, "./invariant": 193, "./joinClasses": 198, "./warning": 212}], 137: [function (require, module, exports) {
    "use strict";
    var ReactPropTypeLocationNames = {};
    if ("production" !== "production") {
        ReactPropTypeLocationNames = {prop: "prop", context: "context", childContext: "child context"}
    }
    module.exports = ReactPropTypeLocationNames
}, {}], 138: [function (require, module, exports) {
    "use strict";
    var keyMirror = require("./keyMirror");
    var ReactPropTypeLocations = keyMirror({prop: null, context: null, childContext: null});
    module.exports = ReactPropTypeLocations
}, {"./keyMirror": 199}], 139: [function (require, module, exports) {
    "use strict";
    var ReactElement = require("./ReactElement");
    var ReactPropTypeLocationNames = require("./ReactPropTypeLocationNames");
    var deprecated = require("./deprecated");
    var emptyFunction = require("./emptyFunction");
    var ANONYMOUS = "<<anonymous>>";
    var elementTypeChecker = createElementTypeChecker();
    var nodeTypeChecker = createNodeChecker();
    var ReactPropTypes = {array: createPrimitiveTypeChecker("array"), bool: createPrimitiveTypeChecker("boolean"), func: createPrimitiveTypeChecker("function"), number: createPrimitiveTypeChecker("number"), object: createPrimitiveTypeChecker("object"), string: createPrimitiveTypeChecker("string"), any: createAnyTypeChecker(), arrayOf: createArrayOfTypeChecker, element: elementTypeChecker, instanceOf: createInstanceTypeChecker, node: nodeTypeChecker, objectOf: createObjectOfTypeChecker, oneOf: createEnumTypeChecker, oneOfType: createUnionTypeChecker, shape: createShapeTypeChecker, component: deprecated("React.PropTypes", "component", "element", this, elementTypeChecker), renderable: deprecated("React.PropTypes", "renderable", "node", this, nodeTypeChecker)};

    function createChainableTypeChecker(validate) {
        function checkType(isRequired, props, propName, componentName, location) {
            componentName = componentName || ANONYMOUS;
            if (props[propName] == null) {
                var locationName = ReactPropTypeLocationNames[location];
                if (isRequired) {
                    return new Error("Required " + locationName + " `" + propName + "` was not specified in " + ("`" + componentName + "`."))
                }
            } else {
                return validate(props, propName, componentName, location)
            }
        }

        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType
    }

    function createPrimitiveTypeChecker(expectedType) {
        function validate(props, propName, componentName, location) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== expectedType) {
                var locationName = ReactPropTypeLocationNames[location];
                var preciseType = getPreciseType(propValue);
                return new Error("Invalid " + locationName + " `" + propName + "` of type `" + preciseType + "` " + ("supplied to `" + componentName + "`, expected `" + expectedType + "`."))
            }
        }

        return createChainableTypeChecker(validate)
    }

    function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunction.thatReturns())
    }

    function createArrayOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location) {
            var propValue = props[propName];
            if (!Array.isArray(propValue)) {
                var locationName = ReactPropTypeLocationNames[location];
                var propType = getPropType(propValue);
                return new Error("Invalid " + locationName + " `" + propName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."))
            }
            for (var i = 0; i < propValue.length; i++) {
                var error = typeChecker(propValue, i, componentName, location);
                if (error instanceof Error) {
                    return error
                }
            }
        }

        return createChainableTypeChecker(validate)
    }

    function createElementTypeChecker() {
        function validate(props, propName, componentName, location) {
            if (!ReactElement.isValidElement(props[propName])) {
                var locationName = ReactPropTypeLocationNames[location];
                return new Error("Invalid " + locationName + " `" + propName + "` supplied to " + ("`" + componentName + "`, expected a ReactElement."))
            }
        }

        return createChainableTypeChecker(validate)
    }

    function createInstanceTypeChecker(expectedClass) {
        function validate(props, propName, componentName, location) {
            if (!(props[propName]instanceof expectedClass)) {
                var locationName = ReactPropTypeLocationNames[location];
                var expectedClassName = expectedClass.name || ANONYMOUS;
                return new Error("Invalid " + locationName + " `" + propName + "` supplied to " + ("`" + componentName + "`, expected instance of `" + expectedClassName + "`."))
            }
        }

        return createChainableTypeChecker(validate)
    }

    function createEnumTypeChecker(expectedValues) {
        function validate(props, propName, componentName, location) {
            var propValue = props[propName];
            for (var i = 0; i < expectedValues.length; i++) {
                if (propValue === expectedValues[i]) {
                    return
                }
            }
            var locationName = ReactPropTypeLocationNames[location];
            var valuesString = JSON.stringify(expectedValues);
            return new Error("Invalid " + locationName + " `" + propName + "` of value `" + propValue + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."))
        }

        return createChainableTypeChecker(validate)
    }

    function createObjectOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== "object") {
                var locationName = ReactPropTypeLocationNames[location];
                return new Error("Invalid " + locationName + " `" + propName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."))
            }
            for (var key in propValue) {
                if (propValue.hasOwnProperty(key)) {
                    var error = typeChecker(propValue, key, componentName, location);
                    if (error instanceof Error) {
                        return error
                    }
                }
            }
        }

        return createChainableTypeChecker(validate)
    }

    function createUnionTypeChecker(arrayOfTypeCheckers) {
        function validate(props, propName, componentName, location) {
            for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
                var checker = arrayOfTypeCheckers[i];
                if (checker(props, propName, componentName, location) == null) {
                    return
                }
            }
            var locationName = ReactPropTypeLocationNames[location];
            return new Error("Invalid " + locationName + " `" + propName + "` supplied to " + ("`" + componentName + "`."))
        }

        return createChainableTypeChecker(validate)
    }

    function createNodeChecker() {
        function validate(props, propName, componentName, location) {
            if (!isNode(props[propName])) {
                var locationName = ReactPropTypeLocationNames[location];
                return new Error("Invalid " + locationName + " `" + propName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."))
            }
        }

        return createChainableTypeChecker(validate)
    }

    function createShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== "object") {
                var locationName = ReactPropTypeLocationNames[location];
                return new Error("Invalid " + locationName + " `" + propName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."))
            }
            for (var key in shapeTypes) {
                var checker = shapeTypes[key];
                if (!checker) {
                    continue
                }
                var error = checker(propValue, key, componentName, location);
                if (error) {
                    return error
                }
            }
        }

        return createChainableTypeChecker(validate, "expected `object`")
    }

    function isNode(propValue) {
        switch (typeof propValue) {
            case"number":
            case"string":
                return true;
            case"boolean":
                return!propValue;
            case"object":
                if (Array.isArray(propValue)) {
                    return propValue.every(isNode)
                }
                if (ReactElement.isValidElement(propValue)) {
                    return true
                }
                for (var k in propValue) {
                    if (!isNode(propValue[k])) {
                        return false
                    }
                }
                return true;
            default:
                return false
        }
    }

    function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) {
            return"array"
        }
        if (propValue instanceof RegExp) {
            return"object"
        }
        return propType
    }

    function getPreciseType(propValue) {
        var propType = getPropType(propValue);
        if (propType === "object") {
            if (propValue instanceof Date) {
                return"date"
            } else if (propValue instanceof RegExp) {
                return"regexp"
            }
        }
        return propType
    }

    module.exports = ReactPropTypes
}, {"./ReactElement": 119, "./ReactPropTypeLocationNames": 137, "./deprecated": 173, "./emptyFunction": 174}], 140: [function (require, module, exports) {
    "use strict";
    var PooledClass = require("./PooledClass");
    var ReactBrowserEventEmitter = require("./ReactBrowserEventEmitter");
    var assign = require("./Object.assign");

    function ReactPutListenerQueue() {
        this.listenersToPut = []
    }

    assign(ReactPutListenerQueue.prototype, {enqueuePutListener: function (rootNodeID, propKey, propValue) {
        this.listenersToPut.push({rootNodeID: rootNodeID, propKey: propKey, propValue: propValue})
    }, putListeners: function () {
        for (var i = 0; i < this.listenersToPut.length; i++) {
            var listenerToPut = this.listenersToPut[i];
            ReactBrowserEventEmitter.putListener(listenerToPut.rootNodeID, listenerToPut.propKey, listenerToPut.propValue)
        }
    }, reset: function () {
        this.listenersToPut.length = 0
    }, destructor: function () {
        this.reset()
    }});
    PooledClass.addPoolingTo(ReactPutListenerQueue);
    module.exports = ReactPutListenerQueue
}, {"./Object.assign": 93, "./PooledClass": 94, "./ReactBrowserEventEmitter": 97}], 141: [function (require, module, exports) {
    "use strict";
    var CallbackQueue = require("./CallbackQueue");
    var PooledClass = require("./PooledClass");
    var ReactBrowserEventEmitter = require("./ReactBrowserEventEmitter");
    var ReactInputSelection = require("./ReactInputSelection");
    var ReactPutListenerQueue = require("./ReactPutListenerQueue");
    var Transaction = require("./Transaction");
    var assign = require("./Object.assign");
    var SELECTION_RESTORATION = {initialize: ReactInputSelection.getSelectionInformation, close: ReactInputSelection.restoreSelection};
    var EVENT_SUPPRESSION = {initialize: function () {
        var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
        ReactBrowserEventEmitter.setEnabled(false);
        return currentlyEnabled
    }, close: function (previouslyEnabled) {
        ReactBrowserEventEmitter.setEnabled(previouslyEnabled)
    }};
    var ON_DOM_READY_QUEUEING = {initialize: function () {
        this.reactMountReady.reset()
    }, close: function () {
        this.reactMountReady.notifyAll()
    }};
    var PUT_LISTENER_QUEUEING = {initialize: function () {
        this.putListenerQueue.reset()
    }, close: function () {
        this.putListenerQueue.putListeners()
    }};
    var TRANSACTION_WRAPPERS = [PUT_LISTENER_QUEUEING, SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];

    function ReactReconcileTransaction() {
        this.reinitializeTransaction();
        this.renderToStaticMarkup = false;
        this.reactMountReady = CallbackQueue.getPooled(null);
        this.putListenerQueue = ReactPutListenerQueue.getPooled()
    }

    var Mixin = {getTransactionWrappers: function () {
        return TRANSACTION_WRAPPERS
    }, getReactMountReady: function () {
        return this.reactMountReady
    }, getPutListenerQueue: function () {
        return this.putListenerQueue
    }, destructor: function () {
        CallbackQueue.release(this.reactMountReady);
        this.reactMountReady = null;
        ReactPutListenerQueue.release(this.putListenerQueue);
        this.putListenerQueue = null
    }};
    assign(ReactReconcileTransaction.prototype, Transaction.Mixin, Mixin);
    PooledClass.addPoolingTo(ReactReconcileTransaction);
    module.exports = ReactReconcileTransaction
}, {"./CallbackQueue": 72, "./Object.assign": 93, "./PooledClass": 94, "./ReactBrowserEventEmitter": 97, "./ReactInputSelection": 126, "./ReactPutListenerQueue": 140, "./Transaction": 162}], 142: [function (require, module, exports) {
    "use strict";
    var ReactRootIndexInjection = {injectCreateReactRootIndex: function (_createReactRootIndex) {
        ReactRootIndex.createReactRootIndex = _createReactRootIndex
    }};
    var ReactRootIndex = {createReactRootIndex: null, injection: ReactRootIndexInjection};
    module.exports = ReactRootIndex
}, {}], 143: [function (require, module, exports) {
    "use strict";
    var ReactElement = require("./ReactElement");
    var ReactInstanceHandles = require("./ReactInstanceHandles");
    var ReactMarkupChecksum = require("./ReactMarkupChecksum");
    var ReactServerRenderingTransaction = require("./ReactServerRenderingTransaction");
    var instantiateReactComponent = require("./instantiateReactComponent");
    var invariant = require("./invariant");

    function renderToString(element) {
        "production" !== "production" ? invariant(ReactElement.isValidElement(element), "renderToString(): You must pass a valid ReactElement.") : invariant(ReactElement.isValidElement(element));
        var transaction;
        try {
            var id = ReactInstanceHandles.createReactRootID();
            transaction = ReactServerRenderingTransaction.getPooled(false);
            return transaction.perform(function () {
                var componentInstance = instantiateReactComponent(element, null);
                var markup = componentInstance.mountComponent(id, transaction, 0);
                return ReactMarkupChecksum.addChecksumToMarkup(markup)
            }, null)
        } finally {
            ReactServerRenderingTransaction.release(transaction)
        }
    }

    function renderToStaticMarkup(element) {
        "production" !== "production" ? invariant(ReactElement.isValidElement(element), "renderToStaticMarkup(): You must pass a valid ReactElement.") : invariant(ReactElement.isValidElement(element));
        var transaction;
        try {
            var id = ReactInstanceHandles.createReactRootID();
            transaction = ReactServerRenderingTransaction.getPooled(true);
            return transaction.perform(function () {
                var componentInstance = instantiateReactComponent(element, null);
                return componentInstance.mountComponent(id, transaction, 0)
            }, null)
        } finally {
            ReactServerRenderingTransaction.release(transaction)
        }
    }

    module.exports = {renderToString: renderToString, renderToStaticMarkup: renderToStaticMarkup}
}, {"./ReactElement": 119, "./ReactInstanceHandles": 127, "./ReactMarkupChecksum": 129, "./ReactServerRenderingTransaction": 144, "./instantiateReactComponent": 192, "./invariant": 193}], 144: [function (require, module, exports) {
    "use strict";
    var PooledClass = require("./PooledClass");
    var CallbackQueue = require("./CallbackQueue");
    var ReactPutListenerQueue = require("./ReactPutListenerQueue");
    var Transaction = require("./Transaction");
    var assign = require("./Object.assign");
    var emptyFunction = require("./emptyFunction");
    var ON_DOM_READY_QUEUEING = {initialize: function () {
        this.reactMountReady.reset()
    }, close: emptyFunction};
    var PUT_LISTENER_QUEUEING = {initialize: function () {
        this.putListenerQueue.reset()
    }, close: emptyFunction};
    var TRANSACTION_WRAPPERS = [PUT_LISTENER_QUEUEING, ON_DOM_READY_QUEUEING];

    function ReactServerRenderingTransaction(renderToStaticMarkup) {
        this.reinitializeTransaction();
        this.renderToStaticMarkup = renderToStaticMarkup;
        this.reactMountReady = CallbackQueue.getPooled(null);
        this.putListenerQueue = ReactPutListenerQueue.getPooled()
    }

    var Mixin = {getTransactionWrappers: function () {
        return TRANSACTION_WRAPPERS
    }, getReactMountReady: function () {
        return this.reactMountReady
    }, getPutListenerQueue: function () {
        return this.putListenerQueue
    }, destructor: function () {
        CallbackQueue.release(this.reactMountReady);
        this.reactMountReady = null;
        ReactPutListenerQueue.release(this.putListenerQueue);
        this.putListenerQueue = null
    }};
    assign(ReactServerRenderingTransaction.prototype, Transaction.Mixin, Mixin);
    PooledClass.addPoolingTo(ReactServerRenderingTransaction);
    module.exports = ReactServerRenderingTransaction
}, {"./CallbackQueue": 72, "./Object.assign": 93, "./PooledClass": 94, "./ReactPutListenerQueue": 140, "./Transaction": 162, "./emptyFunction": 174}], 145: [function (require, module, exports) {
    "use strict";
    var DOMPropertyOperations = require("./DOMPropertyOperations");
    var ReactComponent = require("./ReactComponent");
    var ReactElement = require("./ReactElement");
    var assign = require("./Object.assign");
    var escapeTextForBrowser = require("./escapeTextForBrowser");
    var ReactTextComponent = function (props) {
    };
    assign(ReactTextComponent.prototype, ReactComponent.Mixin, {mountComponent: function (rootID, transaction, mountDepth) {
        ReactComponent.Mixin.mountComponent.call(this, rootID, transaction, mountDepth);
        var escapedText = escapeTextForBrowser(this.props);
        if (transaction.renderToStaticMarkup) {
            return escapedText
        }
        return"<span " + DOMPropertyOperations.createMarkupForID(rootID) + ">" + escapedText + "</span>"
    }, receiveComponent: function (nextComponent, transaction) {
        var nextProps = nextComponent.props;
        if (nextProps !== this.props) {
            this.props = nextProps;
            ReactComponent.BackendIDOperations.updateTextContentByID(this._rootNodeID, nextProps)
        }
    }});
    var ReactTextComponentFactory = function (text) {
        return new ReactElement(ReactTextComponent, null, null, null, null, text)
    };
    ReactTextComponentFactory.type = ReactTextComponent;
    module.exports = ReactTextComponentFactory
}, {"./DOMPropertyOperations": 78, "./Object.assign": 93, "./ReactComponent": 99, "./ReactElement": 119, "./escapeTextForBrowser": 176}], 146: [function (require, module, exports) {
    "use strict";
    var CallbackQueue = require("./CallbackQueue");
    var PooledClass = require("./PooledClass");
    var ReactCurrentOwner = require("./ReactCurrentOwner");
    var ReactPerf = require("./ReactPerf");
    var Transaction = require("./Transaction");
    var assign = require("./Object.assign");
    var invariant = require("./invariant");
    var warning = require("./warning");
    var dirtyComponents = [];
    var asapCallbackQueue = CallbackQueue.getPooled();
    var asapEnqueued = false;
    var batchingStrategy = null;

    function ensureInjected() {
        "production" !== "production" ? invariant(ReactUpdates.ReactReconcileTransaction && batchingStrategy, "ReactUpdates: must inject a reconcile transaction class and batching " + "strategy") : invariant(ReactUpdates.ReactReconcileTransaction && batchingStrategy)
    }

    var NESTED_UPDATES = {initialize: function () {
        this.dirtyComponentsLength = dirtyComponents.length
    }, close: function () {
        if (this.dirtyComponentsLength !== dirtyComponents.length) {
            dirtyComponents.splice(0, this.dirtyComponentsLength);
            flushBatchedUpdates()
        } else {
            dirtyComponents.length = 0
        }
    }};
    var UPDATE_QUEUEING = {initialize: function () {
        this.callbackQueue.reset()
    }, close: function () {
        this.callbackQueue.notifyAll()
    }};
    var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];

    function ReactUpdatesFlushTransaction() {
        this.reinitializeTransaction();
        this.dirtyComponentsLength = null;
        this.callbackQueue = CallbackQueue.getPooled();
        this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled()
    }

    assign(ReactUpdatesFlushTransaction.prototype, Transaction.Mixin, {getTransactionWrappers: function () {
        return TRANSACTION_WRAPPERS
    }, destructor: function () {
        this.dirtyComponentsLength = null;
        CallbackQueue.release(this.callbackQueue);
        this.callbackQueue = null;
        ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
        this.reconcileTransaction = null
    }, perform: function (method, scope, a) {
        return Transaction.Mixin.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a)
    }});
    PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);
    function batchedUpdates(callback, a, b) {
        ensureInjected();
        batchingStrategy.batchedUpdates(callback, a, b)
    }

    function mountDepthComparator(c1, c2) {
        return c1._mountDepth - c2._mountDepth
    }

    function runBatchedUpdates(transaction) {
        var len = transaction.dirtyComponentsLength;
        "production" !== "production" ? invariant(len === dirtyComponents.length, "Expected flush transaction's stored dirty-components length (%s) to " + "match dirty-components array length (%s).", len, dirtyComponents.length) : invariant(len === dirtyComponents.length);
        dirtyComponents.sort(mountDepthComparator);
        for (var i = 0; i < len; i++) {
            var component = dirtyComponents[i];
            if (component.isMounted()) {
                var callbacks = component._pendingCallbacks;
                component._pendingCallbacks = null;
                component.performUpdateIfNecessary(transaction.reconcileTransaction);
                if (callbacks) {
                    for (var j = 0; j < callbacks.length; j++) {
                        transaction.callbackQueue.enqueue(callbacks[j], component)
                    }
                }
            }
        }
    }

    var flushBatchedUpdates = ReactPerf.measure("ReactUpdates", "flushBatchedUpdates", function () {
        while (dirtyComponents.length || asapEnqueued) {
            if (dirtyComponents.length) {
                var transaction = ReactUpdatesFlushTransaction.getPooled();
                transaction.perform(runBatchedUpdates, null, transaction);
                ReactUpdatesFlushTransaction.release(transaction)
            }
            if (asapEnqueued) {
                asapEnqueued = false;
                var queue = asapCallbackQueue;
                asapCallbackQueue = CallbackQueue.getPooled();
                queue.notifyAll();
                CallbackQueue.release(queue)
            }
        }
    });

    function enqueueUpdate(component, callback) {
        "production" !== "production" ? invariant(!callback || typeof callback === "function", "enqueueUpdate(...): You called `setProps`, `replaceProps`, " + "`setState`, `replaceState`, or `forceUpdate` with a callback that " + "isn't callable.") : invariant(!callback || typeof callback === "function");
        ensureInjected();
        "production" !== "production" ? warning(ReactCurrentOwner.current == null, "enqueueUpdate(): Render methods should be a pure function of props " + "and state; triggering nested component updates from render is not " + "allowed. If necessary, trigger nested updates in " + "componentDidUpdate.") : null;
        if (!batchingStrategy.isBatchingUpdates) {
            batchingStrategy.batchedUpdates(enqueueUpdate, component, callback);
            return
        }
        dirtyComponents.push(component);
        if (callback) {
            if (component._pendingCallbacks) {
                component._pendingCallbacks.push(callback)
            } else {
                component._pendingCallbacks = [callback]
            }
        }
    }

    function asap(callback, context) {
        "production" !== "production" ? invariant(batchingStrategy.isBatchingUpdates, "ReactUpdates.asap: Can't enqueue an asap callback in a context where" + "updates are not being batched.") : invariant(batchingStrategy.isBatchingUpdates);
        asapCallbackQueue.enqueue(callback, context);
        asapEnqueued = true
    }

    var ReactUpdatesInjection = {injectReconcileTransaction: function (ReconcileTransaction) {
        "production" !== "production" ? invariant(ReconcileTransaction, "ReactUpdates: must provide a reconcile transaction class") : invariant(ReconcileTransaction);
        ReactUpdates.ReactReconcileTransaction = ReconcileTransaction
    }, injectBatchingStrategy: function (_batchingStrategy) {
        "production" !== "production" ? invariant(_batchingStrategy, "ReactUpdates: must provide a batching strategy") : invariant(_batchingStrategy);
        "production" !== "production" ? invariant(typeof _batchingStrategy.batchedUpdates === "function", "ReactUpdates: must provide a batchedUpdates() function") : invariant(typeof _batchingStrategy.batchedUpdates === "function");
        "production" !== "production" ? invariant(typeof _batchingStrategy.isBatchingUpdates === "boolean", "ReactUpdates: must provide an isBatchingUpdates boolean attribute") : invariant(typeof _batchingStrategy.isBatchingUpdates === "boolean");
        batchingStrategy = _batchingStrategy
    }};
    var ReactUpdates = {ReactReconcileTransaction: null, batchedUpdates: batchedUpdates, enqueueUpdate: enqueueUpdate, flushBatchedUpdates: flushBatchedUpdates, injection: ReactUpdatesInjection, asap: asap};
    module.exports = ReactUpdates
}, {"./CallbackQueue": 72, "./Object.assign": 93, "./PooledClass": 94, "./ReactCurrentOwner": 103, "./ReactPerf": 135, "./Transaction": 162, "./invariant": 193, "./warning": 212}], 147: [function (require, module, exports) {
    "use strict";
    var DOMProperty = require("./DOMProperty");
    var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;
    var SVGDOMPropertyConfig = {Properties: {cx: MUST_USE_ATTRIBUTE, cy: MUST_USE_ATTRIBUTE, d: MUST_USE_ATTRIBUTE, dx: MUST_USE_ATTRIBUTE, dy: MUST_USE_ATTRIBUTE, fill: MUST_USE_ATTRIBUTE, fillOpacity: MUST_USE_ATTRIBUTE, fontFamily: MUST_USE_ATTRIBUTE, fontSize: MUST_USE_ATTRIBUTE, fx: MUST_USE_ATTRIBUTE, fy: MUST_USE_ATTRIBUTE, gradientTransform: MUST_USE_ATTRIBUTE, gradientUnits: MUST_USE_ATTRIBUTE, markerEnd: MUST_USE_ATTRIBUTE, markerMid: MUST_USE_ATTRIBUTE, markerStart: MUST_USE_ATTRIBUTE, offset: MUST_USE_ATTRIBUTE, opacity: MUST_USE_ATTRIBUTE, patternContentUnits: MUST_USE_ATTRIBUTE, patternUnits: MUST_USE_ATTRIBUTE, points: MUST_USE_ATTRIBUTE, preserveAspectRatio: MUST_USE_ATTRIBUTE, r: MUST_USE_ATTRIBUTE, rx: MUST_USE_ATTRIBUTE, ry: MUST_USE_ATTRIBUTE, spreadMethod: MUST_USE_ATTRIBUTE, stopColor: MUST_USE_ATTRIBUTE, stopOpacity: MUST_USE_ATTRIBUTE, stroke: MUST_USE_ATTRIBUTE, strokeDasharray: MUST_USE_ATTRIBUTE, strokeLinecap: MUST_USE_ATTRIBUTE, strokeOpacity: MUST_USE_ATTRIBUTE, strokeWidth: MUST_USE_ATTRIBUTE, textAnchor: MUST_USE_ATTRIBUTE, transform: MUST_USE_ATTRIBUTE, version: MUST_USE_ATTRIBUTE, viewBox: MUST_USE_ATTRIBUTE, x1: MUST_USE_ATTRIBUTE, x2: MUST_USE_ATTRIBUTE, x: MUST_USE_ATTRIBUTE, y1: MUST_USE_ATTRIBUTE, y2: MUST_USE_ATTRIBUTE, y: MUST_USE_ATTRIBUTE}, DOMAttributeNames: {fillOpacity: "fill-opacity", fontFamily: "font-family", fontSize: "font-size", gradientTransform: "gradientTransform", gradientUnits: "gradientUnits", markerEnd: "marker-end", markerMid: "marker-mid", markerStart: "marker-start", patternContentUnits: "patternContentUnits", patternUnits: "patternUnits", preserveAspectRatio: "preserveAspectRatio", spreadMethod: "spreadMethod", stopColor: "stop-color", stopOpacity: "stop-opacity", strokeDasharray: "stroke-dasharray", strokeLinecap: "stroke-linecap", strokeOpacity: "stroke-opacity", strokeWidth: "stroke-width", textAnchor: "text-anchor", viewBox: "viewBox"}};
    module.exports = SVGDOMPropertyConfig
}, {"./DOMProperty": 77}], 148: [function (require, module, exports) {
    "use strict";
    var EventConstants = require("./EventConstants");
    var EventPropagators = require("./EventPropagators");
    var ReactInputSelection = require("./ReactInputSelection");
    var SyntheticEvent = require("./SyntheticEvent");
    var getActiveElement = require("./getActiveElement");
    var isTextInputElement = require("./isTextInputElement");
    var keyOf = require("./keyOf");
    var shallowEqual = require("./shallowEqual");
    var topLevelTypes = EventConstants.topLevelTypes;
    var eventTypes = {select: {phasedRegistrationNames: {bubbled: keyOf({onSelect: null}), captured: keyOf({onSelectCapture: null})}, dependencies: [topLevelTypes.topBlur, topLevelTypes.topContextMenu, topLevelTypes.topFocus, topLevelTypes.topKeyDown, topLevelTypes.topMouseDown, topLevelTypes.topMouseUp, topLevelTypes.topSelectionChange]}};
    var activeElement = null;
    var activeElementID = null;
    var lastSelection = null;
    var mouseDown = false;

    function getSelection(node) {
        if ("selectionStart"in node && ReactInputSelection.hasSelectionCapabilities(node)) {
            return{start: node.selectionStart, end: node.selectionEnd}
        } else if (window.getSelection) {
            var selection = window.getSelection();
            return{anchorNode: selection.anchorNode, anchorOffset: selection.anchorOffset, focusNode: selection.focusNode, focusOffset: selection.focusOffset}
        } else if (document.selection) {
            var range = document.selection.createRange();
            return{parentElement: range.parentElement(), text: range.text, top: range.boundingTop, left: range.boundingLeft}
        }
    }

    function constructSelectEvent(nativeEvent) {
        if (mouseDown || activeElement == null || activeElement != getActiveElement()) {
            return
        }
        var currentSelection = getSelection(activeElement);
        if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
            lastSelection = currentSelection;
            var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementID, nativeEvent);
            syntheticEvent.type = "select";
            syntheticEvent.target = activeElement;
            EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);
            return syntheticEvent
        }
    }

    var SelectEventPlugin = {eventTypes: eventTypes, extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
        switch (topLevelType) {
            case topLevelTypes.topFocus:
                if (isTextInputElement(topLevelTarget) || topLevelTarget.contentEditable === "true") {
                    activeElement = topLevelTarget;
                    activeElementID = topLevelTargetID;
                    lastSelection = null
                }
                break;
            case topLevelTypes.topBlur:
                activeElement = null;
                activeElementID = null;
                lastSelection = null;
                break;
            case topLevelTypes.topMouseDown:
                mouseDown = true;
                break;
            case topLevelTypes.topContextMenu:
            case topLevelTypes.topMouseUp:
                mouseDown = false;
                return constructSelectEvent(nativeEvent);
            case topLevelTypes.topSelectionChange:
            case topLevelTypes.topKeyDown:
            case topLevelTypes.topKeyUp:
                return constructSelectEvent(nativeEvent)
        }
    }};
    module.exports = SelectEventPlugin
}, {"./EventConstants": 82, "./EventPropagators": 87, "./ReactInputSelection": 126, "./SyntheticEvent": 154, "./getActiveElement": 180, "./isTextInputElement": 196, "./keyOf": 200, "./shallowEqual": 208}], 149: [function (require, module, exports) {
    "use strict";
    var GLOBAL_MOUNT_POINT_MAX = Math.pow(2, 53);
    var ServerReactRootIndex = {createReactRootIndex: function () {
        return Math.ceil(Math.random() * GLOBAL_MOUNT_POINT_MAX)
    }};
    module.exports = ServerReactRootIndex
}, {}], 150: [function (require, module, exports) {
    "use strict";
    var EventConstants = require("./EventConstants");
    var EventPluginUtils = require("./EventPluginUtils");
    var EventPropagators = require("./EventPropagators");
    var SyntheticClipboardEvent = require("./SyntheticClipboardEvent");
    var SyntheticEvent = require("./SyntheticEvent");
    var SyntheticFocusEvent = require("./SyntheticFocusEvent");
    var SyntheticKeyboardEvent = require("./SyntheticKeyboardEvent");
    var SyntheticMouseEvent = require("./SyntheticMouseEvent");
    var SyntheticDragEvent = require("./SyntheticDragEvent");
    var SyntheticTouchEvent = require("./SyntheticTouchEvent");
    var SyntheticUIEvent = require("./SyntheticUIEvent");
    var SyntheticWheelEvent = require("./SyntheticWheelEvent");
    var getEventCharCode = require("./getEventCharCode");
    var invariant = require("./invariant");
    var keyOf = require("./keyOf");
    var warning = require("./warning");
    var topLevelTypes = EventConstants.topLevelTypes;
    var eventTypes = {blur: {phasedRegistrationNames: {bubbled: keyOf({onBlur: true}), captured: keyOf({onBlurCapture: true})}}, click: {phasedRegistrationNames: {bubbled: keyOf({onClick: true}), captured: keyOf({onClickCapture: true})}}, contextMenu: {phasedRegistrationNames: {bubbled: keyOf({onContextMenu: true}), captured: keyOf({onContextMenuCapture: true})}}, copy: {phasedRegistrationNames: {bubbled: keyOf({onCopy: true}), captured: keyOf({onCopyCapture: true})}}, cut: {phasedRegistrationNames: {bubbled: keyOf({onCut: true}), captured: keyOf({onCutCapture: true})}}, doubleClick: {phasedRegistrationNames: {bubbled: keyOf({onDoubleClick: true}), captured: keyOf({onDoubleClickCapture: true})}}, drag: {phasedRegistrationNames: {bubbled: keyOf({onDrag: true}), captured: keyOf({onDragCapture: true})}}, dragEnd: {phasedRegistrationNames: {bubbled: keyOf({onDragEnd: true}), captured: keyOf({onDragEndCapture: true})}}, dragEnter: {phasedRegistrationNames: {bubbled: keyOf({onDragEnter: true}), captured: keyOf({onDragEnterCapture: true})}}, dragExit: {phasedRegistrationNames: {bubbled: keyOf({onDragExit: true}), captured: keyOf({onDragExitCapture: true})}}, dragLeave: {phasedRegistrationNames: {bubbled: keyOf({onDragLeave: true}), captured: keyOf({onDragLeaveCapture: true})}}, dragOver: {phasedRegistrationNames: {bubbled: keyOf({onDragOver: true}), captured: keyOf({onDragOverCapture: true})}}, dragStart: {phasedRegistrationNames: {bubbled: keyOf({onDragStart: true}), captured: keyOf({onDragStartCapture: true})}}, drop: {phasedRegistrationNames: {bubbled: keyOf({onDrop: true}), captured: keyOf({onDropCapture: true})}}, focus: {phasedRegistrationNames: {bubbled: keyOf({onFocus: true}), captured: keyOf({onFocusCapture: true})}}, input: {phasedRegistrationNames: {bubbled: keyOf({onInput: true}), captured: keyOf({onInputCapture: true})}}, keyDown: {phasedRegistrationNames: {bubbled: keyOf({onKeyDown: true}), captured: keyOf({onKeyDownCapture: true})}}, keyPress: {phasedRegistrationNames: {bubbled: keyOf({onKeyPress: true}), captured: keyOf({onKeyPressCapture: true})}}, keyUp: {phasedRegistrationNames: {bubbled: keyOf({onKeyUp: true}), captured: keyOf({onKeyUpCapture: true})}}, load: {phasedRegistrationNames: {bubbled: keyOf({onLoad: true}), captured: keyOf({onLoadCapture: true})}}, error: {phasedRegistrationNames: {bubbled: keyOf({onError: true}), captured: keyOf({onErrorCapture: true})}}, mouseDown: {phasedRegistrationNames: {bubbled: keyOf({onMouseDown: true}), captured: keyOf({onMouseDownCapture: true})}}, mouseMove: {phasedRegistrationNames: {bubbled: keyOf({onMouseMove: true}), captured: keyOf({onMouseMoveCapture: true})}}, mouseOut: {phasedRegistrationNames: {bubbled: keyOf({onMouseOut: true}), captured: keyOf({onMouseOutCapture: true})}}, mouseOver: {phasedRegistrationNames: {bubbled: keyOf({onMouseOver: true}), captured: keyOf({onMouseOverCapture: true})}}, mouseUp: {phasedRegistrationNames: {bubbled: keyOf({onMouseUp: true}), captured: keyOf({onMouseUpCapture: true})}}, paste: {phasedRegistrationNames: {bubbled: keyOf({onPaste: true}), captured: keyOf({onPasteCapture: true})}}, reset: {phasedRegistrationNames: {bubbled: keyOf({onReset: true}), captured: keyOf({onResetCapture: true})}}, scroll: {phasedRegistrationNames: {bubbled: keyOf({onScroll: true}), captured: keyOf({onScrollCapture: true})}}, submit: {phasedRegistrationNames: {bubbled: keyOf({onSubmit: true}), captured: keyOf({onSubmitCapture: true})}}, touchCancel: {phasedRegistrationNames: {bubbled: keyOf({onTouchCancel: true}), captured: keyOf({onTouchCancelCapture: true})}}, touchEnd: {phasedRegistrationNames: {bubbled: keyOf({onTouchEnd: true}), captured: keyOf({onTouchEndCapture: true})}}, touchMove: {phasedRegistrationNames: {bubbled: keyOf({onTouchMove: true}), captured: keyOf({onTouchMoveCapture: true})}}, touchStart: {phasedRegistrationNames: {bubbled: keyOf({onTouchStart: true}), captured: keyOf({onTouchStartCapture: true})}}, wheel: {phasedRegistrationNames: {bubbled: keyOf({onWheel: true}), captured: keyOf({onWheelCapture: true})}}};
    var topLevelEventsToDispatchConfig = {topBlur: eventTypes.blur, topClick: eventTypes.click, topContextMenu: eventTypes.contextMenu, topCopy: eventTypes.copy, topCut: eventTypes.cut, topDoubleClick: eventTypes.doubleClick, topDrag: eventTypes.drag, topDragEnd: eventTypes.dragEnd, topDragEnter: eventTypes.dragEnter, topDragExit: eventTypes.dragExit, topDragLeave: eventTypes.dragLeave, topDragOver: eventTypes.dragOver, topDragStart: eventTypes.dragStart, topDrop: eventTypes.drop, topError: eventTypes.error, topFocus: eventTypes.focus, topInput: eventTypes.input, topKeyDown: eventTypes.keyDown, topKeyPress: eventTypes.keyPress, topKeyUp: eventTypes.keyUp, topLoad: eventTypes.load, topMouseDown: eventTypes.mouseDown, topMouseMove: eventTypes.mouseMove, topMouseOut: eventTypes.mouseOut, topMouseOver: eventTypes.mouseOver, topMouseUp: eventTypes.mouseUp, topPaste: eventTypes.paste, topReset: eventTypes.reset, topScroll: eventTypes.scroll, topSubmit: eventTypes.submit, topTouchCancel: eventTypes.touchCancel, topTouchEnd: eventTypes.touchEnd, topTouchMove: eventTypes.touchMove, topTouchStart: eventTypes.touchStart, topWheel: eventTypes.wheel};
    for (var topLevelType in topLevelEventsToDispatchConfig) {
        topLevelEventsToDispatchConfig[topLevelType].dependencies = [topLevelType]
    }
    var SimpleEventPlugin = {eventTypes: eventTypes, executeDispatch: function (event, listener, domID) {
        var returnValue = EventPluginUtils.executeDispatch(event, listener, domID);
        "production" !== "production" ? warning(typeof returnValue !== "boolean", "Returning `false` from an event handler is deprecated and will be " + "ignored in a future release. Instead, manually call " + "e.stopPropagation() or e.preventDefault(), as appropriate.") : null;
        if (returnValue === false) {
            event.stopPropagation();
            event.preventDefault()
        }
    }, extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
        var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
        if (!dispatchConfig) {
            return null
        }
        var EventConstructor;
        switch (topLevelType) {
            case topLevelTypes.topInput:
            case topLevelTypes.topLoad:
            case topLevelTypes.topError:
            case topLevelTypes.topReset:
            case topLevelTypes.topSubmit:
                EventConstructor = SyntheticEvent;
                break;
            case topLevelTypes.topKeyPress:
                if (getEventCharCode(nativeEvent) === 0) {
                    return null
                }
            case topLevelTypes.topKeyDown:
            case topLevelTypes.topKeyUp:
                EventConstructor = SyntheticKeyboardEvent;
                break;
            case topLevelTypes.topBlur:
            case topLevelTypes.topFocus:
                EventConstructor = SyntheticFocusEvent;
                break;
            case topLevelTypes.topClick:
                if (nativeEvent.button === 2) {
                    return null
                }
            case topLevelTypes.topContextMenu:
            case topLevelTypes.topDoubleClick:
            case topLevelTypes.topMouseDown:
            case topLevelTypes.topMouseMove:
            case topLevelTypes.topMouseOut:
            case topLevelTypes.topMouseOver:
            case topLevelTypes.topMouseUp:
                EventConstructor = SyntheticMouseEvent;
                break;
            case topLevelTypes.topDrag:
            case topLevelTypes.topDragEnd:
            case topLevelTypes.topDragEnter:
            case topLevelTypes.topDragExit:
            case topLevelTypes.topDragLeave:
            case topLevelTypes.topDragOver:
            case topLevelTypes.topDragStart:
            case topLevelTypes.topDrop:
                EventConstructor = SyntheticDragEvent;
                break;
            case topLevelTypes.topTouchCancel:
            case topLevelTypes.topTouchEnd:
            case topLevelTypes.topTouchMove:
            case topLevelTypes.topTouchStart:
                EventConstructor = SyntheticTouchEvent;
                break;
            case topLevelTypes.topScroll:
                EventConstructor = SyntheticUIEvent;
                break;
            case topLevelTypes.topWheel:
                EventConstructor = SyntheticWheelEvent;
                break;
            case topLevelTypes.topCopy:
            case topLevelTypes.topCut:
            case topLevelTypes.topPaste:
                EventConstructor = SyntheticClipboardEvent;
                break
        }
        "production" !== "production" ? invariant(EventConstructor, "SimpleEventPlugin: Unhandled event type, `%s`.", topLevelType) : invariant(EventConstructor);
        var event = EventConstructor.getPooled(dispatchConfig, topLevelTargetID, nativeEvent);
        EventPropagators.accumulateTwoPhaseDispatches(event);
        return event
    }};
    module.exports = SimpleEventPlugin
}, {"./EventConstants": 82, "./EventPluginUtils": 86, "./EventPropagators": 87, "./SyntheticClipboardEvent": 151, "./SyntheticDragEvent": 153, "./SyntheticEvent": 154, "./SyntheticFocusEvent": 155, "./SyntheticKeyboardEvent": 157, "./SyntheticMouseEvent": 158, "./SyntheticTouchEvent": 159, "./SyntheticUIEvent": 160, "./SyntheticWheelEvent": 161, "./getEventCharCode": 181, "./invariant": 193, "./keyOf": 200, "./warning": 212}], 151: [function (require, module, exports) {
    "use strict";
    var SyntheticEvent = require("./SyntheticEvent");
    var ClipboardEventInterface = {clipboardData: function (event) {
        return"clipboardData"in event ? event.clipboardData : window.clipboardData
    }};

    function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent) {
        SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent)
    }

    SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);
    module.exports = SyntheticClipboardEvent
}, {"./SyntheticEvent": 154}], 152: [function (require, module, exports) {
    "use strict";
    var SyntheticEvent = require("./SyntheticEvent");
    var CompositionEventInterface = {data: null};

    function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent) {
        SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent)
    }

    SyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);
    module.exports = SyntheticCompositionEvent
}, {"./SyntheticEvent": 154}], 153: [function (require, module, exports) {
    "use strict";
    var SyntheticMouseEvent = require("./SyntheticMouseEvent");
    var DragEventInterface = {dataTransfer: null};

    function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent) {
        SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent)
    }

    SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);
    module.exports = SyntheticDragEvent
}, {"./SyntheticMouseEvent": 158}], 154: [function (require, module, exports) {
    "use strict";
    var PooledClass = require("./PooledClass");
    var assign = require("./Object.assign");
    var emptyFunction = require("./emptyFunction");
    var getEventTarget = require("./getEventTarget");
    var EventInterface = {type: null, target: getEventTarget, currentTarget: emptyFunction.thatReturnsNull, eventPhase: null, bubbles: null, cancelable: null, timeStamp: function (event) {
        return event.timeStamp || Date.now()
    }, defaultPrevented: null, isTrusted: null};

    function SyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent) {
        this.dispatchConfig = dispatchConfig;
        this.dispatchMarker = dispatchMarker;
        this.nativeEvent = nativeEvent;
        var Interface = this.constructor.Interface;
        for (var propName in Interface) {
            if (!Interface.hasOwnProperty(propName)) {
                continue
            }
            var normalize = Interface[propName];
            if (normalize) {
                this[propName] = normalize(nativeEvent)
            } else {
                this[propName] = nativeEvent[propName]
            }
        }
        var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
        if (defaultPrevented) {
            this.isDefaultPrevented = emptyFunction.thatReturnsTrue
        } else {
            this.isDefaultPrevented = emptyFunction.thatReturnsFalse
        }
        this.isPropagationStopped = emptyFunction.thatReturnsFalse
    }

    assign(SyntheticEvent.prototype, {preventDefault: function () {
        this.defaultPrevented = true;
        var event = this.nativeEvent;
        event.preventDefault ? event.preventDefault() : event.returnValue = false;
        this.isDefaultPrevented = emptyFunction.thatReturnsTrue
    }, stopPropagation: function () {
        var event = this.nativeEvent;
        event.stopPropagation ? event.stopPropagation() : event.cancelBubble = true;
        this.isPropagationStopped = emptyFunction.thatReturnsTrue
    }, persist: function () {
        this.isPersistent = emptyFunction.thatReturnsTrue
    }, isPersistent: emptyFunction.thatReturnsFalse, destructor: function () {
        var Interface = this.constructor.Interface;
        for (var propName in Interface) {
            this[propName] = null
        }
        this.dispatchConfig = null;
        this.dispatchMarker = null;
        this.nativeEvent = null
    }});
    SyntheticEvent.Interface = EventInterface;
    SyntheticEvent.augmentClass = function (Class, Interface) {
        var Super = this;
        var prototype = Object.create(Super.prototype);
        assign(prototype, Class.prototype);
        Class.prototype = prototype;
        Class.prototype.constructor = Class;
        Class.Interface = assign({}, Super.Interface, Interface);
        Class.augmentClass = Super.augmentClass;
        PooledClass.addPoolingTo(Class, PooledClass.threeArgumentPooler)
    };
    PooledClass.addPoolingTo(SyntheticEvent, PooledClass.threeArgumentPooler);
    module.exports = SyntheticEvent
}, {"./Object.assign": 93, "./PooledClass": 94, "./emptyFunction": 174, "./getEventTarget": 184}], 155: [function (require, module, exports) {
    "use strict";
    var SyntheticUIEvent = require("./SyntheticUIEvent");
    var FocusEventInterface = {relatedTarget: null};

    function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent) {
        SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent)
    }

    SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);
    module.exports = SyntheticFocusEvent
}, {"./SyntheticUIEvent": 160}], 156: [function (require, module, exports) {
    "use strict";
    var SyntheticEvent = require("./SyntheticEvent");
    var InputEventInterface = {data: null};

    function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent) {
        SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent)
    }

    SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);
    module.exports = SyntheticInputEvent
}, {"./SyntheticEvent": 154}], 157: [function (require, module, exports) {
    "use strict";
    var SyntheticUIEvent = require("./SyntheticUIEvent");
    var getEventCharCode = require("./getEventCharCode");
    var getEventKey = require("./getEventKey");
    var getEventModifierState = require("./getEventModifierState");
    var KeyboardEventInterface = {key: getEventKey, location: null, ctrlKey: null, shiftKey: null, altKey: null, metaKey: null, repeat: null, locale: null, getModifierState: getEventModifierState, charCode: function (event) {
        if (event.type === "keypress") {
            return getEventCharCode(event)
        }
        return 0
    }, keyCode: function (event) {
        if (event.type === "keydown" || event.type === "keyup") {
            return event.keyCode
        }
        return 0
    }, which: function (event) {
        if (event.type === "keypress") {
            return getEventCharCode(event)
        }
        if (event.type === "keydown" || event.type === "keyup") {
            return event.keyCode
        }
        return 0
    }};

    function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent) {
        SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent)
    }

    SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);
    module.exports = SyntheticKeyboardEvent
}, {"./SyntheticUIEvent": 160, "./getEventCharCode": 181, "./getEventKey": 182, "./getEventModifierState": 183}], 158: [function (require, module, exports) {
    "use strict";
    var SyntheticUIEvent = require("./SyntheticUIEvent");
    var ViewportMetrics = require("./ViewportMetrics");
    var getEventModifierState = require("./getEventModifierState");
    var MouseEventInterface = {screenX: null, screenY: null, clientX: null, clientY: null, ctrlKey: null, shiftKey: null, altKey: null, metaKey: null, getModifierState: getEventModifierState, button: function (event) {
        var button = event.button;
        if ("which"in event) {
            return button
        }
        return button === 2 ? 2 : button === 4 ? 1 : 0
    }, buttons: null, relatedTarget: function (event) {
        return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement)
    }, pageX: function (event) {
        return"pageX"in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft
    }, pageY: function (event) {
        return"pageY"in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop
    }};

    function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent) {
        SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent)
    }

    SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);
    module.exports = SyntheticMouseEvent
}, {"./SyntheticUIEvent": 160, "./ViewportMetrics": 163, "./getEventModifierState": 183}], 159: [function (require, module, exports) {
    "use strict";
    var SyntheticUIEvent = require("./SyntheticUIEvent");
    var getEventModifierState = require("./getEventModifierState");
    var TouchEventInterface = {touches: null, targetTouches: null, changedTouches: null, altKey: null, metaKey: null, ctrlKey: null, shiftKey: null, getModifierState: getEventModifierState};

    function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent) {
        SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent)
    }

    SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);
    module.exports = SyntheticTouchEvent
}, {"./SyntheticUIEvent": 160, "./getEventModifierState": 183}], 160: [function (require, module, exports) {
    "use strict";
    var SyntheticEvent = require("./SyntheticEvent");
    var getEventTarget = require("./getEventTarget");
    var UIEventInterface = {view: function (event) {
        if (event.view) {
            return event.view
        }
        var target = getEventTarget(event);
        if (target != null && target.window === target) {
            return target
        }
        var doc = target.ownerDocument;
        if (doc) {
            return doc.defaultView || doc.parentWindow
        } else {
            return window
        }
    }, detail: function (event) {
        return event.detail || 0
    }};

    function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent) {
        SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent)
    }

    SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);
    module.exports = SyntheticUIEvent
}, {"./SyntheticEvent": 154, "./getEventTarget": 184}], 161: [function (require, module, exports) {
    "use strict";
    var SyntheticMouseEvent = require("./SyntheticMouseEvent");
    var WheelEventInterface = {deltaX: function (event) {
        return"deltaX"in event ? event.deltaX : "wheelDeltaX"in event ? -event.wheelDeltaX : 0
    }, deltaY: function (event) {
        return"deltaY"in event ? event.deltaY : "wheelDeltaY"in event ? -event.wheelDeltaY : "wheelDelta"in event ? -event.wheelDelta : 0
    }, deltaZ: null, deltaMode: null};

    function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent) {
        SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent)
    }

    SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);
    module.exports = SyntheticWheelEvent
}, {"./SyntheticMouseEvent": 158}], 162: [function (require, module, exports) {
    "use strict";
    var invariant = require("./invariant");
    var Mixin = {reinitializeTransaction: function () {
        this.transactionWrappers = this.getTransactionWrappers();
        if (!this.wrapperInitData) {
            this.wrapperInitData = []
        } else {
            this.wrapperInitData.length = 0
        }
        this._isInTransaction = false
    }, _isInTransaction: false, getTransactionWrappers: null, isInTransaction: function () {
        return!!this._isInTransaction
    }, perform: function (method, scope, a, b, c, d, e, f) {
        "production" !== "production" ? invariant(!this.isInTransaction(), "Transaction.perform(...): Cannot initialize a transaction when there " + "is already an outstanding transaction.") : invariant(!this.isInTransaction());
        var errorThrown;
        var ret;
        try {
            this._isInTransaction = true;
            errorThrown = true;
            this.initializeAll(0);
            ret = method.call(scope, a, b, c, d, e, f);
            errorThrown = false
        } finally {
            try {
                if (errorThrown) {
                    try {
                        this.closeAll(0)
                    } catch (err) {
                    }
                } else {
                    this.closeAll(0)
                }
            } finally {
                this._isInTransaction = false
            }
        }
        return ret
    }, initializeAll: function (startIndex) {
        var transactionWrappers = this.transactionWrappers;
        for (var i = startIndex; i < transactionWrappers.length; i++) {
            var wrapper = transactionWrappers[i];
            try {
                this.wrapperInitData[i] = Transaction.OBSERVED_ERROR;
                this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null
            } finally {
                if (this.wrapperInitData[i] === Transaction.OBSERVED_ERROR) {
                    try {
                        this.initializeAll(i + 1)
                    } catch (err) {
                    }
                }
            }
        }
    }, closeAll: function (startIndex) {
        "production" !== "production" ? invariant(this.isInTransaction(), "Transaction.closeAll(): Cannot close transaction when none are open.") : invariant(this.isInTransaction());
        var transactionWrappers = this.transactionWrappers;
        for (var i = startIndex; i < transactionWrappers.length; i++) {
            var wrapper = transactionWrappers[i];
            var initData = this.wrapperInitData[i];
            var errorThrown;
            try {
                errorThrown = true;
                if (initData !== Transaction.OBSERVED_ERROR) {
                    wrapper.close && wrapper.close.call(this, initData)
                }
                errorThrown = false
            } finally {
                if (errorThrown) {
                    try {
                        this.closeAll(i + 1)
                    } catch (e) {
                    }
                }
            }
        }
        this.wrapperInitData.length = 0
    }};
    var Transaction = {Mixin: Mixin, OBSERVED_ERROR: {}};
    module.exports = Transaction
}, {"./invariant": 193}], 163: [function (require, module, exports) {
    "use strict";
    var getUnboundedScrollPosition = require("./getUnboundedScrollPosition");
    var ViewportMetrics = {currentScrollLeft: 0, currentScrollTop: 0, refreshScrollValues: function () {
        var scrollPosition = getUnboundedScrollPosition(window);
        ViewportMetrics.currentScrollLeft = scrollPosition.x;
        ViewportMetrics.currentScrollTop = scrollPosition.y
    }};
    module.exports = ViewportMetrics
}, {"./getUnboundedScrollPosition": 189}], 164: [function (require, module, exports) {
    "use strict";
    var invariant = require("./invariant");

    function accumulateInto(current, next) {
        "production" !== "production" ? invariant(next != null, "accumulateInto(...): Accumulated items must not be null or undefined.") : invariant(next != null);
        if (current == null) {
            return next
        }
        var currentIsArray = Array.isArray(current);
        var nextIsArray = Array.isArray(next);
        if (currentIsArray && nextIsArray) {
            current.push.apply(current, next);
            return current
        }
        if (currentIsArray) {
            current.push(next);
            return current
        }
        if (nextIsArray) {
            return[current].concat(next)
        }
        return[current, next]
    }

    module.exports = accumulateInto
}, {"./invariant": 193}], 165: [function (require, module, exports) {
    "use strict";
    var MOD = 65521;

    function adler32(data) {
        var a = 1;
        var b = 0;
        for (var i = 0; i < data.length; i++) {
            a = (a + data.charCodeAt(i)) % MOD;
            b = (b + a) % MOD
        }
        return a | b << 16
    }

    module.exports = adler32
}, {}], 166: [function (require, module, exports) {
    var _hyphenPattern = /-(.)/g;

    function camelize(string) {
        return string.replace(_hyphenPattern, function (_, character) {
            return character.toUpperCase()
        })
    }

    module.exports = camelize
}, {}], 167: [function (require, module, exports) {
    "use strict";
    var camelize = require("./camelize");
    var msPattern = /^-ms-/;

    function camelizeStyleName(string) {
        return camelize(string.replace(msPattern, "ms-"))
    }

    module.exports = camelizeStyleName
}, {"./camelize": 166}], 168: [function (require, module, exports) {
    var isTextNode = require("./isTextNode");

    function containsNode(outerNode, innerNode) {
        if (!outerNode || !innerNode) {
            return false
        } else if (outerNode === innerNode) {
            return true
        } else if (isTextNode(outerNode)) {
            return false
        } else if (isTextNode(innerNode)) {
            return containsNode(outerNode, innerNode.parentNode)
        } else if (outerNode.contains) {
            return outerNode.contains(innerNode)
        } else if (outerNode.compareDocumentPosition) {
            return!!(outerNode.compareDocumentPosition(innerNode) & 16)
        } else {
            return false
        }
    }

    module.exports = containsNode
}, {"./isTextNode": 197}], 169: [function (require, module, exports) {
    var toArray = require("./toArray");

    function hasArrayNature(obj) {
        return!!obj && (typeof obj == "object" || typeof obj == "function") && "length"in obj && !("setInterval"in obj) && typeof obj.nodeType != "number" && (Array.isArray(obj) || "callee"in obj || "item"in obj)
    }

    function createArrayFrom(obj) {
        if (!hasArrayNature(obj)) {
            return[obj]
        } else if (Array.isArray(obj)) {
            return obj.slice()
        } else {
            return toArray(obj)
        }
    }

    module.exports = createArrayFrom
}, {"./toArray": 210}], 170: [function (require, module, exports) {
    "use strict";
    var ReactCompositeComponent = require("./ReactCompositeComponent");
    var ReactElement = require("./ReactElement");
    var invariant = require("./invariant");

    function createFullPageComponent(tag) {
        var elementFactory = ReactElement.createFactory(tag);
        var FullPageComponent = ReactCompositeComponent.createClass({displayName: "ReactFullPageComponent" + tag, componentWillUnmount: function () {
            "production" !== "production" ? invariant(false, "%s tried to unmount. Because of cross-browser quirks it is " + "impossible to unmount some top-level components (eg <html>, <head>, " + "and <body>) reliably and efficiently. To fix this, have a single " + "top-level component that never unmounts render these elements.", this.constructor.displayName) : invariant(false)
        }, render: function () {
            return elementFactory(this.props)
        }});
        return FullPageComponent
    }

    module.exports = createFullPageComponent
}, {"./ReactCompositeComponent": 101, "./ReactElement": 119, "./invariant": 193}], 171: [function (require, module, exports) {
    var ExecutionEnvironment = require("./ExecutionEnvironment");
    var createArrayFrom = require("./createArrayFrom");
    var getMarkupWrap = require("./getMarkupWrap");
    var invariant = require("./invariant");
    var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement("div") : null;
    var nodeNamePattern = /^\s*<(\w+)/;

    function getNodeName(markup) {
        var nodeNameMatch = markup.match(nodeNamePattern);
        return nodeNameMatch && nodeNameMatch[1].toLowerCase()
    }

    function createNodesFromMarkup(markup, handleScript) {
        var node = dummyNode;
        "production" !== "production" ? invariant(!!dummyNode, "createNodesFromMarkup dummy not initialized") : invariant(!!dummyNode);
        var nodeName = getNodeName(markup);
        var wrap = nodeName && getMarkupWrap(nodeName);
        if (wrap) {
            node.innerHTML = wrap[1] + markup + wrap[2];
            var wrapDepth = wrap[0];
            while (wrapDepth--) {
                node = node.lastChild
            }
        } else {
            node.innerHTML = markup
        }
        var scripts = node.getElementsByTagName("script");
        if (scripts.length) {
            "production" !== "production" ? invariant(handleScript, "createNodesFromMarkup(...): Unexpected <script> element rendered.") : invariant(handleScript);
            createArrayFrom(scripts).forEach(handleScript)
        }
        var nodes = createArrayFrom(node.childNodes);
        while (node.lastChild) {
            node.removeChild(node.lastChild)
        }
        return nodes
    }

    module.exports = createNodesFromMarkup
}, {"./ExecutionEnvironment": 88, "./createArrayFrom": 169, "./getMarkupWrap": 185, "./invariant": 193}], 172: [function (require, module, exports) {
    "use strict";
    var CSSProperty = require("./CSSProperty");
    var isUnitlessNumber = CSSProperty.isUnitlessNumber;

    function dangerousStyleValue(name, value) {
        var isEmpty = value == null || typeof value === "boolean" || value === "";
        if (isEmpty) {
            return""
        }
        var isNonNumeric = isNaN(value);
        if (isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
            return"" + value
        }
        if (typeof value === "string") {
            value = value.trim()
        }
        return value + "px"
    }

    module.exports = dangerousStyleValue
}, {"./CSSProperty": 70}], 173: [function (require, module, exports) {
    var assign = require("./Object.assign");
    var warning = require("./warning");

    function deprecated(namespace, oldName, newName, ctx, fn) {
        var warned = false;
        if ("production" !== "production") {
            var newFn = function () {
                "production" !== "production" ? warning(warned, namespace + "." + oldName + " will be deprecated in a future version. " + ("Use " + namespace + "." + newName + " instead.")) : null;
                warned = true;
                return fn.apply(ctx, arguments)
            };
            newFn.displayName = namespace + "_" + oldName;
            return assign(newFn, fn)
        }
        return fn
    }

    module.exports = deprecated
}, {"./Object.assign": 93, "./warning": 212}], 174: [function (require, module, exports) {
    function makeEmptyFunction(arg) {
        return function () {
            return arg
        }
    }

    function emptyFunction() {
    }

    emptyFunction.thatReturns = makeEmptyFunction;
    emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
    emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
    emptyFunction.thatReturnsNull = makeEmptyFunction(null);
    emptyFunction.thatReturnsThis = function () {
        return this
    };
    emptyFunction.thatReturnsArgument = function (arg) {
        return arg
    };
    module.exports = emptyFunction
}, {}], 175: [function (require, module, exports) {
    "use strict";
    var emptyObject = {};
    if ("production" !== "production") {
        Object.freeze(emptyObject)
    }
    module.exports = emptyObject
}, {}], 176: [function (require, module, exports) {
    "use strict";
    var ESCAPE_LOOKUP = {"&": "&amp;", ">": "&gt;", "<": "&lt;", '"': "&quot;", "'": "&#x27;"};
    var ESCAPE_REGEX = /[&><"']/g;

    function escaper(match) {
        return ESCAPE_LOOKUP[match]
    }

    function escapeTextForBrowser(text) {
        return("" + text).replace(ESCAPE_REGEX, escaper)
    }

    module.exports = escapeTextForBrowser
}, {}], 177: [function (require, module, exports) {
    "use strict";
    var ReactTextComponent = require("./ReactTextComponent");
    var traverseAllChildren = require("./traverseAllChildren");
    var warning = require("./warning");

    function flattenSingleChildIntoContext(traverseContext, child, name) {
        var result = traverseContext;
        var keyUnique = !result.hasOwnProperty(name);
        "production" !== "production" ? warning(keyUnique, "flattenChildren(...): Encountered two children with the same key, " + "`%s`. Child keys must be unique; when two children share a key, only " + "the first child will be used.", name) : null;
        if (keyUnique && child != null) {
            var type = typeof child;
            var normalizedValue;
            if (type === "string") {
                normalizedValue = ReactTextComponent(child)
            } else if (type === "number") {
                normalizedValue = ReactTextComponent("" + child)
            } else {
                normalizedValue = child
            }
            result[name] = normalizedValue
        }
    }

    function flattenChildren(children) {
        if (children == null) {
            return children
        }
        var result = {};
        traverseAllChildren(children, flattenSingleChildIntoContext, result);
        return result
    }

    module.exports = flattenChildren
}, {"./ReactTextComponent": 145, "./traverseAllChildren": 211, "./warning": 212}], 178: [function (require, module, exports) {
    "use strict";
    function focusNode(node) {
        try {
            node.focus()
        } catch (e) {
        }
    }

    module.exports = focusNode
}, {}], 179: [function (require, module, exports) {
    "use strict";
    var forEachAccumulated = function (arr, cb, scope) {
        if (Array.isArray(arr)) {
            arr.forEach(cb, scope)
        } else if (arr) {
            cb.call(scope, arr)
        }
    };
    module.exports = forEachAccumulated
}, {}], 180: [function (require, module, exports) {
    function getActiveElement() {
        try {
            return document.activeElement || document.body
        } catch (e) {
            return document.body
        }
    }

    module.exports = getActiveElement
}, {}], 181: [function (require, module, exports) {
    "use strict";
    function getEventCharCode(nativeEvent) {
        var charCode;
        var keyCode = nativeEvent.keyCode;
        if ("charCode"in nativeEvent) {
            charCode = nativeEvent.charCode;
            if (charCode === 0 && keyCode === 13) {
                charCode = 13
            }
        } else {
            charCode = keyCode
        }
        if (charCode >= 32 || charCode === 13) {
            return charCode
        }
        return 0
    }

    module.exports = getEventCharCode
}, {}], 182: [function (require, module, exports) {
    "use strict";
    var getEventCharCode = require("./getEventCharCode");
    var normalizeKey = {Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified"};
    var translateToKey = {8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta"};

    function getEventKey(nativeEvent) {
        if (nativeEvent.key) {
            var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
            if (key !== "Unidentified") {
                return key
            }
        }
        if (nativeEvent.type === "keypress") {
            var charCode = getEventCharCode(nativeEvent);
            return charCode === 13 ? "Enter" : String.fromCharCode(charCode)
        }
        if (nativeEvent.type === "keydown" || nativeEvent.type === "keyup") {
            return translateToKey[nativeEvent.keyCode] || "Unidentified"
        }
        return""
    }

    module.exports = getEventKey
}, {"./getEventCharCode": 181}], 183: [function (require, module, exports) {
    "use strict";
    var modifierKeyToProp = {Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey"};

    function modifierStateGetter(keyArg) {
        var syntheticEvent = this;
        var nativeEvent = syntheticEvent.nativeEvent;
        if (nativeEvent.getModifierState) {
            return nativeEvent.getModifierState(keyArg)
        }
        var keyProp = modifierKeyToProp[keyArg];
        return keyProp ? !!nativeEvent[keyProp] : false
    }

    function getEventModifierState(nativeEvent) {
        return modifierStateGetter
    }

    module.exports = getEventModifierState
}, {}], 184: [function (require, module, exports) {
    "use strict";
    function getEventTarget(nativeEvent) {
        var target = nativeEvent.target || nativeEvent.srcElement || window;
        return target.nodeType === 3 ? target.parentNode : target
    }

    module.exports = getEventTarget
}, {}], 185: [function (require, module, exports) {
    var ExecutionEnvironment = require("./ExecutionEnvironment");
    var invariant = require("./invariant");
    var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement("div") : null;
    var shouldWrap = {circle: true, defs: true, ellipse: true, g: true, line: true, linearGradient: true, path: true, polygon: true, polyline: true, radialGradient: true, rect: true, stop: true, text: true};
    var selectWrap = [1, '<select multiple="true">', "</select>"];
    var tableWrap = [1, "<table>", "</table>"];
    var trWrap = [3, "<table><tbody><tr>", "</tr></tbody></table>"];
    var svgWrap = [1, "<svg>", "</svg>"];
    var markupWrap = {"*": [1, "?<div>", "</div>"], area: [1, "<map>", "</map>"], col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"], legend: [1, "<fieldset>", "</fieldset>"], param: [1, "<object>", "</object>"], tr: [2, "<table><tbody>", "</tbody></table>"], optgroup: selectWrap, option: selectWrap, caption: tableWrap, colgroup: tableWrap, tbody: tableWrap, tfoot: tableWrap, thead: tableWrap, td: trWrap, th: trWrap, circle: svgWrap, defs: svgWrap, ellipse: svgWrap, g: svgWrap, line: svgWrap, linearGradient: svgWrap, path: svgWrap, polygon: svgWrap, polyline: svgWrap, radialGradient: svgWrap, rect: svgWrap, stop: svgWrap, text: svgWrap};

    function getMarkupWrap(nodeName) {
        "production" !== "production" ? invariant(!!dummyNode, "Markup wrapping node not initialized") : invariant(!!dummyNode);
        if (!markupWrap.hasOwnProperty(nodeName)) {
            nodeName = "*"
        }
        if (!shouldWrap.hasOwnProperty(nodeName)) {
            if (nodeName === "*") {
                dummyNode.innerHTML = "<link />"
            } else {
                dummyNode.innerHTML = "<" + nodeName + "></" + nodeName + ">"
            }
            shouldWrap[nodeName] = !dummyNode.firstChild
        }
        return shouldWrap[nodeName] ? markupWrap[nodeName] : null
    }

    module.exports = getMarkupWrap
}, {"./ExecutionEnvironment": 88, "./invariant": 193}], 186: [function (require, module, exports) {
    "use strict";
    function getLeafNode(node) {
        while (node && node.firstChild) {
            node = node.firstChild
        }
        return node
    }

    function getSiblingNode(node) {
        while (node) {
            if (node.nextSibling) {
                return node.nextSibling
            }
            node = node.parentNode
        }
    }

    function getNodeForCharacterOffset(root, offset) {
        var node = getLeafNode(root);
        var nodeStart = 0;
        var nodeEnd = 0;
        while (node) {
            if (node.nodeType == 3) {
                nodeEnd = nodeStart + node.textContent.length;
                if (nodeStart <= offset && nodeEnd >= offset) {
                    return{node: node, offset: offset - nodeStart}
                }
                nodeStart = nodeEnd
            }
            node = getLeafNode(getSiblingNode(node))
        }
    }

    module.exports = getNodeForCharacterOffset
}, {}], 187: [function (require, module, exports) {
    "use strict";
    var DOC_NODE_TYPE = 9;

    function getReactRootElementInContainer(container) {
        if (!container) {
            return null
        }
        if (container.nodeType === DOC_NODE_TYPE) {
            return container.documentElement
        } else {
            return container.firstChild
        }
    }

    module.exports = getReactRootElementInContainer
}, {}], 188: [function (require, module, exports) {
    "use strict";
    var ExecutionEnvironment = require("./ExecutionEnvironment");
    var contentKey = null;

    function getTextContentAccessor() {
        if (!contentKey && ExecutionEnvironment.canUseDOM) {
            contentKey = "textContent"in document.documentElement ? "textContent" : "innerText"
        }
        return contentKey
    }

    module.exports = getTextContentAccessor
}, {"./ExecutionEnvironment": 88}], 189: [function (require, module, exports) {
    "use strict";
    function getUnboundedScrollPosition(scrollable) {
        if (scrollable === window) {
            return{x: window.pageXOffset || document.documentElement.scrollLeft, y: window.pageYOffset || document.documentElement.scrollTop}
        }
        return{x: scrollable.scrollLeft, y: scrollable.scrollTop}
    }

    module.exports = getUnboundedScrollPosition
}, {}], 190: [function (require, module, exports) {
    var _uppercasePattern = /([A-Z])/g;

    function hyphenate(string) {
        return string.replace(_uppercasePattern, "-$1").toLowerCase()
    }

    module.exports = hyphenate
}, {}], 191: [function (require, module, exports) {
    "use strict";
    var hyphenate = require("./hyphenate");
    var msPattern = /^ms-/;

    function hyphenateStyleName(string) {
        return hyphenate(string).replace(msPattern, "-ms-")
    }

    module.exports = hyphenateStyleName
}, {"./hyphenate": 190}], 192: [function (require, module, exports) {
    "use strict";
    var warning = require("./warning");
    var ReactElement = require("./ReactElement");
    var ReactLegacyElement = require("./ReactLegacyElement");
    var ReactNativeComponent = require("./ReactNativeComponent");
    var ReactEmptyComponent = require("./ReactEmptyComponent");

    function instantiateReactComponent(element, parentCompositeType) {
        var instance;
        if ("production" !== "production") {
            "production" !== "production" ? warning(element && (typeof element.type === "function" || typeof element.type === "string"), "Only functions or strings can be mounted as React components.") : null;
            if (element.type._mockedReactClassConstructor) {
                ReactLegacyElement._isLegacyCallWarningEnabled = false;
                try {
                    instance = new element.type._mockedReactClassConstructor(element.props)
                } finally {
                    ReactLegacyElement._isLegacyCallWarningEnabled = true
                }
                if (ReactElement.isValidElement(instance)) {
                    instance = new instance.type(instance.props)
                }
                var render = instance.render;
                if (!render) {
                    element = ReactEmptyComponent.getEmptyComponent()
                } else {
                    if (render._isMockFunction && !render._getMockImplementation()) {
                        render.mockImplementation(ReactEmptyComponent.getEmptyComponent)
                    }
                    instance.construct(element);
                    return instance
                }
            }
        }
        if (typeof element.type === "string") {
            instance = ReactNativeComponent.createInstanceForTag(element.type, element.props, parentCompositeType)
        } else {
            instance = new element.type(element.props)
        }
        if ("production" !== "production") {
            "production" !== "production" ? warning(typeof instance.construct === "function" && typeof instance.mountComponent === "function" && typeof instance.receiveComponent === "function", "Only React Components can be mounted.") : null
        }
        instance.construct(element);
        return instance
    }

    module.exports = instantiateReactComponent
}, {"./ReactElement": 119, "./ReactEmptyComponent": 121, "./ReactLegacyElement": 128, "./ReactNativeComponent": 133, "./warning": 212}], 193: [function (require, module, exports) {
    "use strict";
    var invariant = function (condition, format, a, b, c, d, e, f) {
        if ("production" !== "production") {
            if (format === undefined) {
                throw new Error("invariant requires an error message argument")
            }
        }
        if (!condition) {
            var error;
            if (format === undefined) {
                error = new Error("Minified exception occurred; use the non-minified dev environment " + "for the full error message and additional helpful warnings.")
            } else {
                var args = [a, b, c, d, e, f];
                var argIndex = 0;
                error = new Error("Invariant Violation: " + format.replace(/%s/g, function () {
                    return args[argIndex++]
                }))
            }
            error.framesToPop = 1;
            throw error
        }
    };
    module.exports = invariant
}, {}], 194: [function (require, module, exports) {
    "use strict";
    var ExecutionEnvironment = require("./ExecutionEnvironment");
    var useHasFeature;
    if (ExecutionEnvironment.canUseDOM) {
        useHasFeature = document.implementation && document.implementation.hasFeature && document.implementation.hasFeature("", "") !== true
    }
    function isEventSupported(eventNameSuffix, capture) {
        if (!ExecutionEnvironment.canUseDOM || capture && !("addEventListener"in document)) {
            return false
        }
        var eventName = "on" + eventNameSuffix;
        var isSupported = eventName in document;
        if (!isSupported) {
            var element = document.createElement("div");
            element.setAttribute(eventName, "return;");
            isSupported = typeof element[eventName] === "function"
        }
        if (!isSupported && useHasFeature && eventNameSuffix === "wheel") {
            isSupported = document.implementation.hasFeature("Events.wheel", "3.0")
        }
        return isSupported
    }

    module.exports = isEventSupported
}, {"./ExecutionEnvironment": 88}], 195: [function (require, module, exports) {
    function isNode(object) {
        return!!(object && (typeof Node === "function" ? object instanceof Node : typeof object === "object" && typeof object.nodeType === "number" && typeof object.nodeName === "string"))
    }

    module.exports = isNode
}, {}], 196: [function (require, module, exports) {
    "use strict";
    var supportedInputTypes = {color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true};

    function isTextInputElement(elem) {
        return elem && (elem.nodeName === "INPUT" && supportedInputTypes[elem.type] || elem.nodeName === "TEXTAREA")
    }

    module.exports = isTextInputElement
}, {}], 197: [function (require, module, exports) {
    var isNode = require("./isNode");

    function isTextNode(object) {
        return isNode(object) && object.nodeType == 3
    }

    module.exports = isTextNode
}, {"./isNode": 195}], 198: [function (require, module, exports) {
    "use strict";
    function joinClasses(className) {
        if (!className) {
            className = ""
        }
        var nextClass;
        var argLength = arguments.length;
        if (argLength > 1) {
            for (var ii = 1; ii < argLength; ii++) {
                nextClass = arguments[ii];
                if (nextClass) {
                    className = (className ? className + " " : "") + nextClass
                }
            }
        }
        return className
    }

    module.exports = joinClasses
}, {}], 199: [function (require, module, exports) {
    "use strict";
    var invariant = require("./invariant");
    var keyMirror = function (obj) {
        var ret = {};
        var key;
        "production" !== "production" ? invariant(obj instanceof Object && !Array.isArray(obj), "keyMirror(...): Argument must be an object.") : invariant(obj instanceof Object && !Array.isArray(obj));
        for (key in obj) {
            if (!obj.hasOwnProperty(key)) {
                continue
            }
            ret[key] = key
        }
        return ret
    };
    module.exports = keyMirror
}, {"./invariant": 193}], 200: [function (require, module, exports) {
    var keyOf = function (oneKeyObj) {
        var key;
        for (key in oneKeyObj) {
            if (!oneKeyObj.hasOwnProperty(key)) {
                continue
            }
            return key
        }
        return null
    };
    module.exports = keyOf
}, {}], 201: [function (require, module, exports) {
    "use strict";
    var hasOwnProperty = Object.prototype.hasOwnProperty;

    function mapObject(object, callback, context) {
        if (!object) {
            return null
        }
        var result = {};
        for (var name in object) {
            if (hasOwnProperty.call(object, name)) {
                result[name] = callback.call(context, object[name], name, object)
            }
        }
        return result
    }

    module.exports = mapObject
}, {}], 202: [function (require, module, exports) {
    "use strict";
    function memoizeStringOnly(callback) {
        var cache = {};
        return function (string) {
            if (cache.hasOwnProperty(string)) {
                return cache[string]
            } else {
                return cache[string] = callback.call(this, string)
            }
        }
    }

    module.exports = memoizeStringOnly
}, {}], 203: [function (require, module, exports) {
    "use strict";
    var invariant = require("./invariant");

    function monitorCodeUse(eventName, data) {
        "production" !== "production" ? invariant(eventName && !/[^a-z0-9_]/.test(eventName), "You must provide an eventName using only the characters [a-z0-9_]") : invariant(eventName && !/[^a-z0-9_]/.test(eventName))
    }

    module.exports = monitorCodeUse
}, {"./invariant": 193}], 204: [function (require, module, exports) {
    "use strict";
    var ReactElement = require("./ReactElement");
    var invariant = require("./invariant");

    function onlyChild(children) {
        "production" !== "production" ? invariant(ReactElement.isValidElement(children), "onlyChild must be passed a children with exactly one child.") : invariant(ReactElement.isValidElement(children));
        return children
    }

    module.exports = onlyChild
}, {"./ReactElement": 119, "./invariant": 193}], 205: [function (require, module, exports) {
    "use strict";
    var ExecutionEnvironment = require("./ExecutionEnvironment");
    var performance;
    if (ExecutionEnvironment.canUseDOM) {
        performance = window.performance || window.msPerformance || window.webkitPerformance
    }
    module.exports = performance || {}
}, {"./ExecutionEnvironment": 88}], 206: [function (require, module, exports) {
    var performance = require("./performance");
    if (!performance || !performance.now) {
        performance = Date
    }
    var performanceNow = performance.now.bind(performance);
    module.exports = performanceNow
}, {"./performance": 205}], 207: [function (require, module, exports) {
    "use strict";
    var ExecutionEnvironment = require("./ExecutionEnvironment");
    var WHITESPACE_TEST = /^[ \r\n\t\f]/;
    var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;
    var setInnerHTML = function (node, html) {
        node.innerHTML = html
    };
    if (ExecutionEnvironment.canUseDOM) {
        var testElement = document.createElement("div");
        testElement.innerHTML = " ";
        if (testElement.innerHTML === "") {
            setInnerHTML = function (node, html) {
                if (node.parentNode) {
                    node.parentNode.replaceChild(node, node)
                }
                if (WHITESPACE_TEST.test(html) || html[0] === "<" && NONVISIBLE_TEST.test(html)) {
                    node.innerHTML = "" + html;
                    var textNode = node.firstChild;
                    if (textNode.data.length === 1) {
                        node.removeChild(textNode)
                    } else {
                        textNode.deleteData(0, 1)
                    }
                } else {
                    node.innerHTML = html
                }
            }
        }
    }
    module.exports = setInnerHTML
}, {"./ExecutionEnvironment": 88}], 208: [function (require, module, exports) {
    "use strict";
    function shallowEqual(objA, objB) {
        if (objA === objB) {
            return true
        }
        var key;
        for (key in objA) {
            if (objA.hasOwnProperty(key) && (!objB.hasOwnProperty(key) || objA[key] !== objB[key])) {
                return false
            }
        }
        for (key in objB) {
            if (objB.hasOwnProperty(key) && !objA.hasOwnProperty(key)) {
                return false
            }
        }
        return true
    }

    module.exports = shallowEqual
}, {}], 209: [function (require, module, exports) {
    "use strict";
    function shouldUpdateReactComponent(prevElement, nextElement) {
        if (prevElement && nextElement && prevElement.type === nextElement.type && prevElement.key === nextElement.key && prevElement._owner === nextElement._owner) {
            return true
        }
        return false
    }

    module.exports = shouldUpdateReactComponent
}, {}], 210: [function (require, module, exports) {
    var invariant = require("./invariant");

    function toArray(obj) {
        var length = obj.length;
        "production" !== "production" ? invariant(!Array.isArray(obj) && (typeof obj === "object" || typeof obj === "function"), "toArray: Array-like object expected") : invariant(!Array.isArray(obj) && (typeof obj === "object" || typeof obj === "function"));
        "production" !== "production" ? invariant(typeof length === "number", "toArray: Object needs a length property") : invariant(typeof length === "number");
        "production" !== "production" ? invariant(length === 0 || length - 1 in obj, "toArray: Object should have keys for indices") : invariant(length === 0 || length - 1 in obj);
        if (obj.hasOwnProperty) {
            try {
                return Array.prototype.slice.call(obj)
            } catch (e) {
            }
        }
        var ret = Array(length);
        for (var ii = 0; ii < length; ii++) {
            ret[ii] = obj[ii]
        }
        return ret
    }

    module.exports = toArray
}, {"./invariant": 193}], 211: [function (require, module, exports) {
    "use strict";
    var ReactElement = require("./ReactElement");
    var ReactInstanceHandles = require("./ReactInstanceHandles");
    var invariant = require("./invariant");
    var SEPARATOR = ReactInstanceHandles.SEPARATOR;
    var SUBSEPARATOR = ":";
    var userProvidedKeyEscaperLookup = {"=": "=0", ".": "=1", ":": "=2"};
    var userProvidedKeyEscapeRegex = /[=.:]/g;

    function userProvidedKeyEscaper(match) {
        return userProvidedKeyEscaperLookup[match]
    }

    function getComponentKey(component, index) {
        if (component && component.key != null) {
            return wrapUserProvidedKey(component.key)
        }
        return index.toString(36)
    }

    function escapeUserProvidedKey(text) {
        return("" + text).replace(userProvidedKeyEscapeRegex, userProvidedKeyEscaper)
    }

    function wrapUserProvidedKey(key) {
        return"$" + escapeUserProvidedKey(key)
    }

    var traverseAllChildrenImpl = function (children, nameSoFar, indexSoFar, callback, traverseContext) {
        var nextName, nextIndex;
        var subtreeCount = 0;
        if (Array.isArray(children)) {
            for (var i = 0; i < children.length; i++) {
                var child = children[i];
                nextName = nameSoFar + (nameSoFar ? SUBSEPARATOR : SEPARATOR) + getComponentKey(child, i);
                nextIndex = indexSoFar + subtreeCount;
                subtreeCount += traverseAllChildrenImpl(child, nextName, nextIndex, callback, traverseContext)
            }
        } else {
            var type = typeof children;
            var isOnlyChild = nameSoFar === "";
            var storageName = isOnlyChild ? SEPARATOR + getComponentKey(children, 0) : nameSoFar;
            if (children == null || type === "boolean") {
                callback(traverseContext, null, storageName, indexSoFar);
                subtreeCount = 1
            } else if (type === "string" || type === "number" || ReactElement.isValidElement(children)) {
                callback(traverseContext, children, storageName, indexSoFar);
                subtreeCount = 1
            } else if (type === "object") {
                "production" !== "production" ? invariant(!children || children.nodeType !== 1, "traverseAllChildren(...): Encountered an invalid child; DOM " + "elements are not valid children of React components.") : invariant(!children || children.nodeType !== 1);
                for (var key in children) {
                    if (children.hasOwnProperty(key)) {
                        nextName = nameSoFar + (nameSoFar ? SUBSEPARATOR : SEPARATOR) + wrapUserProvidedKey(key) + SUBSEPARATOR + getComponentKey(children[key], 0);
                        nextIndex = indexSoFar + subtreeCount;
                        subtreeCount += traverseAllChildrenImpl(children[key], nextName, nextIndex, callback, traverseContext)
                    }
                }
            }
        }
        return subtreeCount
    };

    function traverseAllChildren(children, callback, traverseContext) {
        if (children == null) {
            return 0
        }
        return traverseAllChildrenImpl(children, "", 0, callback, traverseContext)
    }

    module.exports = traverseAllChildren
}, {"./ReactElement": 119, "./ReactInstanceHandles": 127, "./invariant": 193}], 212: [function (require, module, exports) {
    "use strict";
    var emptyFunction = require("./emptyFunction");
    var warning = emptyFunction;
    if ("production" !== "production") {
        warning = function (condition, format) {
            for (var args = [], $__0 = 2, $__1 = arguments.length; $__0 < $__1; $__0++)args.push(arguments[$__0]);
            if (format === undefined) {
                throw new Error("`warning(condition, format, ...args)` requires a warning " + "message argument")
            }
            if (!condition) {
                var argIndex = 0;
                console.warn("Warning: " + format.replace(/%s/g, function () {
                    return args[argIndex++]
                }))
            }
        }
    }
    module.exports = warning
}, {"./emptyFunction": 174}], 213: [function (require, module, exports) {
    module.exports = require("./lib/React")
}, {"./lib/React": 95}], 214: [function (require, module, exports) {
    module.exports = require("./src/simperium")
}, {"./src/simperium": 234}], 215: [function (require, module, exports) {
    exports = module.exports = require("./debug");
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.colors = ["lightseagreen", "forestgreen", "goldenrod", "dodgerblue", "darkorchid", "crimson"];
    function useColors() {
        return"WebkitAppearance"in document.documentElement.style || window.console && (console.firebug || console.exception && console.table)
    }

    exports.formatters.j = function (v) {
        return JSON.stringify(v)
    };
    function formatArgs() {
        var args = arguments;
        var useColors = this.useColors;
        args[0] = (useColors ? "%c" : "") + this.namespace + (useColors ? "%c " : " ") + args[0] + (useColors ? "%c " : " ") + "+" + exports.humanize(this.diff);
        if (!useColors)return args;
        var c = "color: " + this.color;
        args = [args[0], c, ""].concat(Array.prototype.slice.call(args, 1));
        var index = 0;
        var lastC = 0;
        args[0].replace(/%[a-z%]/g, function (match) {
            if ("%%" === match)return;
            index++;
            if ("%c" === match) {
                lastC = index
            }
        });
        args.splice(lastC, 0, c);
        return args
    }

    function log() {
        return"object" == typeof console && "function" == typeof console.log && Function.prototype.apply.call(console.log, console, arguments)
    }

    function save(namespaces) {
        try {
            if (null == namespaces) {
                localStorage.removeItem("debug")
            } else {
                localStorage.debug = namespaces
            }
        } catch (e) {
        }
    }

    function load() {
        var r;
        try {
            r = localStorage.debug
        } catch (e) {
        }
        return r
    }

    exports.enable(load())
}, {"./debug": 216}], 216: [function (require, module, exports) {
    exports = module.exports = debug;
    exports.coerce = coerce;
    exports.disable = disable;
    exports.enable = enable;
    exports.enabled = enabled;
    exports.humanize = require("ms");
    exports.names = [];
    exports.skips = [];
    exports.formatters = {};
    var prevColor = 0;
    var prevTime;

    function selectColor() {
        return exports.colors[prevColor++ % exports.colors.length]
    }

    function debug(namespace) {
        function disabled() {
        }

        disabled.enabled = false;
        function enabled() {
            var self = enabled;
            var curr = +new Date;
            var ms = curr - (prevTime || curr);
            self.diff = ms;
            self.prev = prevTime;
            self.curr = curr;
            prevTime = curr;
            if (null == self.useColors)self.useColors = exports.useColors();
            if (null == self.color && self.useColors)self.color = selectColor();
            var args = Array.prototype.slice.call(arguments);
            args[0] = exports.coerce(args[0]);
            if ("string" !== typeof args[0]) {
                args = ["%o"].concat(args)
            }
            var index = 0;
            args[0] = args[0].replace(/%([a-z%])/g, function (match, format) {
                if (match === "%%")return match;
                index++;
                var formatter = exports.formatters[format];
                if ("function" === typeof formatter) {
                    var val = args[index];
                    match = formatter.call(self, val);
                    args.splice(index, 1);
                    index--
                }
                return match
            });
            if ("function" === typeof exports.formatArgs) {
                args = exports.formatArgs.apply(self, args)
            }
            var logFn = exports.log || enabled.log || console.log.bind(console);
            logFn.apply(self, args)
        }

        enabled.enabled = true;
        var fn = exports.enabled(namespace) ? enabled : disabled;
        fn.namespace = namespace;
        return fn
    }

    function enable(namespaces) {
        exports.save(namespaces);
        var split = (namespaces || "").split(/[\s,]+/);
        var len = split.length;
        for (var i = 0; i < len; i++) {
            if (!split[i])continue;
            namespaces = split[i].replace("*", ".*?");
            if (namespaces[0] === "-") {
                exports.skips.push(new RegExp("^" + namespaces.substr(1) + "$"))
            } else {
                exports.names.push(new RegExp("^" + namespaces + "$"))
            }
        }
    }

    function disable() {
        exports.enable("")
    }

    function enabled(name) {
        var i, len;
        for (i = 0, len = exports.skips.length; i < len; i++) {
            if (exports.skips[i].test(name)) {
                return false
            }
        }
        for (i = 0, len = exports.names.length; i < len; i++) {
            if (exports.names[i].test(name)) {
                return true
            }
        }
        return false
    }

    function coerce(val) {
        if (val instanceof Error)return val.stack || val.message;
        return val
    }
}, {ms: 217}], 217: [function (require, module, exports) {
    module.exports = require(50)
}, {}], 218: [function (require, module, exports) {
    (function (g) {
        var j = "undefined" != typeof JSON ? JSON.stringify : String;

        function s(str) {
            var i = 1, args = arguments;
            return String(str).replace(/%?%(d|s|j)/g, function (symbol, type) {
                if ("%" == symbol[1])return symbol;
                var arg = args[i++];
                switch (type) {
                    case"d":
                        return Number(arg);
                    case"j":
                        return j(arg)
                }
                return String(arg)
            })
        }

        s.extend = function () {
            String.prototype.s = function () {
                var arr = [this];
                arr.push.apply(arr, arguments);
                return s.apply(null, arr)
            }
        };
        g.top ? g.s = s : module.exports = s
    })(this)
}, {}], 219: [function (require, module, exports) {
    var Emitter = require("emitter");
    var reduce = require("reduce");
    var root = "undefined" == typeof window ? this : window;

    function noop() {
    }

    function isHost(obj) {
        var str = {}.toString.call(obj);
        switch (str) {
            case"[object File]":
            case"[object Blob]":
            case"[object FormData]":
                return true;
            default:
                return false
        }
    }

    function getXHR() {
        if (root.XMLHttpRequest && ("file:" != root.location.protocol || !root.ActiveXObject)) {
            return new XMLHttpRequest
        } else {
            try {
                return new ActiveXObject("Microsoft.XMLHTTP")
            } catch (e) {
            }
            try {
                return new ActiveXObject("Msxml2.XMLHTTP.6.0")
            } catch (e) {
            }
            try {
                return new ActiveXObject("Msxml2.XMLHTTP.3.0")
            } catch (e) {
            }
            try {
                return new ActiveXObject("Msxml2.XMLHTTP")
            } catch (e) {
            }
        }
        return false
    }

    var trim = "".trim ? function (s) {
        return s.trim()
    } : function (s) {
        return s.replace(/(^\s*|\s*$)/g, "")
    };

    function isObject(obj) {
        return obj === Object(obj)
    }

    function serialize(obj) {
        if (!isObject(obj))return obj;
        var pairs = [];
        for (var key in obj) {
            if (null != obj[key]) {
                pairs.push(encodeURIComponent(key) + "=" + encodeURIComponent(obj[key]))
            }
        }
        return pairs.join("&")
    }

    request.serializeObject = serialize;
    function parseString(str) {
        var obj = {};
        var pairs = str.split("&");
        var parts;
        var pair;
        for (var i = 0, len = pairs.length; i < len; ++i) {
            pair = pairs[i];
            parts = pair.split("=");
            obj[decodeURIComponent(parts[0])] = decodeURIComponent(parts[1])
        }
        return obj
    }

    request.parseString = parseString;
    request.types = {html: "text/html", json: "application/json", xml: "application/xml", urlencoded: "application/x-www-form-urlencoded", form: "application/x-www-form-urlencoded", "form-data": "application/x-www-form-urlencoded"};
    request.serialize = {"application/x-www-form-urlencoded": serialize, "application/json": JSON.stringify};
    request.parse = {"application/x-www-form-urlencoded": parseString, "application/json": JSON.parse};
    function parseHeader(str) {
        var lines = str.split(/\r?\n/);
        var fields = {};
        var index;
        var line;
        var field;
        var val;
        lines.pop();
        for (var i = 0, len = lines.length; i < len; ++i) {
            line = lines[i];
            index = line.indexOf(":");
            field = line.slice(0, index).toLowerCase();
            val = trim(line.slice(index + 1));
            fields[field] = val
        }
        return fields
    }

    function type(str) {
        return str.split(/ *; */).shift()
    }

    function params(str) {
        return reduce(str.split(/ *; */), function (obj, str) {
            var parts = str.split(/ *= */), key = parts.shift(), val = parts.shift();
            if (key && val)obj[key] = val;
            return obj
        }, {})
    }

    function Response(req, options) {
        options = options || {};
        this.req = req;
        this.xhr = this.req.xhr;
        this.setStatusProperties(this.xhr.status);
        this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());
        this.header["content-type"] = this.xhr.getResponseHeader("content-type");
        this.setHeaderProperties(this.header);
        if (this.req.method == "HEAD") {
            this.text = "";
            this.body = null
        } else {
            if (this.req._responseType) {
                this.text = null;
                this.body = this.xhr.response
            } else {
                this.text = this.xhr.responseText;
                this.body = this.parseBody(this.text)
            }
        }
    }

    Response.prototype.get = function (field) {
        return this.header[field.toLowerCase()]
    };
    Response.prototype.setHeaderProperties = function (header) {
        var ct = this.header["content-type"] || "";
        this.type = type(ct);
        var obj = params(ct);
        for (var key in obj)this[key] = obj[key]
    };
    Response.prototype.parseBody = function (str) {
        var parse = request.parse[this.type];
        return parse ? parse(str) : null
    };
    Response.prototype.setStatusProperties = function (status) {
        var type = status / 100 | 0;
        this.status = status;
        this.statusType = type;
        this.info = 1 == type;
        this.ok = 2 == type;
        this.clientError = 4 == type;
        this.serverError = 5 == type;
        this.error = 4 == type || 5 == type ? this.toError() : false;
        this.accepted = 202 == status;
        this.noContent = 204 == status || 1223 == status;
        this.badRequest = 400 == status;
        this.unauthorized = 401 == status;
        this.notAcceptable = 406 == status;
        this.notFound = 404 == status;
        this.forbidden = 403 == status
    };
    Response.prototype.toError = function () {
        var req = this.req;
        var method = req.method;
        var path = req.path;
        var msg = "cannot " + method + " " + path + " (" + this.status + ")";
        var err = new Error(msg);
        err.status = this.status;
        err.method = method;
        err.path = path;
        return err
    };
    request.Response = Response;
    function Request(method, url) {
        var self = this;
        Emitter.call(this);
        this._query = this._query || [];
        this.method = method;
        this.url = url;
        this.header = {};
        this._header = {};
        this.on("end", function () {
            var res = new Response(self);
            if ("HEAD" == method)res.text = null;
            self.callback(null, res)
        })
    }

    Emitter(Request.prototype);
    Request.prototype.timeout = function (ms) {
        this._timeout = ms;
        return this
    };
    Request.prototype.clearTimeout = function () {
        this._timeout = 0;
        clearTimeout(this._timer);
        return this
    };
    Request.prototype.abort = function () {
        if (this.aborted)return;
        this.aborted = true;
        this.xhr.abort();
        this.clearTimeout();
        this.emit("abort");
        return this
    };
    Request.prototype.set = function (field, val) {
        if (isObject(field)) {
            for (var key in field) {
                this.set(key, field[key])
            }
            return this
        }
        this._header[field.toLowerCase()] = val;
        this.header[field] = val;
        return this
    };
    Request.prototype.getHeader = function (field) {
        return this._header[field.toLowerCase()]
    };
    Request.prototype.type = function (type) {
        this.set("Content-Type", request.types[type] || type);
        return this
    };
    Request.prototype.accept = function (type) {
        this.set("Accept", request.types[type] || type);
        return this
    };
    Request.prototype.auth = function (user, pass) {
        var str = btoa(user + ":" + pass);
        this.set("Authorization", "Basic " + str);
        return this
    };
    Request.prototype.query = function (val) {
        if ("string" != typeof val)val = serialize(val);
        if (val)this._query.push(val);
        return this
    };
    Request.prototype.send = function (data) {
        var obj = isObject(data);
        var type = this.getHeader("Content-Type");
        if (obj && isObject(this._data)) {
            for (var key in data) {
                this._data[key] = data[key]
            }
        } else if ("string" == typeof data) {
            if (!type)this.type("form");
            type = this.getHeader("Content-Type");
            if ("application/x-www-form-urlencoded" == type) {
                this._data = this._data ? this._data + "&" + data : data
            } else {
                this._data = (this._data || "") + data
            }
        } else {
            this._data = data
        }
        if (!obj)return this;
        if (!type)this.type("json");
        return this
    };
    Request.prototype.callback = function (err, res) {
        var fn = this._callback;
        if (2 == fn.length)return fn(err, res);
        if (err)return this.emit("error", err);
        fn(res)
    };
    Request.prototype.crossDomainError = function () {
        var err = new Error("Origin is not allowed by Access-Control-Allow-Origin");
        err.crossDomain = true;
        this.callback(err)
    };
    Request.prototype.timeoutError = function () {
        var timeout = this._timeout;
        var err = new Error("timeout of " + timeout + "ms exceeded");
        err.timeout = timeout;
        this.callback(err)
    };
    Request.prototype.withCredentials = function () {
        this._withCredentials = true;
        return this
    };
    Request.prototype.responseType = function (type) {
        this._responseType = type;
        return this
    };
    Request.prototype.end = function (fn) {
        var self = this;
        var xhr = this.xhr = getXHR();
        var query = this._query.join("&");
        var timeout = this._timeout;
        var data = this._data;
        this._callback = fn || noop;
        xhr.onreadystatechange = function () {
            if (4 != xhr.readyState)return;
            if (0 == xhr.status) {
                if (self.aborted)return self.timeoutError();
                return self.crossDomainError()
            }
            self.emit("end")
        };
        if (xhr.upload) {
            xhr.upload.onprogress = function (e) {
                e.percent = e.loaded / e.total * 100;
                self.emit("progress", e)
            }
        }
        if (timeout && !this._timer) {
            this._timer = setTimeout(function () {
                self.abort()
            }, timeout)
        }
        if (query) {
            query = request.serializeObject(query);
            this.url += ~this.url.indexOf("?") ? "&" + query : "?" + query
        }
        xhr.open(this.method, this.url, true);
        if (this._withCredentials)xhr.withCredentials = true;
        if (this._responseType)xhr.responseType = this._responseType;
        if ("GET" != this.method && "HEAD" != this.method && "string" != typeof data && !isHost(data)) {
            var serialize = request.serialize[this.getHeader("Content-Type")];
            if (serialize)data = serialize(data)
        }
        for (var field in this.header) {
            if (null == this.header[field])continue;
            xhr.setRequestHeader(field, this.header[field])
        }
        xhr.send(data);
        return this
    };
    request.Request = Request;
    function request(method, url) {
        if ("function" == typeof url) {
            return new Request("GET", method).end(url)
        }
        if (1 == arguments.length) {
            return new Request("GET", method)
        }
        return new Request(method, url)
    }

    request.get = function (url, data, fn) {
        var req = request("GET", url);
        if ("function" == typeof data)fn = data, data = null;
        if (data)req.query(data);
        if (fn)req.end(fn);
        return req
    };
    request.head = function (url, data, fn) {
        var req = request("HEAD", url);
        if ("function" == typeof data)fn = data, data = null;
        if (data)req.send(data);
        if (fn)req.end(fn);
        return req
    };
    request.del = function (url, fn) {
        var req = request("DELETE", url);
        if (fn)req.end(fn);
        return req
    };
    request.patch = function (url, data, fn) {
        var req = request("PATCH", url);
        if ("function" == typeof data)fn = data, data = null;
        if (data)req.send(data);
        if (fn)req.end(fn);
        return req
    };
    request.post = function (url, data, fn) {
        var req = request("POST", url);
        if ("function" == typeof data)fn = data, data = null;
        if (data)req.send(data);
        if (fn)req.end(fn);
        return req
    };
    request.put = function (url, data, fn) {
        var req = request("PUT", url);
        if ("function" == typeof data)fn = data, data = null;
        if (data)req.send(data);
        if (fn)req.end(fn);
        return req
    };
    module.exports = request
}, {emitter: 220, reduce: 221}], 220: [function (require, module, exports) {
    module.exports = Emitter;
    function Emitter(obj) {
        if (obj)return mixin(obj)
    }

    function mixin(obj) {
        for (var key in Emitter.prototype) {
            obj[key] = Emitter.prototype[key]
        }
        return obj
    }

    Emitter.prototype.on = function (event, fn) {
        this._callbacks = this._callbacks || {};
        (this._callbacks[event] = this._callbacks[event] || []).push(fn);
        return this
    };
    Emitter.prototype.once = function (event, fn) {
        var self = this;
        this._callbacks = this._callbacks || {};
        function on() {
            self.off(event, on);
            fn.apply(this, arguments)
        }

        fn._off = on;
        this.on(event, on);
        return this
    };
    Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = function (event, fn) {
        this._callbacks = this._callbacks || {};
        if (0 == arguments.length) {
            this._callbacks = {};
            return this
        }
        var callbacks = this._callbacks[event];
        if (!callbacks)return this;
        if (1 == arguments.length) {
            delete this._callbacks[event];
            return this
        }
        var i = callbacks.indexOf(fn._off || fn);
        if (~i)callbacks.splice(i, 1);
        return this
    };
    Emitter.prototype.emit = function (event) {
        this._callbacks = this._callbacks || {};
        var args = [].slice.call(arguments, 1), callbacks = this._callbacks[event];
        if (callbacks) {
            callbacks = callbacks.slice(0);
            for (var i = 0, len = callbacks.length; i < len; ++i) {
                callbacks[i].apply(this, args)
            }
        }
        return this
    };
    Emitter.prototype.listeners = function (event) {
        this._callbacks = this._callbacks || {};
        return this._callbacks[event] || []
    };
    Emitter.prototype.hasListeners = function (event) {
        return!!this.listeners(event).length
    }
}, {}], 221: [function (require, module, exports) {
    module.exports = function (arr, fn, initial) {
        var idx = 0;
        var len = arr.length;
        var curr = arguments.length == 3 ? initial : arr[idx++];
        while (idx < len) {
            curr = fn.call(null, curr, arr[idx], ++idx, arr)
        }
        return curr
    }
}, {}], 222: [function (require, module, exports) {
    module.exports = Array
}, {}], 223: [function (require, module, exports) {
    (function (global) {
        var rng;
        if (global.crypto && crypto.getRandomValues) {
            var _rnds8 = new Uint8Array(16);
            rng = function whatwgRNG() {
                crypto.getRandomValues(_rnds8);
                return _rnds8
            }
        }
        if (!rng) {
            var _rnds = new Array(16);
            rng = function () {
                for (var i = 0, r; i < 16; i++) {
                    if ((i & 3) === 0)r = Math.random() * 4294967296;
                    _rnds[i] = r >>> ((i & 3) << 3) & 255
                }
                return _rnds
            }
        }
        module.exports = rng
    }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
}, {}], 224: [function (require, module, exports) {
    var _rng = require("./rng");
    var BufferClass = require("./buffer");
    var _byteToHex = [];
    var _hexToByte = {};
    for (var i = 0; i < 256; i++) {
        _byteToHex[i] = (i + 256).toString(16).substr(1);
        _hexToByte[_byteToHex[i]] = i
    }
    function parse(s, buf, offset) {
        var i = buf && offset || 0, ii = 0;
        buf = buf || [];
        s.toLowerCase().replace(/[0-9a-f]{2}/g, function (oct) {
            if (ii < 16) {
                buf[i + ii++] = _hexToByte[oct]
            }
        });
        while (ii < 16) {
            buf[i + ii++] = 0
        }
        return buf
    }

    function unparse(buf, offset) {
        var i = offset || 0, bth = _byteToHex;
        return bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + "-" + bth[buf[i++]] + bth[buf[i++]] + "-" + bth[buf[i++]] + bth[buf[i++]] + "-" + bth[buf[i++]] + bth[buf[i++]] + "-" + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]]
    }

    var _seedBytes = _rng();
    var _nodeId = [_seedBytes[0] | 1, _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]];
    var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 16383;
    var _lastMSecs = 0, _lastNSecs = 0;

    function v1(options, buf, offset) {
        var i = buf && offset || 0;
        var b = buf || [];
        options = options || {};
        var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;
        var msecs = options.msecs !== undefined ? options.msecs : (new Date).getTime();
        var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;
        var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
        if (dt < 0 && options.clockseq === undefined) {
            clockseq = clockseq + 1 & 16383
        }
        if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
            nsecs = 0
        }
        if (nsecs >= 1e4) {
            throw new Error("uuid.v1(): Can't create more than 10M uuids/sec")
        }
        _lastMSecs = msecs;
        _lastNSecs = nsecs;
        _clockseq = clockseq;
        msecs += 122192928e5;
        var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
        b[i++] = tl >>> 24 & 255;
        b[i++] = tl >>> 16 & 255;
        b[i++] = tl >>> 8 & 255;
        b[i++] = tl & 255;
        var tmh = msecs / 4294967296 * 1e4 & 268435455;
        b[i++] = tmh >>> 8 & 255;
        b[i++] = tmh & 255;
        b[i++] = tmh >>> 24 & 15 | 16;
        b[i++] = tmh >>> 16 & 255;
        b[i++] = clockseq >>> 8 | 128;
        b[i++] = clockseq & 255;
        var node = options.node || _nodeId;
        for (var n = 0; n < 6; n++) {
            b[i + n] = node[n]
        }
        return buf ? buf : unparse(b)
    }

    function v4(options, buf, offset) {
        var i = buf && offset || 0;
        if (typeof options == "string") {
            buf = options == "binary" ? new BufferClass(16) : null;
            options = null
        }
        options = options || {};
        var rnds = options.random || (options.rng || _rng)();
        rnds[6] = rnds[6] & 15 | 64;
        rnds[8] = rnds[8] & 63 | 128;
        if (buf) {
            for (var ii = 0; ii < 16; ii++) {
                buf[i + ii] = rnds[ii]
            }
        }
        return buf || unparse(rnds)
    }

    var uuid = v4;
    uuid.v1 = v1;
    uuid.v4 = v4;
    uuid.parse = parse;
    uuid.unparse = unparse;
    uuid.BufferClass = BufferClass;
    module.exports = uuid
}, {"./buffer": 222, "./rng": 223}], 225: [function (require, module, exports) {
    module.exports = {name: "simperium", version: "0.0.0", build: "20131216.32", description: "Simperium client library for Javascript", main: "./index.js", browser: "./index.js", scripts: {test: 'echo "Error: no test specified" && exit 1'}, author: "", license: "GPL2+", dependencies: {uuid: "~1.4.1", debug: "1.0.2", s: "0.1.1", inherits: "2.0.1", superagent: "git://github.com/Simperium/superagent.git#binary-test", "npm-deps": "0.1.1", browserify: "4.1.11", "browserify-shim": "3.5.0"}, devDependencies: {}, readme: "Simperium Javascript Library\n============================\n\nInstalling\n----------\n\n1. `git clone ...`\n2. `cd simperium-js-air`\n3. `make install`\n\nWe use [npm-deps](https://github.com/Automattic/npm-deps), which can cause [annoying `package.json` git changes](https://github.com/Automattic/npm-deps#annoying-packagejson-git-changes).\n\nBuilding\n--------\n\n1. `make build`\n\nTesting\n-------\n\nThere are no tests yet :)\n\nThere is a read-only test client at `./test-client/` that can be viewed in a browser.\n", readmeFilename: "README.md", _id: "simperium@0.0.0", dist: {shasum: "a4784bf2c2258092452b0035f8401f7ad35264ee"}, _resolved: "git+ssh://git@github.com:Simperium/simperium-js-air.git#c7124b082a84e14591316ce6f3a797eca164833e", _from: "simperium@git+ssh://git@github.com:Simperium/simperium-js-air.git"}
}, {}], 226: [function (require, module, exports) {
    (function (Buffer) {
        var format = require("s");
        var request = require("superagent");

        function Binary(bucket, document_id, document_key, source, meta, callback) {
            this.bucket = bucket;
            this.document_id = document_id;
            this.document_key = document_key;
            this.source = source || undefined;
            if ("string" === typeof meta) {
                this.contentType = meta;
                this.meta = undefined
            } else {
                this.contentType = meta["content-type"] || "application/octet-stream";
                this.meta = meta
            }
            this.callback = callback
        }

        function toJSON() {
            return this.meta
        }

        function url(callback) {
            request.get(format("https://api.simperium.com/1/%s/%s/i/%s/b/%s", this.bucket.options.app_id, this.bucket.name, this.document_id, this.document_key)).set("X-Simperium-Token", this.bucket.options.token).set("X-Do-Redirect", "no").end(function (res) {
                if (res.error) {
                    callback(res.error, null, res);
                    return
                }
                if (res.status < 200 || res.status > 299) {
                    callback(res.status, null, res);
                    return
                }
                callback(null, res.text)
            })
        }

        function get(callback) {
            this.url(function (error, url) {
                if (error) {
                    callback(error, null)
                }
                request.get(url).responseType("blob").end(function (res) {
                    if (res.error) {
                        callback(res.error, null, res);
                        return
                    }
                    if (res.status < 200 || res.status > 299) {
                        callback(res.status, null, res);
                        return
                    }
                    callback(null, res.body, res)
                })
            })
        }

        function put(callback) {
            var _this = this;
            callback = callback || this.callback || function () {
            };
            this.getBytes(function (data) {
                request.put(format("https://api.simperium.com/1/%s/%s/i/%s/b/%s", _this.bucket.options.app_id, _this.bucket.name, _this.document_id, _this.document_key)).set("Content-Type", _this.contentType).set("X-Simperium-Token", bucket.options.token).send(data).end(function (res) {
                    if (res.error) {
                        callback(res.error, null, res);
                        return
                    }
                    if (res.status < 200 || res.status > 299) {
                        callback(res.status, null, res);
                        return
                    }
                    callback(null, res.text, res)
                })
            })
        }

        function getBytes(source, callback) {
            var reader;
            if ("string" === typeof source) {
                callback(new Buffer(source, "utf8"));
                return
            }
            if (source instanceof ArrayBuffer) {
                source = new Uint8Array(source)
            }
            if (source instanceof Uint8Array) {
                callback(new Buffer(source));
                return
            }
            if (source instanceof Blob) {
                reader = new FileReader;
                reader.onload = function (event) {
                    getBytes(event.target.result, callback)
                };
                reader.readAsArrayBuffer(source);
                return
            }
            callback(new Uint8Array(0))
        }

        var binaryMeta = ["content-length", "hash", "signature", "mtime", "path", "jsmtime", "content-type", "backend"];

        function parse(object, id, bucket) {
            var i, j, newObject = {};
            for (i in object) {
                if (!object.hasOwnProperty(i)) {
                    continue
                }
                for (j = 0; j < binaryMeta.length; j++) {
                    if ("object" !== typeof object[i] || !(binaryMeta[j]in object[i])) {
                        newObject[i] = object[i];
                        break
                    }
                }
                if (!(i in newObject)) {
                    newObject[i] = new Binary(bucket, id, i, undefined, object[i])
                }
            }
            return newObject
        }

        function mapBinary(object, func_or_object) {
            var i, newObject = {};
            for (i in object) {
                if (!object.hasOwnProperty(i)) {
                    continue
                }
                if (object[i]instanceof Binary) {
                    object[i].document_key = i;
                    if (func_or_object) {
                        if ("function" === typeof func_or_object) {
                            newObject[i] = func_or_object.call(object[i])
                        } else if ("undefined" !== typeof func_or_object[i]) {
                            newObject[i] = func_or_object[i]
                        }
                    } else {
                        newObject[i] = object[i].meta
                    }
                } else {
                    newObject[i] = object[i]
                }
            }
            return newObject
        }

        function haser(func) {
            return function (object) {
                try {
                    mapBinary(object, func)
                } catch (e) {
                    if (e === func) {
                        return true
                    }
                    throw e
                }
                return false
            }
        }

        function throwSomething() {
            throw throwSomething
        }

        function throwSomethingIfSource() {
            if (this.source) {
                throw throwSomethingIfSource
            }
        }

        Binary.prototype.url = url;
        Binary.prototype.get = get;
        Binary.prototype.put = put;
        Binary.prototype.toJSON = toJSON;
        Binary.prototype.getBytes = function (callback) {
            getBytes(this.source, callback)
        };
        Binary.parse = parse;
        Binary.mapBinary = mapBinary;
        Binary.hasBinary = haser(throwSomething);
        Binary.hasBinaryWithSource = haser(throwSomethingIfSource);
        module.exports = Binary
    }).call(this, require("buffer").Buffer)
}, {buffer: 40, s: 218, superagent: 219}], 227: [function (require, module, exports) {
    var events = require("events");
    var format = require("s");
    var inherits = require("inherits");
    var uuid = require("uuid");
    var debug = require("debug")("simperium:bucket");
    var Store = require("./store");
    var LocalStorage = require("./localStorage");
    var Message = require("./message");
    var Cursor = require("./cursor");
    var Binary = require("./binary");
    var config = require("../package.json");
    var bound_methods = ["log", "on", "start", "send", "on_open", "on_close", "load_versions", "get_version", "retrieve_changes", "update", "pending", "on_data", "on_index_page", "on_entity_version", "on_changes", "_entity_id", "_send_changes", "_remote_index"];

    function Bucket(name, options, jsondiff) {
        events.EventEmitter.call(this);
        bound_methods.forEach(function (bound_method) {
            this[bound_method] = this[bound_method].bind(this)
        }, this);
        this.name = name;
        this.jd = jsondiff;
        this.options = options || {};
        this.server_options = {};
        this.chan = this.options.n;
        this.space = format("%s/%s", this.options.app_id, this.name);
        this.username = this.options.username;
        this.namespace = format("%s:%s", this.username, this.space);
        this.store = {meta: new Store, data: new Store};
        if (LocalStorage) {
            this.persist = {meta: new LocalStorage(format("%s/m/", this.namespace)), data: new LocalStorage(format("%s/e/", this.namespace))};
            this.store.meta.pipe(this.persist.meta);
            this.store.data.pipe(this.persist.data)
        } else {
            this.persist = null
        }
        Object.defineProperty(this, "clientid", {get: function () {
            return this.store.meta.get("clientid")
        }, set: function (value) {
            return this.store.meta.set("clientid", value)
        }});
        if (!("persist_clientid"in this.options) || !this.options.persist_clientid) {
            this.clientid = null
        }
        if (!this.clientid || 0 !== this.clientid.indexOf("sjs")) {
            this.clientid = format("sjs-%s-%s", config.build, uuid())
        }
        this.cb_l = null;
        this.connected = false;
        this.initialized = false;
        this.authorized = false;
        if (LocalStorage && (!("nostore"in this.options) || !this.options.nostore)) {
            this.store.meta.fillOnceFrom(this.persist.meta);
            this.loaded = this.store.data.fillOnceFrom(this.persist.data, this._filter_stored_data.bind(this));
            this.log("localstorage loaded %d entities", this.loaded)
        } else {
            this.loaded = 0;
            this.log("not loading from localstorage")
        }
        this.store.meta.add("last_cv", "0");
        this.store.meta.add("ccid", uuid());
        this.data = {send_queue: [], send_queue_timer: null};
        this.started = false;
        this._last_pending = null;
        this._send_backoff = 15e3;
        this._backoff_max = 12e4;
        this._backoff_min = 15e3;
        this.log("bucket created: username=%s, options=%j", this.username, this.options)
    }

    inherits(Bucket, events.EventEmitter);
    Bucket.prototype.log = function (message_format) {
        var args = Array.prototype.slice.call(arguments);
        debug.apply(debug, args);
        args.unshift("log");
        this.emit.apply(this, args)
    };
    Bucket.prototype._on = Bucket.prototype.on;
    Bucket.prototype.on = function (event, callback) {
        if ("local" === event || "get" === event) {
            this.cb_l = callback;
            return this
        }
        return this._on.apply(this, arguments)
    };
    Bucket.prototype._filter_stored_data = function (data) {
        if (!this._verify(data)) {
            this.log("ignoring CORRUPT data=%j", data);
            return
        }
        data.check = null;
        return data
    };
    Bucket.prototype._verify = function (data) {
        if ("object" !== typeof data || !("object"in data) || !("version"in data)) {
            return false
        }
        if (!this.jd.entries(data.object)) {
            if ("last"in data && this.jd.entries(data.last) > 0) {
                return true
            } else {
                return false
            }
        } else {
            if ("undefined" === typeof data.version || null === data.version) {
                return false
            }
        }
        return true
    };
    Bucket.prototype._entity_id = function (id) {
        if ("undefined" === typeof id || null === id) {
            return id
        }
        if (!("expose_namespace"in this.server_options) || !this.server_options.expose_namespace) {
            return id
        }
        if (id.split("/").length > 1) {
            return id
        }
        return format("%s/%s", this.server_options.namespace, id)
    };
    Bucket.prototype.start = function () {
        var init;
        this.log("started initialized=%d, authorized=%d", this.initialized, this.authorized);
        this.namespace = format("%s:%s", this.username, this.space);
        this.started = true;
        this.first = false;
        if (!this.authorized) {
            if (this.connected) {
                this.first = true;
                this.irequest_time = Date.now();
                this.index_request = true;
                this.notify_index = {};
                init = {app_id: this.options.app_id, token: this.options.token, name: this.name, clientid: this.clientid, build: config.build};
                if ("undefined" !== this.options.presence_debounce && this.options.presence_debounce) {
                    init.presence_debounce = this.options.presence_debounce
                }
                if ("undefined" !== this.options.presence_session && this.options.presence_session) {
                    init.presence_session = this.options.presence_session
                }
                if (!this.initialized) {
                    init.cmd = new Message.INDEX({data: 1, limit: "limit"in this.options ? parseInt(this.options.limit, 10) : 40})
                }
                this.send(new Message.INIT(init));
                this.log("sent init=%j waiting for auth", init)
            } else {
                this.log("waiting for connect")
            }
            return
        }
        if (!this.initialized) {
            if (!this.first) {
                this.notify_index = {};
                this._refresh_store()
            }
        } else {
            this.log("retrieve changes from start");
            this.retrieve_changes()
        }
    };
    Bucket.prototype.on_open = function () {
        this.connected = true;
        if (this.started) {
            this.start()
        }
    };
    Bucket.prototype.on_close = function () {
        this.connected = false;
        this.authorized = false
    };
    Bucket.prototype.on_data = function (data) {
        var _this = this;
        if (data instanceof Message.AUTH) {
            if (!data.username) {
                this.log("auth error: %j", data);
                this.started = false;
                this.emit("error", "auth")
            } else {
                this.username = data.username;
                this.authorized = true;
                if (this.initialized) {
                    return this.start()
                }
                this.emit("auth", this.username)
            }
        } else if (data instanceof Message.CHANGE_VERSION && !data.version) {
            this.log("cv out of sync, refreshing index");
            return setTimeout(function () {
                return _this._refresh_store()
            })
        } else if (data instanceof Message.CHANGES && data.changes) {
            if ("0" === this.store.meta.get("last_cv") && 0 === data.changes.length && !this.cv_check) {
                this.cv_check = true;
                this._refresh_store()
            }
            return this.on_changes(this.jd.deepCopy(data.changes))
        } else if (data instanceof Message.INDEX) {
            this.log("index msg received: time_delta=%d", Date.now() - this.irequest_time);
            return this.on_index_page(this.jd.deepCopy(data))
        } else if (data instanceof Message.ENTITY) {
            if (null === data.data) {
                return this.on_entity_version(null, data.id, data.version)
            } else {
                return this.on_entity_version(this.jd.deepCopy(data.data.data), data.id, data.version)
            }
        } else if (data instanceof Message.OPTIONS) {
            this.server_options = this.jd.deepCopy(data);
            this.log("options_received=%j", this.server_options);
            if ("schema"in this.server_options && this.server_options.schema) {
                this.schema = this.server_options.schema;
                this.log("schema=%j", this.schema)
            }
            this.emit("server_options", this.server_options)
        } else if (data instanceof Message.REMOTE_INDEX) {
            return this._remote_index()
        } else {
            return this.log("unknown message: %s", data)
        }
    };
    Bucket.prototype.send = function (message) {
        this.log("sending: %d:%s", this.chan, message.toString());
        this.emit("message", message, this.chan)
    };
    Bucket.prototype._refresh_store = function () {
        this.log("_refresh_store(): loading index");
        this.send(new Message.INDEX({data: 1, limit: "limit"in this.options ? parseInt(this.options.limit, 10) : 40}));
        this.irequest_time = Date.now();
        this.index_request = true
    };
    Bucket.prototype.on_index_page = function (response) {
        var item, loaded, now, page_req, _i, _len, _this = this;
        now = Date.now();
        this.log("index response time: %d", now - this.irequest_time);
        this.log("on_index_page(): index page received, current=%s, response=%j", response["current"], response);
        loaded = 0;
        for (_i = 0, _len = response.index.length; _i < _len; _i++) {
            item = response.index[_i];
            item["id"] = this._entity_id(item["id"]);
            this.notify_index[item["id"]] = false;
            loaded++;
            setTimeout(function (item) {
                return function () {
                    return _this.on_entity_version(item["d"], item["id"], item["v"])
                }
            }(item))
        }
        if (!("mark"in response) || !response.mark || "limit"in this.options) {
            this.index_request = false;
            this.store.meta.set("last_cv", "current"in response && response.current ? response.current : "0");
            if (0 === loaded) {
                return this._index_loaded()
            }
        } else {
            this.index_request = true;
            this.log("index last process time=%d, page_delay=%d", Date.now() - now, this.options["page_delay"]);
            page_req = function (mark) {
                _this.send(new Message.INDEX({data: 1, mark: mark, limit: 100}));
                return _this.irequest_time = Date.now()
            };
            return setTimeout(function (mark) {
                return function () {
                    return page_req(mark)
                }
            }(response.mark), this.options.page_delay)
        }
    };
    Bucket.prototype.load_versions = function (id, versions) {
        var entity, min, max, version;
        id = this._entity_id(id);
        entity = this.store.data.get(id);
        if (!entity) {
            return false
        }
        min = Math.max(entity.version - (versions + 1), 1);
        max = entity.version - 1;
        for (version = min; version <= max; version++) {
            this.log("loading version %s.%d", id, version);
            this.send(new Message.ENTITY({id: id, version: version}))
        }
    };
    Bucket.prototype.get_version = function (id, version) {
        id = this._entity_id(id);
        this.send(new Message.ENTITY({id: id, version: version}))
    };
    Bucket.prototype.on_entity_version = function (data, id, version) {
        var entity, data_copy, nid, notify_event, hasBinary, to_load;
        id = this._entity_id(id);
        this.log("on_entity_version( %j, %s, %s )", data, id, version);
        if (null != data) {
            data_copy = this.jd.deepCopy(data)
        } else {
            data_copy = null
        }
        if (!this.initialized && this.listeners("notify_init").length) {
            notify_event = "notify_init"
        } else {
            notify_event = "notify"
        }
        hasBinary = "binary_backend"in this.server_options && this.server_options.binary_backend;
        entity = this.store.data.get(id);
        if (entity && "last"in entity && this.jd.entries(entity.last)) {
            data_copy = this.jd.deepCopy(entity.last);
            this.emit(notify_event, id, hasBinary ? Binary.parse(data_copy, id, this) : data_copy, null);
            this.notify_index[id] = true;
            return this._check_update(id)
        } else if (entity && version < entity.version) {
            this.emit("notify_version", id, hasBinary ? Binary.parse(data_copy, id, this) : data_copy, version);
            return
        } else {
            if (!entity) {
                entity = {}
            }
            entity.id = id;
            entity.object = data;
            entity.version = parseInt(version, 10);
            this.store.data.set(id, entity);
            this.emit(notify_event, id, hasBinary ? Binary.parse(data_copy, id, this) : data_copy, version);
            this.notify_index[id] = true;
            to_load = 0;
            for (nid in this.notify_index) {
                if (!this.notify_index.hasOwnProperty(nid)) {
                    continue
                }
                if (false === this.notify_index[nid]) {
                    to_load++
                }
            }
            if (!to_load && false === this.index_request) {
                return this._index_loaded()
            }
        }
    };
    Bucket.prototype._index_loaded = function () {
        this.log("index loaded: initialized=%d", this.initialized);
        if (!this.initialized) {
            this.emit("ready")
        }
        this.initialized = true;
        this.log("retrieve changes from index loaded");
        this.retrieve_changes()
    };
    Bucket.prototype._notify_client = function (key, new_object, orig_object, diff, version) {
        var c_object, cursor, captured, element, fieldname, new_data, o_diff, offsets, t_diff, t_object, hasBinary;
        key = this._entity_id(key);
        this.log("_notify_client( %s, %j, %j, %j )", key, new_object, orig_object, diff);
        hasBinary = "binary_backend"in this.server_options && this.server_options.binary_backend;
        if (null == this.cb_l) {
            this.log("no get callback, notifying without transform");
            if (hasBinary) {
                this.emit("notify", key, Binary.parse(new_object, key, this), version)
            } else {
                this.emit("notify", key, new_object, version)
            }
            return
        }
        c_object = this.cb_l(key);
        if (hasBinary && Binary.hasBinary(c_object)) {
            c_object = Binary.mapBinary(c_object, orig_object)
        }
        t_object = null;
        t_diff = null;
        cursor = null;
        offsets = [];
        captured = false;
        if ("array" === this.jd.typeOf(c_object)) {
            element = c_object[2];
            fieldname = c_object[1];
            c_object = c_object[0];
            cursor = new Cursor(element, this.jd.dmp);
            captured = cursor.capture();
            if (captured) {
                offsets[0] = cursor.startOffset;
                if ("endOffset"in cursor) {
                    offsets[1] = cursor.endOffset
                }
            }
        }
        if (null != c_object && null != orig_object) {
            this.log("going to do object diff new diff=%j", diff);
            o_diff = this.jd.object_diff(orig_object, c_object, this.schema);
            this.log("client/server version diff=%j", o_diff);
            if (0 === this.jd.entries(o_diff)) {
                this.log("local diff 0 entries");
                t_diff = diff;
                t_object = orig_object
            } else {
                this.log("client modified doing transform o_diff=%j, orig_object=%j, c_object=%j", o_diff, orig_object, c_object);
                t_diff = this.jd.transform_object_diff(o_diff, diff, orig_object, this.schema);
                t_object = new_object
            }
            if (captured) {
                new_data = this.jd.apply_object_diff_with_offsets(t_object, t_diff, fieldname, offsets);
                if (null != element && "value"in element) {
                    element["value"] = new_data[fieldname]
                }
                cursor.startOffset = offsets[0];
                if (offsets.length > 1) {
                    cursor.endOffset = offsets[1];
                    if (cursor.startOffset >= cursor.endOffset) {
                        cursor.collapsed = true
                    }
                }
                cursor.restore()
            } else {
                this.log("in regular apply_object_diff t_object=%j, t_diff=%j", t_object, t_diff);
                new_data = this.jd.apply_object_diff(t_object, t_diff)
            }
            this.log("notifying client of new data for [%s]=%j", key, new_data)
        } else if (new_object) {
            new_data = new_object
        } else {
            new_data = null;
            version = null
        }
        if (hasBinary) {
            return this.emit("notify", key, Binary.parse(new_data, key, this), version)
        } else {
            return this.emit("notify", key, new_data, version)
        }
    };
    Bucket.prototype._check_update = function (id) {
        var entity, change, found, _i, _len;
        id = this._entity_id(id);
        entity = this.store.data.get(id);
        this.log("_check_update( %s )", id);
        if (!entity) {
            return false
        }
        if (entity.change) {
            found = false;
            for (_i = 0, _len = this.data.send_queue.length; _i < _len; _i++) {
                change = this.data.send_queue[_i];
                if (change["id"] === entity.change["id"] && change["ccid"] === entity.change["ccid"]) {
                    found = true;
                    break
                }
            }
            if (!found) {
                this._queue_change([entity.change, null]);
                return true
            }
            return false
        }
        if (null != entity.check) {
            return false
        }
        if ("last"in entity && this.jd.equals(entity.object, entity.last)) {
            delete entity.last;
            this.store.data.set(id, entity);
            if (this.persist) {
                this.persist.data.delete(id)
            }
            return false
        }
        change = this._make_change(id);
        if (null != change) {
            entity.change = change;
            this.store.data.set(id, entity);
            this._queue_change(change)
        } else if (this.persist) {
            this.persist.data.delete(id)
        }
        return true
    };
    Bucket.prototype.update = function (id, object, patch) {
        var entity, allowed_slashes, change, slashes, hasBinary, object_to_send, _i, _len, _this = this;
        id = this._entity_id(id);
        if (1 === arguments.length) {
            if (null == this.cb_l) {
                throw new Error("missing 'local' callback")
            } else {
                object = this.cb_l(id);
                if ("array" === this.jd.typeOf(object)) {
                    object = object[0]
                }
            }
        }
        this.log("update( %s )", id);
        if (null == id && null == object) {
            return false
        }
        if ("expose_namespace"in this.server_options && this.server_options.expose_namespace) {
            allowed_slashes = 1
        } else {
            allowed_slashes = 0
        }
        hasBinary = "binary_backend"in this.server_options && this.server_options.binary_backend;
        if (null != id) {
            slashes = id.split("/").length - 1;
            if (id.length === 0 || slashes > allowed_slashes) {
                return false
            }
        } else {
            id = uuid();
            id = this._entity_id(id)
        }
        entity = this.store.data.get(id);
        if (!entity) {
            entity = {id: id, object: {}, version: null, change: null, check: null};
            this.store.data.set(id, entity)
        }
        if (patch) {
            object_to_send = this.jd.deepCopy(entity.object);
            Object.keys(object).forEach(function (key) {
                object_to_send[key] = object[key]
            })
        } else {
            object_to_send = object
        }
        if (hasBinary && Binary.hasBinaryWithSource(object)) {
            entity.last = this.jd.deepCopy(Binary.mapBinary(object_to_send));
            entity.binary = object_to_send
        } else {
            entity.last = this.jd.deepCopy(object_to_send)
        }
        this.store.data.set(id, entity);
        for (_i = 0, _len = this.data.send_queue.length; _i < _len; _i++) {
            change = this.data.send_queue[_i];
            if (String(id) === change["id"]) {
                this.log("update( %s ) found pending change, aborting", id);
                return null
            }
        }
        if (null != entity.check) {
            clearTimeout(entity.check)
        }
        entity.check = setTimeout(function (id, entity) {
            return function () {
                var change;
                entity.check = null;
                change = _this._make_change(id);
                entity.change = change[0];
                delete entity.last;
                _this.store.data.set(id, entity);
                return _this._queue_change(change)
            }
        }(id, entity), this.options["update_delay"]);
        return id
    };
    Bucket.prototype._make_change = function (id) {
        var entity, c_object, b_object, change, hasBinary;
        id = this._entity_id(id);
        this.log("_make_change( %s )", id);
        entity = this.store.data.get(id);
        change = {id: String(id), ccid: uuid()};
        hasBinary = "binary_backend"in this.server_options && this.server_options.binary_backend;
        if (!this.initialized) {
            if ("last"in entity) {
                c_object = entity.last;
                b_object = entity.binary || null
            } else {
                return null
            }
        } else {
            if (null == this.cb_l) {
                if ("last"in entity) {
                    c_object = entity.last;
                    b_object = entity.binary || null
                } else {
                    return null
                }
            } else {
                c_object = this.cb_l(id);
                if ("array" === this.jd.typeOf(c_object)) {
                    c_object = c_object[0]
                }
                if (hasBinary && Binary.hasBinary(c_object)) {
                    if (Binary.hasBinaryWithSource(c_object)) {
                        b_object = c_object
                    } else {
                        b_object = null
                    }
                    c_object = Binary.mapBinary(c_object)
                }
            }
        }
        if (null != entity.version) {
            change["sv"] = entity.version
        }
        if (null === c_object && null != entity.version) {
            change["o"] = "-";
            this.log("deletion requested for %s", id)
        } else if (null != c_object && null != entity.object) {
            change["o"] = "M";
            if ("sendfull"in entity) {
                change["d"] = this.jd.deepCopy(c_object);
                delete entity.sendfull;
                this.store.data.set(id, entity)
            } else {
                this.log("object_diff ghost=%j, client=%j, schema=%d", entity.object, c_object, this.schema);
                change["v"] = this.jd.object_diff(entity.object, c_object, this.schema);
                if (0 === this.jd.entries(change["v"])) {
                    change = null
                }
            }
        } else {
            change = null;
            b_object = null
        }
        this.log("_make_change( %s ) returning: %j, binary? %s", id, change, !!b_object);
        return[change, b_object]
    };
    Bucket.prototype._queue_change = function (change) {
        var _this = this;
        var b_object = change[1];
        change = change[0];
        if (null == change) {
            return
        }
        this.log("_queue_change( %s:%s ): sending", change["id"], change["ccid"]);
        this.data.send_queue.push(change);
        this.send(new Message.CHANGES(change));
        if (b_object) {
            Binary.mapBinary(b_object, function () {
                this.put()
            })
        }
        this._check_pending();
        if (null != this.data.send_queue_timer) {
            clearTimeout(this.data.send_queue_timer)
        }
        return this.data.send_queue_timer = setTimeout(this._send_changes, this._send_backoff)
    };
    Bucket.prototype._send_changes = function () {
        var change, _i, _len;
        if (0 === this.data.send_queue.length) {
            this.log("send_queue empty, done");
            this.data.send_queue_timer = null;
            return
        }
        if (!this.connected) {
            this.log("_send_changes: not connected")
        } else {
            for (_i = 0, _len = this.data.send_queue; _i < _len; _i++) {
                change = this.data.send_queue[_i];
                this.log("sending change=%j", change);
                this.send(new Message.CHANGES(change))
            }
        }
        this._send_backoff = this._send_backoff * 2;
        if (this._send_backoff > this._backoff_max) {
            this._send_backoff = this._backoff_max
        }
        return this.data.send_queue_timer = setTimeout(this._send_changes, this._send_backoff)
    };
    Bucket.prototype.retrieve_changes = function () {
        this.log("requesting changes since cv=%s", this.store.meta.get("last_cv"));
        this.send(new Message.CHANGE_VERSION({version: this.store.meta.get("last_cv")}))
    };
    Bucket.prototype.on_changes = function (response) {
        var entity, change, check_updates, id, idx, new_object, op, orig_object, pd, pending, pending_to_delete, reload_needed, _fn, _i, _j, _ilen, _jlen, _this = this;
        check_updates = [];
        reload_needed = false;
        this._send_backoff = this._backoff_min;
        this.log("on_changes(): response=%j", response);
        for (_i = 0, _ilen = response.length; _i < _ilen; _i++) {
            change = response[_i];
            id = change["id"];
            id = this._entity_id(id);
            this.log("on_changes(): processing id=%s", id);
            pending_to_delete = [];
            for (_j = 0, _jlen = this.data.send_queue.length; _j < _jlen; _j++) {
                pending = this.data.send_queue[_j];
                if (change["clientid"] === this.clientid && id === this._entity_id(pending["id"])) {
                    this.log("deleting change for id=%s", id);
                    change["local"] = true;
                    pending_to_delete.push(pending);
                    check_updates.push(id)
                }
            }
            for (_j = 0, _jlen = pending_to_delete.length; _j < _jlen; _j++) {
                pd = pending_to_delete[_j];
                entity = this.store.data.get(this._entity_id(pd["id"]));
                entity.change = null;
                this.store.data.set(id, entity);
                this.data.send_queue = function () {
                    var _i, _ilen, p, _results;
                    _results = [];
                    for (_i = 0, _ilen = this.data.send_queue.length; _i < _ilen; _i++) {
                        p = this.data.send_queue[_i];
                        if (p !== pd) {
                            _results.push(p)
                        }
                    }
                    return _results
                }.call(this)
            }
            if (pending_to_delete.length > 0) {
                this._check_pending()
            }
            this.log("send_queue=%j", this.data.send_queue);
            if ("error"in change && change.error) {
                switch (change.error) {
                    case 412:
                        this.log("on_changes(): empty change, dont check");
                        idx = check_updates.indexOf(id);
                        if (idx > -1) {
                            check_updates.splice(idx, 1)
                        }
                        break;
                    case 409:
                        this.log("on_changes(): duplicate change, ignoring");
                        break;
                    case 405:
                        this.log("on_changes(): bad version");
                        entity = this.store.data.get(id);
                        if (entity) {
                            entity.version = null;
                            this.store.data.set(id, entity)
                        }
                        reload_needed = true;
                        break;
                    case 440:
                        this.log("on_changes(): bad diff, sending full object");
                        entity = this.store.data.get(id);
                        entity.sendfull = true;
                        this.store.data.set(id, entity);
                        break;
                    default:
                        this.log("on_changes(): error for last change, reloading");
                        entity = this.store.data.get(id);
                        if (entity) {
                            entity.version = null;
                            this.store.data.set(id, entity)
                        }
                        reload_needed = true
                }
            } else {
                op = change["o"];
                if ("-" === op) {
                    this.store.data.delete(id);
                    if (!("local"in change)) {
                        this._notify_client(id, null, null, null, null)
                    }
                } else if ("M" === op) {
                    entity = this.store.data.get(id);
                    if ("sv"in change && change.sv && null != entity && null != entity.version && entity.version === change["sv"] || (!("sv"in change) || !change.sv) || 1 === change["ev"]) {
                        if (null == entity) {
                            entity = {id: id, object: {}, version: null, change: null, check: null}
                        }
                        this.log("processing modify for %j", entity);
                        orig_object = this.jd.deepCopy(entity.object);
                        entity.object = this.jd.apply_object_diff(entity.object, change["v"]);
                        entity.version = change["ev"];
                        this.store.data.set(id, entity);
                        new_object = this.jd.deepCopy(entity.object);
                        if (!("local"in change)) {
                            this._notify_client(id, new_object, orig_object, change["v"], change["ev"])
                        }
                    } else if (null != entity && null != entity.version && change["ev"] <= entity.version) {
                        this.log("old or duplicate change received, ignoring, change.ev=%s, entity.version=%s", change["ev"], entity.version)
                    } else {
                        if (null == entity) {
                            this.log("version mismatch couldnt apply change, change.ev=%s, entity=null", change["ev"])
                        } else {
                            this.log("version mismatch couldnt apply change, change.ev=%s, entity.version=%s", change["ev"], entity.version);
                            entity.version = null;
                            this.store.data.set(id, entity)
                        }
                        reload_needed = true
                    }
                } else {
                    this.log("no operation found for change")
                }
                if (!reload_needed) {
                    this.store.meta.set("last_cv", change["cv"]);
                    this.log("checkpoint cv=%s, ccid=%s", this.store.meta.get("last_cv"), this.store.meta.get("ccid"))
                }
            }
        }
        if (reload_needed) {
            this.log("reload needed, refreshing store");
            setTimeout(function () {
                return _this._refresh_store()
            })
        } else {
            _fn = function (id) {
                return setTimeout(function () {
                    return _this._check_update(id)
                }, _this.options["update_delay"])
            };
            for (_i = 0, _ilen = check_updates.length; _i < _ilen; _i++) {
                id = check_updates[_i];
                _fn(id)
            }
        }
    };
    Bucket.prototype.pending = function () {
        var pending_ids, _i, _len;
        pending_ids = [];
        for (_i = 0, _len = this.data.send_queue.length; _i < _len; _i++) {
            pending_ids.push(this._entity_id(this.data.send_queue[_i].id))
        }
        this.log("pending=%j", pending_ids);
        return pending_ids
    };
    Bucket.prototype._check_pending = function () {
        var curr_pending, diff, _i, _len;
        if (!this.listeners("notify_pending").length) {
            return
        }
        curr_pending = this.pending();
        diff = true;
        if (this._last_pending) {
            diff = false;
            if (this._last_pending.length === curr_pending.length) {
                for (_i = 0, _len = this._last_pending.length; _i < _len; _i++) {
                    if (-1 === curr_pending.indexOf(this._last_pending[_i])) {
                        diff = true
                    }
                }
            } else {
                diff = true
            }
        }
        if (diff) {
            this._last_pending = curr_pending;
            this.emit("notify_pending", curr_pending)
        }
    };
    Bucket.prototype._remote_index = function () {
        var remote_index, _i, _len;
        remote_index = {current: this.store.meta.get("last_cv"), index: [], pending: []};
        this.store.data.keys().forEach(function (key) {
            remote_index["index"].push({id: key, v: this.store.data.get(key).version})
        }, this);
        for (_i = 0, _len = this.data.send_queue.length; _i < _len; _i++) {
            remote_index["pending"].push(this.jd.deepCopy(this.data.send_queue[_i]))
        }
        return this.send(new Message.REMOTE_INDEX(remote_index))
    };
    Bucket.prototype.binary = function (id, key, source, meta, callback) {
        return new Binary(this, id, key, source, meta, callback)
    };
    module.exports = Bucket
}, {"../package.json": 225, "./binary": 226, "./cursor": 229, "./localStorage": 232, "./message": 233, "./store": 236, debug: 215, events: 44, inherits: 52, s: 218, uuid: 224}], 228: [function (require, module, exports) {
    var events = require("events");
    var format = require("s");
    var inherits = require("inherits");
    var SockJS = require("./sockjs-client-wrapper");
    var Message = require("./message");

    function Connection(options) {
        events.EventEmitter.call(this);
        this.options = {};
        Object.getOwnPropertyNames(this.defaults).concat(Object.getOwnPropertyNames(options)).forEach(function (property) {
            if (property in this.options) {
                return
            }
            if (property in options) {
                this.options[property] = options[property]
            } else {
                this.options[property] = this.defaults[property]
            }
        }, this);
        if (!("port"in this.options)) {
            this.options.port = -1 === this.options.host.indexOf("api.simperium.com") ? 80 : 443
        }
        if (!("scheme"in this.options) || "http" !== this.options.scheme && "https" !== this.options.scheme) {
            this.options.scheme = 443 === this.options.port ? "https" : "http"
        }
        if (80 === this.options.port && "http" === this.options.scheme || 443 === this.options.port && "https" === this.options.scheme) {
            this.url = format("%s://%s/%s", this.options.scheme, this.options.host, this.options.path)
        } else {
            this.url = format("%s://%s:%d/%s", this.options.scheme, this.options.host, this.options.port, this.options.path)
        }
        this.stopped = false;
        this.backoff = this.options.backoff;
        this.hb = this.options.hb;
        this.hb_check = this.hb_check.bind(this);
        this.connect = this.connect.bind(this);
        this.connect()
    }

    inherits(Connection, events.EventEmitter);
    Connection.prototype.defaults = {debug: false, backoff: 3e3, hb: 1, host: "api.simperium.com"};
    Connection.prototype.connect = function () {
        this.hb_timer = null;
        this.last_message_time = 0;
        this.sock = new SockJS(this.url, undefined, this.options);
        this.sock.onopen = this._on_open.bind(this);
        this.sock.onerror = this._on_error.bind(this);
        this.sock.onmessage = this._on_message.bind(this);
        this.sock.onclose = this._on_close.bind(this)
    };
    Connection.prototype.start = function () {
        this.stopped = false
    };
    Connection.prototype.stop = function () {
        this.stopped = true;
        if ("undefined" !== typeof this.sock && this.sock) {
            try {
                this.sock.close()
            } catch (error) {
            }
        }
    };
    Connection.prototype.send = function (message) {
        this.sock.send(message.toString())
    };
    Connection.prototype._on_open = function () {
        this.backoff = this.options.backoff;
        this.hb_timer = setTimeout(this.hb_check, 2e4);
        this.emit("open")
    };
    Connection.prototype._on_close = function () {
        if (this.backoff < 4e3) {
            this.backoff = this.backoff + 1
        } else {
            this.backoff = 15e3
        }
        if (this.hb_timer) {
            clearTimeout(this.hb_timer);
            this.hb_timer = null
        }
        if (!this.stopped) {
            setTimeout(this.connect, this.backoff)
        }
    };
    Connection.prototype._on_error = function (error) {
        this.emit("error", error);
        this.stop()
    };
    Connection.prototype._on_message = function (event) {
        var data, colon, channel, message;
        this.last_message_time = Date.now();
        data = event.data;
        colon = data.indexOf(":");
        channel = parseInt(data.substr(0, colon), 10);
        try {
            if (isNaN(channel)) {
                channel = null;
                message = Message.parse(data)
            } else {
                message = Message.parse(data.substr(colon + 1))
            }
        } catch (error) {
            return
        }
        if (message instanceof Message.HEARTBEAT) {
            this.hb = parseInt(data.substr(2), 10);
            return
        }
        this.emit("message", message, channel)
    };
    Connection.prototype.hb_check = function () {
        var delay;
        if (this.sock.readyState !== this.sock.OPEN) {
            return
        }
        delay = Date.now() - this.last_message_time;
        if (delay > 4e4) {
            this.sock.close()
        } else if (delay > 15e3) {
            this.sock.send(format("h:%d", this.hb))
        }
        this.hb_timer = setTimeout(this.hb_check, 2e4)
    };
    module.exports = Connection
}, {"./message": 233, "./sockjs-client-wrapper": 235, events: 44, inherits: 52, s: 218}], 229: [function (require, module, exports) {
    function Cursor(element, diffMatchPatch) {
        this.element = element;
        this.dmp = diffMatchPatch
    }

    Cursor.prototype.capture = function () {
        var text, selectionStart, selectionEnd, doc, range, newRange;
        if ("activeElement"in this.element && !this.element.activeElement) {
            return false
        }
        this.padLength = this.dmp.Match_MaxBits / 2;
        text = this.element.value;
        if ("selectionStart"in this.element) {
            try {
                selectionStart = this.element.selectionStart;
                selectionEnd = this.element.selectionEnd
            } catch (error) {
                return false
            }
            this.startPrefix = text.substring(selectionStart - this.padLength, selectionStart);
            this.startSuffix = text.substring(selectionStart, selectionStart + this.padLength);
            this.startOffset = selectionStart;
            this.collapsed = selectionStart == selectionEnd;
            if (!this.collapsed) {
                this.endPrefix = text.substring(selectionEnd - this.padLength, selectionEnd);
                this.endSuffix = text.substring(selectionEnd, selectionEnd + this.padLength);
                this.endOffset = selectionEnd
            }
        } else {
            doc = this.element;
            while (doc.parentNode) {
                doc = doc.parentNode
            }
            if (!doc.selection || !doc.selection.createRange) {
                return false
            }
            range = doc.selection.createRange();
            if (range.parentElement() !== this.element) {
                return false
            }
            newRange = doc.body.createTextRange();
            this.collapsed = "" === range.text;
            newRange.moveToElementText(this.element);
            if (!this.collapsed) {
                newRange.setEndPoint("EndToEnd", range);
                this.endPrefix = newRange.text;
                this.endOffset = this.endPrefix.length;
                this.endPrefix = this.endPrefix.substring(this.endPrefix.length - this.padLength)
            }
            newRange.setEndPoint("EndToStart", range);
            this.startPrefix = newRange.text;
            this.startOffset = this.startPrefix.length;
            this.startPrefix = this.startPrefix.substring(this.startPrefix.length - this.padLength);
            newRange.moveToElementText(this.element);
            newRange.setEndPoint("StartToStart", range);
            this.startSuffix = newRange.text.substring(0, this.padLength);
            if (!this.collapsed) {
                newRange.setEndPoint("StartToEnd", range);
                this.endSuffix = newRange.text.substring(0, this.padLength)
            }
        }
        if ("scrollTop"in this.element) {
            this.scrollTop = this.element.scrollTop / this.element.scrollHeight;
            this.scrollLeft = this.element.scrollLeft / this.element.scrollWidth
        }
        return true
    };
    Cursor.prototype.restore = function () {
        var newText, pattern1, pattern2, diff, cursorStartPoint, cursorEndPoint, doc, snippet, ieStartPoint, newRange;
        var dmpSettings = [this.dmp.Match_Distance, this.dmp.Match_Threshold];
        this.dmp.Match_Distance = 1e3;
        this.dmp.Match_Threshold = .9;
        newText = this.element.value;
        pattern1 = this.startPrefix + this.startSuffix;
        cursorStartPoint = this.dmp.match_main(newText, pattern1, this.startOffset - this.padLength);
        if (null !== cursorStartPoint) {
            pattern2 = newText.substring(cursorStartPoint, cursorStartPoint + pattern1.length);
            diff = this.dmp.diff_main(pattern1, pattern2, false);
            cursorStartPoint += this.dmp.diff_xIndex(diff, this.startPrefix.length)
        }
        cursorEndPoint = null;
        if (!this.collapsed) {
            pattern1 = this.endPrefix + this.endSuffix;
            cursorEndPoint = this.dmp.match_main(newText, pattern1, this.endOffset - this.padLength);
            if (null !== cursorEndPoint) {
                pattern2 = newText.substring(cursorEndPoint, cursorEndPoint + pattern1.length);
                diff = this.dmp.diff_main(pattern1, pattern2, false);
                cursorEndPoint += this.dmp.diff_xIndex(diff, this.endPrefix.length)
            }
        }
        this.dmp.Match_Distance = dmpSettings[0];
        this.dmp.Match_Threshold = dmpSettings[1];
        if (null === cursorStartPoint && null !== cursorEndPoint) {
            cursorStartPoint = cursorEndPoint
        } else if (null === cursorStartPoint && null === cursorEndPoint) {
            cursorStartPoint = this.startOffset
        }
        if (null === cursorEndPoint) {
            cursorEndPoint = cursorStartPoint
        }
        if ("selectionStart"in this.element) {
            this.element.selectionStart = cursorStartPoint;
            this.element.selectionEnd = cursorEndPoint
        } else {
            doc = this.element;
            while (doc.parentNode) {
                doc = doc.parentNode
            }
            if (!doc.selection || !doc.selection.createRange) {
                return
            }
            snippet = this.element.value.substring(0, cursorStartPoint);
            ieStartPoint = snippet.replace(/\r\n/g, "\n").length;
            newRange = doc.body.createTextRange();
            newRange.moveToElementText(this.element);
            newRange.collapse(true);
            newRange.moveStart("character", ieStartPoint);
            if (!this.collapsed) {
                snippet = this.element.value.substring(cursorStartPoint, cursorEndPoint);
                var ieMidLength = snippet.replace(/\r\n/g, "\n").length;
                newRange.moveEnd("character", ieMidLength)
            }
            newRange.select()
        }
        if ("scrollTop"in this) {
            this.element.scrollTop = this.scrollTop * this.element.scrollHeight;
            this.element.scrollLeft = this.scrollLeft * this.element.scrollWidth
        }
    };
    module.exports = Cursor
}, {}], 230: [function (require, module, exports) {
    (function (global) {
        __browserify_shim_require__ = require;
        (function browserifyShim(module, exports, require, define, browserify_shim__define__module__export__) {
            function diff_match_patch() {
                this.Diff_Timeout = 1;
                this.Diff_EditCost = 4;
                this.Match_Threshold = .5;
                this.Match_Distance = 1e3;
                this.Patch_DeleteThreshold = .5;
                this.Patch_Margin = 4;
                this.Match_MaxBits = 32
            }

            var DIFF_DELETE = -1;
            var DIFF_INSERT = 1;
            var DIFF_EQUAL = 0;
            diff_match_patch.Diff;
            diff_match_patch.prototype.diff_main = function (text1, text2, opt_checklines, opt_deadline) {
                if (typeof opt_deadline == "undefined") {
                    if (this.Diff_Timeout <= 0) {
                        opt_deadline = Number.MAX_VALUE
                    } else {
                        opt_deadline = (new Date).getTime() + this.Diff_Timeout * 1e3
                    }
                }
                var deadline = opt_deadline;
                if (text1 == null || text2 == null) {
                    throw new Error("Null input. (diff_main)")
                }
                if (text1 == text2) {
                    if (text1) {
                        return[
                            [DIFF_EQUAL, text1]
                        ]
                    }
                    return[]
                }
                if (typeof opt_checklines == "undefined") {
                    opt_checklines = true
                }
                var checklines = opt_checklines;
                var commonlength = this.diff_commonPrefix(text1, text2);
                var commonprefix = text1.substring(0, commonlength);
                text1 = text1.substring(commonlength);
                text2 = text2.substring(commonlength);
                commonlength = this.diff_commonSuffix(text1, text2);
                var commonsuffix = text1.substring(text1.length - commonlength);
                text1 = text1.substring(0, text1.length - commonlength);
                text2 = text2.substring(0, text2.length - commonlength);
                var diffs = this.diff_compute_(text1, text2, checklines, deadline);
                if (commonprefix) {
                    diffs.unshift([DIFF_EQUAL, commonprefix])
                }
                if (commonsuffix) {
                    diffs.push([DIFF_EQUAL, commonsuffix])
                }
                this.diff_cleanupMerge(diffs);
                return diffs
            };
            diff_match_patch.prototype.diff_compute_ = function (text1, text2, checklines, deadline) {
                var diffs;
                if (!text1) {
                    return[
                        [DIFF_INSERT, text2]
                    ]
                }
                if (!text2) {
                    return[
                        [DIFF_DELETE, text1]
                    ]
                }
                var longtext = text1.length > text2.length ? text1 : text2;
                var shorttext = text1.length > text2.length ? text2 : text1;
                var i = longtext.indexOf(shorttext);
                if (i != -1) {
                    diffs = [
                        [DIFF_INSERT, longtext.substring(0, i)],
                        [DIFF_EQUAL, shorttext],
                        [DIFF_INSERT, longtext.substring(i + shorttext.length)]
                    ];
                    if (text1.length > text2.length) {
                        diffs[0][0] = diffs[2][0] = DIFF_DELETE
                    }
                    return diffs
                }
                if (shorttext.length == 1) {
                    return[
                        [DIFF_DELETE, text1],
                        [DIFF_INSERT, text2]
                    ]
                }
                longtext = shorttext = null;
                var hm = this.diff_halfMatch_(text1, text2);
                if (hm) {
                    var text1_a = hm[0];
                    var text1_b = hm[1];
                    var text2_a = hm[2];
                    var text2_b = hm[3];
                    var mid_common = hm[4];
                    var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);
                    var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);
                    return diffs_a.concat([
                        [DIFF_EQUAL, mid_common]
                    ], diffs_b)
                }
                if (checklines && text1.length > 100 && text2.length > 100) {
                    return this.diff_lineMode_(text1, text2, deadline)
                }
                return this.diff_bisect_(text1, text2, deadline)
            };
            diff_match_patch.prototype.diff_lineMode_ = function (text1, text2, deadline) {
                var a = this.diff_linesToChars_(text1, text2);
                text1 = a.chars1;
                text2 = a.chars2;
                var linearray = a.lineArray;
                var diffs = this.diff_main(text1, text2, false, deadline);
                this.diff_charsToLines_(diffs, linearray);
                this.diff_cleanupSemantic(diffs);
                diffs.push([DIFF_EQUAL, ""]);
                var pointer = 0;
                var count_delete = 0;
                var count_insert = 0;
                var text_delete = "";
                var text_insert = "";
                while (pointer < diffs.length) {
                    switch (diffs[pointer][0]) {
                        case DIFF_INSERT:
                            count_insert++;
                            text_insert += diffs[pointer][1];
                            break;
                        case DIFF_DELETE:
                            count_delete++;
                            text_delete += diffs[pointer][1];
                            break;
                        case DIFF_EQUAL:
                            if (count_delete >= 1 && count_insert >= 1) {
                                diffs.splice(pointer - count_delete - count_insert, count_delete + count_insert);
                                pointer = pointer - count_delete - count_insert;
                                var a = this.diff_main(text_delete, text_insert, false, deadline);
                                for (var j = a.length - 1; j >= 0; j--) {
                                    diffs.splice(pointer, 0, a[j])
                                }
                                pointer = pointer + a.length
                            }
                            count_insert = 0;
                            count_delete = 0;
                            text_delete = "";
                            text_insert = "";
                            break
                    }
                    pointer++
                }
                diffs.pop();
                return diffs
            };
            diff_match_patch.prototype.diff_bisect_ = function (text1, text2, deadline) {
                var text1_length = text1.length;
                var text2_length = text2.length;
                var max_d = Math.ceil((text1_length + text2_length) / 2);
                var v_offset = max_d;
                var v_length = 2 * max_d;
                var v1 = new Array(v_length);
                var v2 = new Array(v_length);
                for (var x = 0; x < v_length; x++) {
                    v1[x] = -1;
                    v2[x] = -1
                }
                v1[v_offset + 1] = 0;
                v2[v_offset + 1] = 0;
                var delta = text1_length - text2_length;
                var front = delta % 2 != 0;
                var k1start = 0;
                var k1end = 0;
                var k2start = 0;
                var k2end = 0;
                for (var d = 0; d < max_d; d++) {
                    if ((new Date).getTime() > deadline) {
                        break
                    }
                    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
                        var k1_offset = v_offset + k1;
                        var x1;
                        if (k1 == -d || k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1]) {
                            x1 = v1[k1_offset + 1]
                        } else {
                            x1 = v1[k1_offset - 1] + 1
                        }
                        var y1 = x1 - k1;
                        while (x1 < text1_length && y1 < text2_length && text1.charAt(x1) == text2.charAt(y1)) {
                            x1++;
                            y1++
                        }
                        v1[k1_offset] = x1;
                        if (x1 > text1_length) {
                            k1end += 2
                        } else if (y1 > text2_length) {
                            k1start += 2
                        } else if (front) {
                            var k2_offset = v_offset + delta - k1;
                            if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
                                var x2 = text1_length - v2[k2_offset];
                                if (x1 >= x2) {
                                    return this.diff_bisectSplit_(text1, text2, x1, y1, deadline)
                                }
                            }
                        }
                    }
                    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
                        var k2_offset = v_offset + k2;
                        var x2;
                        if (k2 == -d || k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1]) {
                            x2 = v2[k2_offset + 1]
                        } else {
                            x2 = v2[k2_offset - 1] + 1
                        }
                        var y2 = x2 - k2;
                        while (x2 < text1_length && y2 < text2_length && text1.charAt(text1_length - x2 - 1) == text2.charAt(text2_length - y2 - 1)) {
                            x2++;
                            y2++
                        }
                        v2[k2_offset] = x2;
                        if (x2 > text1_length) {
                            k2end += 2
                        } else if (y2 > text2_length) {
                            k2start += 2
                        } else if (!front) {
                            var k1_offset = v_offset + delta - k2;
                            if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
                                var x1 = v1[k1_offset];
                                var y1 = v_offset + x1 - k1_offset;
                                x2 = text1_length - x2;
                                if (x1 >= x2) {
                                    return this.diff_bisectSplit_(text1, text2, x1, y1, deadline)
                                }
                            }
                        }
                    }
                }
                return[
                    [DIFF_DELETE, text1],
                    [DIFF_INSERT, text2]
                ]
            };
            diff_match_patch.prototype.diff_bisectSplit_ = function (text1, text2, x, y, deadline) {
                var text1a = text1.substring(0, x);
                var text2a = text2.substring(0, y);
                var text1b = text1.substring(x);
                var text2b = text2.substring(y);
                var diffs = this.diff_main(text1a, text2a, false, deadline);
                var diffsb = this.diff_main(text1b, text2b, false, deadline);
                return diffs.concat(diffsb)
            };
            diff_match_patch.prototype.diff_linesToChars_ = function (text1, text2) {
                var lineArray = [];
                var lineHash = {};
                lineArray[0] = "";
                function diff_linesToCharsMunge_(text) {
                    var chars = "";
                    var lineStart = 0;
                    var lineEnd = -1;
                    var lineArrayLength = lineArray.length;
                    while (lineEnd < text.length - 1) {
                        lineEnd = text.indexOf("\n", lineStart);
                        if (lineEnd == -1) {
                            lineEnd = text.length - 1
                        }
                        var line = text.substring(lineStart, lineEnd + 1);
                        lineStart = lineEnd + 1;
                        if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) : lineHash[line] !== undefined) {
                            chars += String.fromCharCode(lineHash[line])
                        } else {
                            chars += String.fromCharCode(lineArrayLength);
                            lineHash[line] = lineArrayLength;
                            lineArray[lineArrayLength++] = line
                        }
                    }
                    return chars
                }

                var chars1 = diff_linesToCharsMunge_(text1);
                var chars2 = diff_linesToCharsMunge_(text2);
                return{chars1: chars1, chars2: chars2, lineArray: lineArray}
            };
            diff_match_patch.prototype.diff_charsToLines_ = function (diffs, lineArray) {
                for (var x = 0; x < diffs.length; x++) {
                    var chars = diffs[x][1];
                    var text = [];
                    for (var y = 0; y < chars.length; y++) {
                        text[y] = lineArray[chars.charCodeAt(y)]
                    }
                    diffs[x][1] = text.join("")
                }
            };
            diff_match_patch.prototype.diff_commonPrefix = function (text1, text2) {
                if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
                    return 0
                }
                var pointermin = 0;
                var pointermax = Math.min(text1.length, text2.length);
                var pointermid = pointermax;
                var pointerstart = 0;
                while (pointermin < pointermid) {
                    if (text1.substring(pointerstart, pointermid) == text2.substring(pointerstart, pointermid)) {
                        pointermin = pointermid;
                        pointerstart = pointermin
                    } else {
                        pointermax = pointermid
                    }
                    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin)
                }
                return pointermid
            };
            diff_match_patch.prototype.diff_commonSuffix = function (text1, text2) {
                if (!text1 || !text2 || text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
                    return 0
                }
                var pointermin = 0;
                var pointermax = Math.min(text1.length, text2.length);
                var pointermid = pointermax;
                var pointerend = 0;
                while (pointermin < pointermid) {
                    if (text1.substring(text1.length - pointermid, text1.length - pointerend) == text2.substring(text2.length - pointermid, text2.length - pointerend)) {
                        pointermin = pointermid;
                        pointerend = pointermin
                    } else {
                        pointermax = pointermid
                    }
                    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin)
                }
                return pointermid
            };
            diff_match_patch.prototype.diff_commonOverlap_ = function (text1, text2) {
                var text1_length = text1.length;
                var text2_length = text2.length;
                if (text1_length == 0 || text2_length == 0) {
                    return 0
                }
                if (text1_length > text2_length) {
                    text1 = text1.substring(text1_length - text2_length)
                } else if (text1_length < text2_length) {
                    text2 = text2.substring(0, text1_length)
                }
                var text_length = Math.min(text1_length, text2_length);
                if (text1 == text2) {
                    return text_length
                }
                var best = 0;
                var length = 1;
                while (true) {
                    var pattern = text1.substring(text_length - length);
                    var found = text2.indexOf(pattern);
                    if (found == -1) {
                        return best
                    }
                    length += found;
                    if (found == 0 || text1.substring(text_length - length) == text2.substring(0, length)) {
                        best = length;
                        length++
                    }
                }
            };
            diff_match_patch.prototype.diff_halfMatch_ = function (text1, text2) {
                if (this.Diff_Timeout <= 0) {
                    return null
                }
                var longtext = text1.length > text2.length ? text1 : text2;
                var shorttext = text1.length > text2.length ? text2 : text1;
                if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
                    return null
                }
                var dmp = this;

                function diff_halfMatchI_(longtext, shorttext, i) {
                    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
                    var j = -1;
                    var best_common = "";
                    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
                    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {
                        var prefixLength = dmp.diff_commonPrefix(longtext.substring(i), shorttext.substring(j));
                        var suffixLength = dmp.diff_commonSuffix(longtext.substring(0, i), shorttext.substring(0, j));
                        if (best_common.length < suffixLength + prefixLength) {
                            best_common = shorttext.substring(j - suffixLength, j) + shorttext.substring(j, j + prefixLength);
                            best_longtext_a = longtext.substring(0, i - suffixLength);
                            best_longtext_b = longtext.substring(i + prefixLength);
                            best_shorttext_a = shorttext.substring(0, j - suffixLength);
                            best_shorttext_b = shorttext.substring(j + prefixLength)
                        }
                    }
                    if (best_common.length * 2 >= longtext.length) {
                        return[best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b, best_common]
                    } else {
                        return null
                    }
                }

                var hm1 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 4));
                var hm2 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 2));
                var hm;
                if (!hm1 && !hm2) {
                    return null
                } else if (!hm2) {
                    hm = hm1
                } else if (!hm1) {
                    hm = hm2
                } else {
                    hm = hm1[4].length > hm2[4].length ? hm1 : hm2
                }
                var text1_a, text1_b, text2_a, text2_b;
                if (text1.length > text2.length) {
                    text1_a = hm[0];
                    text1_b = hm[1];
                    text2_a = hm[2];
                    text2_b = hm[3]
                } else {
                    text2_a = hm[0];
                    text2_b = hm[1];
                    text1_a = hm[2];
                    text1_b = hm[3]
                }
                var mid_common = hm[4];
                return[text1_a, text1_b, text2_a, text2_b, mid_common]
            };
            diff_match_patch.prototype.diff_cleanupSemantic = function (diffs) {
                var changes = false;
                var equalities = [];
                var equalitiesLength = 0;
                var lastequality = null;
                var pointer = 0;
                var length_insertions1 = 0;
                var length_deletions1 = 0;
                var length_insertions2 = 0;
                var length_deletions2 = 0;
                while (pointer < diffs.length) {
                    if (diffs[pointer][0] == DIFF_EQUAL) {
                        equalities[equalitiesLength++] = pointer;
                        length_insertions1 = length_insertions2;
                        length_deletions1 = length_deletions2;
                        length_insertions2 = 0;
                        length_deletions2 = 0;
                        lastequality = diffs[pointer][1]
                    } else {
                        if (diffs[pointer][0] == DIFF_INSERT) {
                            length_insertions2 += diffs[pointer][1].length
                        } else {
                            length_deletions2 += diffs[pointer][1].length
                        }
                        if (lastequality && lastequality.length <= Math.max(length_insertions1, length_deletions1) && lastequality.length <= Math.max(length_insertions2, length_deletions2)) {
                            diffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE, lastequality]);
                            diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
                            equalitiesLength--;
                            equalitiesLength--;
                            pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
                            length_insertions1 = 0;
                            length_deletions1 = 0;
                            length_insertions2 = 0;
                            length_deletions2 = 0;
                            lastequality = null;
                            changes = true
                        }
                    }
                    pointer++
                }
                if (changes) {
                    this.diff_cleanupMerge(diffs)
                }
                this.diff_cleanupSemanticLossless(diffs);
                pointer = 1;
                while (pointer < diffs.length) {
                    if (diffs[pointer - 1][0] == DIFF_DELETE && diffs[pointer][0] == DIFF_INSERT) {
                        var deletion = diffs[pointer - 1][1];
                        var insertion = diffs[pointer][1];
                        var overlap_length1 = this.diff_commonOverlap_(deletion, insertion);
                        var overlap_length2 = this.diff_commonOverlap_(insertion, deletion);
                        if (overlap_length1 >= overlap_length2) {
                            if (overlap_length1 >= deletion.length / 2 || overlap_length1 >= insertion.length / 2) {
                                diffs.splice(pointer, 0, [DIFF_EQUAL, insertion.substring(0, overlap_length1)]);
                                diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlap_length1);
                                diffs[pointer + 1][1] = insertion.substring(overlap_length1);
                                pointer++
                            }
                        } else {
                            if (overlap_length2 >= deletion.length / 2 || overlap_length2 >= insertion.length / 2) {
                                diffs.splice(pointer, 0, [DIFF_EQUAL, deletion.substring(0, overlap_length2)]);
                                diffs[pointer - 1][0] = DIFF_INSERT;
                                diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlap_length2);
                                diffs[pointer + 1][0] = DIFF_DELETE;
                                diffs[pointer + 1][1] = deletion.substring(overlap_length2);
                                pointer++
                            }
                        }
                        pointer++
                    }
                    pointer++
                }
            };
            diff_match_patch.prototype.diff_cleanupSemanticLossless = function (diffs) {
                function diff_cleanupSemanticScore_(one, two) {
                    if (!one || !two) {
                        return 6
                    }
                    var char1 = one.charAt(one.length - 1);
                    var char2 = two.charAt(0);
                    var nonAlphaNumeric1 = char1.match(diff_match_patch.nonAlphaNumericRegex_);
                    var nonAlphaNumeric2 = char2.match(diff_match_patch.nonAlphaNumericRegex_);
                    var whitespace1 = nonAlphaNumeric1 && char1.match(diff_match_patch.whitespaceRegex_);
                    var whitespace2 = nonAlphaNumeric2 && char2.match(diff_match_patch.whitespaceRegex_);
                    var lineBreak1 = whitespace1 && char1.match(diff_match_patch.linebreakRegex_);
                    var lineBreak2 = whitespace2 && char2.match(diff_match_patch.linebreakRegex_);
                    var blankLine1 = lineBreak1 && one.match(diff_match_patch.blanklineEndRegex_);
                    var blankLine2 = lineBreak2 && two.match(diff_match_patch.blanklineStartRegex_);
                    if (blankLine1 || blankLine2) {
                        return 5
                    } else if (lineBreak1 || lineBreak2) {
                        return 4
                    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
                        return 3
                    } else if (whitespace1 || whitespace2) {
                        return 2
                    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
                        return 1
                    }
                    return 0
                }

                var pointer = 1;
                while (pointer < diffs.length - 1) {
                    if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {
                        var equality1 = diffs[pointer - 1][1];
                        var edit = diffs[pointer][1];
                        var equality2 = diffs[pointer + 1][1];
                        var commonOffset = this.diff_commonSuffix(equality1, edit);
                        if (commonOffset) {
                            var commonString = edit.substring(edit.length - commonOffset);
                            equality1 = equality1.substring(0, equality1.length - commonOffset);
                            edit = commonString + edit.substring(0, edit.length - commonOffset);
                            equality2 = commonString + equality2
                        }
                        var bestEquality1 = equality1;
                        var bestEdit = edit;
                        var bestEquality2 = equality2;
                        var bestScore = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
                        while (edit.charAt(0) === equality2.charAt(0)) {
                            equality1 += edit.charAt(0);
                            edit = edit.substring(1) + equality2.charAt(0);
                            equality2 = equality2.substring(1);
                            var score = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
                            if (score >= bestScore) {
                                bestScore = score;
                                bestEquality1 = equality1;
                                bestEdit = edit;
                                bestEquality2 = equality2
                            }
                        }
                        if (diffs[pointer - 1][1] != bestEquality1) {
                            if (bestEquality1) {
                                diffs[pointer - 1][1] = bestEquality1
                            } else {
                                diffs.splice(pointer - 1, 1);
                                pointer--
                            }
                            diffs[pointer][1] = bestEdit;
                            if (bestEquality2) {
                                diffs[pointer + 1][1] = bestEquality2
                            } else {
                                diffs.splice(pointer + 1, 1);
                                pointer--
                            }
                        }
                    }
                    pointer++
                }
            };
            diff_match_patch.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;
            diff_match_patch.whitespaceRegex_ = /\s/;
            diff_match_patch.linebreakRegex_ = /[\r\n]/;
            diff_match_patch.blanklineEndRegex_ = /\n\r?\n$/;
            diff_match_patch.blanklineStartRegex_ = /^\r?\n\r?\n/;
            diff_match_patch.prototype.diff_cleanupEfficiency = function (diffs) {
                var changes = false;
                var equalities = [];
                var equalitiesLength = 0;
                var lastequality = null;
                var pointer = 0;
                var pre_ins = false;
                var pre_del = false;
                var post_ins = false;
                var post_del = false;
                while (pointer < diffs.length) {
                    if (diffs[pointer][0] == DIFF_EQUAL) {
                        if (diffs[pointer][1].length < this.Diff_EditCost && (post_ins || post_del)) {
                            equalities[equalitiesLength++] = pointer;
                            pre_ins = post_ins;
                            pre_del = post_del;
                            lastequality = diffs[pointer][1]
                        } else {
                            equalitiesLength = 0;
                            lastequality = null
                        }
                        post_ins = post_del = false
                    } else {
                        if (diffs[pointer][0] == DIFF_DELETE) {
                            post_del = true
                        } else {
                            post_ins = true
                        }
                        if (lastequality && (pre_ins && pre_del && post_ins && post_del || lastequality.length < this.Diff_EditCost / 2 && pre_ins + pre_del + post_ins + post_del == 3)) {
                            diffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE, lastequality]);
                            diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
                            equalitiesLength--;
                            lastequality = null;
                            if (pre_ins && pre_del) {
                                post_ins = post_del = true;
                                equalitiesLength = 0
                            } else {
                                equalitiesLength--;
                                pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
                                post_ins = post_del = false
                            }
                            changes = true
                        }
                    }
                    pointer++
                }
                if (changes) {
                    this.diff_cleanupMerge(diffs)
                }
            };
            diff_match_patch.prototype.diff_cleanupMerge = function (diffs) {
                diffs.push([DIFF_EQUAL, ""]);
                var pointer = 0;
                var count_delete = 0;
                var count_insert = 0;
                var text_delete = "";
                var text_insert = "";
                var commonlength;
                while (pointer < diffs.length) {
                    switch (diffs[pointer][0]) {
                        case DIFF_INSERT:
                            count_insert++;
                            text_insert += diffs[pointer][1];
                            pointer++;
                            break;
                        case DIFF_DELETE:
                            count_delete++;
                            text_delete += diffs[pointer][1];
                            pointer++;
                            break;
                        case DIFF_EQUAL:
                            if (count_delete + count_insert > 1) {
                                if (count_delete !== 0 && count_insert !== 0) {
                                    commonlength = this.diff_commonPrefix(text_insert, text_delete);
                                    if (commonlength !== 0) {
                                        if (pointer - count_delete - count_insert > 0 && diffs[pointer - count_delete - count_insert - 1][0] == DIFF_EQUAL) {
                                            diffs[pointer - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength)
                                        } else {
                                            diffs.splice(0, 0, [DIFF_EQUAL, text_insert.substring(0, commonlength)]);
                                            pointer++
                                        }
                                        text_insert = text_insert.substring(commonlength);
                                        text_delete = text_delete.substring(commonlength)
                                    }
                                    commonlength = this.diff_commonSuffix(text_insert, text_delete);
                                    if (commonlength !== 0) {
                                        diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];
                                        text_insert = text_insert.substring(0, text_insert.length - commonlength);
                                        text_delete = text_delete.substring(0, text_delete.length - commonlength)
                                    }
                                }
                                if (count_delete === 0) {
                                    diffs.splice(pointer - count_insert, count_delete + count_insert, [DIFF_INSERT, text_insert])
                                } else if (count_insert === 0) {
                                    diffs.splice(pointer - count_delete, count_delete + count_insert, [DIFF_DELETE, text_delete])
                                } else {
                                    diffs.splice(pointer - count_delete - count_insert, count_delete + count_insert, [DIFF_DELETE, text_delete], [DIFF_INSERT, text_insert])
                                }
                                pointer = pointer - count_delete - count_insert + (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1
                            } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
                                diffs[pointer - 1][1] += diffs[pointer][1];
                                diffs.splice(pointer, 1)
                            } else {
                                pointer++
                            }
                            count_insert = 0;
                            count_delete = 0;
                            text_delete = "";
                            text_insert = "";
                            break
                    }
                }
                if (diffs[diffs.length - 1][1] === "") {
                    diffs.pop()
                }
                var changes = false;
                pointer = 1;
                while (pointer < diffs.length - 1) {
                    if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {
                        if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
                            diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);
                            diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
                            diffs.splice(pointer - 1, 1);
                            changes = true
                        } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) == diffs[pointer + 1][1]) {
                            diffs[pointer - 1][1] += diffs[pointer + 1][1];
                            diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
                            diffs.splice(pointer + 1, 1);
                            changes = true
                        }
                    }
                    pointer++
                }
                if (changes) {
                    this.diff_cleanupMerge(diffs)
                }
            };
            diff_match_patch.prototype.diff_xIndex = function (diffs, loc) {
                var chars1 = 0;
                var chars2 = 0;
                var last_chars1 = 0;
                var last_chars2 = 0;
                var x;
                for (x = 0; x < diffs.length; x++) {
                    if (diffs[x][0] !== DIFF_INSERT) {
                        chars1 += diffs[x][1].length
                    }
                    if (diffs[x][0] !== DIFF_DELETE) {
                        chars2 += diffs[x][1].length
                    }
                    if (chars1 > loc) {
                        break
                    }
                    last_chars1 = chars1;
                    last_chars2 = chars2
                }
                if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {
                    return last_chars2
                }
                return last_chars2 + (loc - last_chars1)
            };
            diff_match_patch.prototype.diff_prettyHtml = function (diffs) {
                var html = [];
                var pattern_amp = /&/g;
                var pattern_lt = /</g;
                var pattern_gt = />/g;
                var pattern_para = /\n/g;
                for (var x = 0; x < diffs.length; x++) {
                    var op = diffs[x][0];
                    var data = diffs[x][1];
                    var text = data.replace(pattern_amp, "&amp;").replace(pattern_lt, "&lt;").replace(pattern_gt, "&gt;").replace(pattern_para, "&para;<br>");
                    switch (op) {
                        case DIFF_INSERT:
                            html[x] = '<ins style="background:#e6ffe6;">' + text + "</ins>";
                            break;
                        case DIFF_DELETE:
                            html[x] = '<del style="background:#ffe6e6;">' + text + "</del>";
                            break;
                        case DIFF_EQUAL:
                            html[x] = "<span>" + text + "</span>";
                            break
                    }
                }
                return html.join("")
            };
            diff_match_patch.prototype.diff_text1 = function (diffs) {
                var text = [];
                for (var x = 0; x < diffs.length; x++) {
                    if (diffs[x][0] !== DIFF_INSERT) {
                        text[x] = diffs[x][1]
                    }
                }
                return text.join("")
            };
            diff_match_patch.prototype.diff_text2 = function (diffs) {
                var text = [];
                for (var x = 0; x < diffs.length; x++) {
                    if (diffs[x][0] !== DIFF_DELETE) {
                        text[x] = diffs[x][1]
                    }
                }
                return text.join("")
            };
            diff_match_patch.prototype.diff_levenshtein = function (diffs) {
                var levenshtein = 0;
                var insertions = 0;
                var deletions = 0;
                for (var x = 0; x < diffs.length; x++) {
                    var op = diffs[x][0];
                    var data = diffs[x][1];
                    switch (op) {
                        case DIFF_INSERT:
                            insertions += data.length;
                            break;
                        case DIFF_DELETE:
                            deletions += data.length;
                            break;
                        case DIFF_EQUAL:
                            levenshtein += Math.max(insertions, deletions);
                            insertions = 0;
                            deletions = 0;
                            break
                    }
                }
                levenshtein += Math.max(insertions, deletions);
                return levenshtein
            };
            diff_match_patch.prototype.diff_toDelta = function (diffs) {
                var text = [];
                for (var x = 0; x < diffs.length; x++) {
                    switch (diffs[x][0]) {
                        case DIFF_INSERT:
                            text[x] = "+" + encodeURI(diffs[x][1]);
                            break;
                        case DIFF_DELETE:
                            text[x] = "-" + diffs[x][1].length;
                            break;
                        case DIFF_EQUAL:
                            text[x] = "=" + diffs[x][1].length;
                            break
                    }
                }
                return text.join("	").replace(/%20/g, " ")
            };
            diff_match_patch.prototype.diff_fromDelta = function (text1, delta) {
                var diffs = [];
                var diffsLength = 0;
                var pointer = 0;
                var tokens = delta.split(/\t/g);
                for (var x = 0; x < tokens.length; x++) {
                    var param = tokens[x].substring(1);
                    switch (tokens[x].charAt(0)) {
                        case"+":
                            try {
                                diffs[diffsLength++] = [DIFF_INSERT, decodeURI(param)]
                            } catch (ex) {
                                throw new Error("Illegal escape in diff_fromDelta: " + param)
                            }
                            break;
                        case"-":
                        case"=":
                            var n = parseInt(param, 10);
                            if (isNaN(n) || n < 0) {
                                throw new Error("Invalid number in diff_fromDelta: " + param)
                            }
                            var text = text1.substring(pointer, pointer += n);
                            if (tokens[x].charAt(0) == "=") {
                                diffs[diffsLength++] = [DIFF_EQUAL, text]
                            } else {
                                diffs[diffsLength++] = [DIFF_DELETE, text]
                            }
                            break;
                        default:
                            if (tokens[x]) {
                                throw new Error("Invalid diff operation in diff_fromDelta: " + tokens[x])
                            }
                    }
                }
                if (pointer != text1.length) {
                    throw new Error("Delta length (" + pointer + ") does not equal source text length (" + text1.length + ").")
                }
                return diffs
            };
            diff_match_patch.prototype.match_main = function (text, pattern, loc) {
                if (text == null || pattern == null || loc == null) {
                    throw new Error("Null input. (match_main)")
                }
                loc = Math.max(0, Math.min(loc, text.length));
                if (text == pattern) {
                    return 0
                } else if (!text.length) {
                    return-1
                } else if (text.substring(loc, loc + pattern.length) == pattern) {
                    return loc
                } else {
                    return this.match_bitap_(text, pattern, loc)
                }
            };
            diff_match_patch.prototype.match_bitap_ = function (text, pattern, loc) {
                if (pattern.length > this.Match_MaxBits) {
                    throw new Error("Pattern too long for this browser.")
                }
                var s = this.match_alphabet_(pattern);
                var dmp = this;

                function match_bitapScore_(e, x) {
                    var accuracy = e / pattern.length;
                    var proximity = Math.abs(loc - x);
                    if (!dmp.Match_Distance) {
                        return proximity ? 1 : accuracy
                    }
                    return accuracy + proximity / dmp.Match_Distance
                }

                var score_threshold = this.Match_Threshold;
                var best_loc = text.indexOf(pattern, loc);
                if (best_loc != -1) {
                    score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);
                    best_loc = text.lastIndexOf(pattern, loc + pattern.length);
                    if (best_loc != -1) {
                        score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold)
                    }
                }
                var matchmask = 1 << pattern.length - 1;
                best_loc = -1;
                var bin_min, bin_mid;
                var bin_max = pattern.length + text.length;
                var last_rd;
                for (var d = 0; d < pattern.length; d++) {
                    bin_min = 0;
                    bin_mid = bin_max;
                    while (bin_min < bin_mid) {
                        if (match_bitapScore_(d, loc + bin_mid) <= score_threshold) {
                            bin_min = bin_mid
                        } else {
                            bin_max = bin_mid
                        }
                        bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min)
                    }
                    bin_max = bin_mid;
                    var start = Math.max(1, loc - bin_mid + 1);
                    var finish = Math.min(loc + bin_mid, text.length) + pattern.length;
                    var rd = Array(finish + 2);
                    rd[finish + 1] = (1 << d) - 1;
                    for (var j = finish; j >= start; j--) {
                        var charMatch = s[text.charAt(j - 1)];
                        if (d === 0) {
                            rd[j] = (rd[j + 1] << 1 | 1) & charMatch
                        } else {
                            rd[j] = (rd[j + 1] << 1 | 1) & charMatch | ((last_rd[j + 1] | last_rd[j]) << 1 | 1) | last_rd[j + 1]
                        }
                        if (rd[j] & matchmask) {
                            var score = match_bitapScore_(d, j - 1);
                            if (score <= score_threshold) {
                                score_threshold = score;
                                best_loc = j - 1;
                                if (best_loc > loc) {
                                    start = Math.max(1, 2 * loc - best_loc)
                                } else {
                                    break
                                }
                            }
                        }
                    }
                    if (match_bitapScore_(d + 1, loc) > score_threshold) {
                        break
                    }
                    last_rd = rd
                }
                return best_loc
            };
            diff_match_patch.prototype.match_alphabet_ = function (pattern) {
                var s = {};
                for (var i = 0; i < pattern.length; i++) {
                    s[pattern.charAt(i)] = 0
                }
                for (var i = 0; i < pattern.length; i++) {
                    s[pattern.charAt(i)] |= 1 << pattern.length - i - 1
                }
                return s
            };
            diff_match_patch.prototype.patch_addContext_ = function (patch, text) {
                if (text.length == 0) {
                    return
                }
                var pattern = text.substring(patch.start2, patch.start2 + patch.length1);
                var padding = 0;
                while (text.indexOf(pattern) != text.lastIndexOf(pattern) && pattern.length < this.Match_MaxBits - this.Patch_Margin - this.Patch_Margin) {
                    padding += this.Patch_Margin;
                    pattern = text.substring(patch.start2 - padding, patch.start2 + patch.length1 + padding)
                }
                padding += this.Patch_Margin;
                var prefix = text.substring(patch.start2 - padding, patch.start2);
                if (prefix) {
                    patch.diffs.unshift([DIFF_EQUAL, prefix])
                }
                var suffix = text.substring(patch.start2 + patch.length1, patch.start2 + patch.length1 + padding);
                if (suffix) {
                    patch.diffs.push([DIFF_EQUAL, suffix])
                }
                patch.start1 -= prefix.length;
                patch.start2 -= prefix.length;
                patch.length1 += prefix.length + suffix.length;
                patch.length2 += prefix.length + suffix.length
            };
            diff_match_patch.prototype.patch_make = function (a, opt_b, opt_c) {
                var text1, diffs;
                if (typeof a == "string" && typeof opt_b == "string" && typeof opt_c == "undefined") {
                    text1 = a;
                    diffs = this.diff_main(text1, opt_b, true);
                    if (diffs.length > 2) {
                        this.diff_cleanupSemantic(diffs);
                        this.diff_cleanupEfficiency(diffs)
                    }
                } else if (a && typeof a == "object" && typeof opt_b == "undefined" && typeof opt_c == "undefined") {
                    diffs = a;
                    text1 = this.diff_text1(diffs)
                } else if (typeof a == "string" && opt_b && typeof opt_b == "object" && typeof opt_c == "undefined") {
                    text1 = a;
                    diffs = opt_b
                } else if (typeof a == "string" && typeof opt_b == "string" && opt_c && typeof opt_c == "object") {
                    text1 = a;
                    diffs = opt_c
                } else {
                    throw new Error("Unknown call format to patch_make.")
                }
                if (diffs.length === 0) {
                    return[]
                }
                var patches = [];
                var patch = new diff_match_patch.patch_obj;
                var patchDiffLength = 0;
                var char_count1 = 0;
                var char_count2 = 0;
                var prepatch_text = text1;
                var postpatch_text = text1;
                for (var x = 0; x < diffs.length; x++) {
                    var diff_type = diffs[x][0];
                    var diff_text = diffs[x][1];
                    if (!patchDiffLength && diff_type !== DIFF_EQUAL) {
                        patch.start1 = char_count1;
                        patch.start2 = char_count2
                    }
                    switch (diff_type) {
                        case DIFF_INSERT:
                            patch.diffs[patchDiffLength++] = diffs[x];
                            patch.length2 += diff_text.length;
                            postpatch_text = postpatch_text.substring(0, char_count2) + diff_text + postpatch_text.substring(char_count2);
                            break;
                        case DIFF_DELETE:
                            patch.length1 += diff_text.length;
                            patch.diffs[patchDiffLength++] = diffs[x];
                            postpatch_text = postpatch_text.substring(0, char_count2) + postpatch_text.substring(char_count2 + diff_text.length);
                            break;
                        case DIFF_EQUAL:
                            if (diff_text.length <= 2 * this.Patch_Margin && patchDiffLength && diffs.length != x + 1) {
                                patch.diffs[patchDiffLength++] = diffs[x];
                                patch.length1 += diff_text.length;
                                patch.length2 += diff_text.length
                            } else if (diff_text.length >= 2 * this.Patch_Margin) {
                                if (patchDiffLength) {
                                    this.patch_addContext_(patch, prepatch_text);
                                    patches.push(patch);
                                    patch = new diff_match_patch.patch_obj;
                                    patchDiffLength = 0;
                                    prepatch_text = postpatch_text;
                                    char_count1 = char_count2
                                }
                            }
                            break
                    }
                    if (diff_type !== DIFF_INSERT) {
                        char_count1 += diff_text.length
                    }
                    if (diff_type !== DIFF_DELETE) {
                        char_count2 += diff_text.length
                    }
                }
                if (patchDiffLength) {
                    this.patch_addContext_(patch, prepatch_text);
                    patches.push(patch)
                }
                return patches
            };
            diff_match_patch.prototype.patch_deepCopy = function (patches) {
                var patchesCopy = [];
                for (var x = 0; x < patches.length; x++) {
                    var patch = patches[x];
                    var patchCopy = new diff_match_patch.patch_obj;
                    patchCopy.diffs = [];
                    for (var y = 0; y < patch.diffs.length; y++) {
                        patchCopy.diffs[y] = patch.diffs[y].slice()
                    }
                    patchCopy.start1 = patch.start1;
                    patchCopy.start2 = patch.start2;
                    patchCopy.length1 = patch.length1;
                    patchCopy.length2 = patch.length2;
                    patchesCopy[x] = patchCopy
                }
                return patchesCopy
            };
            diff_match_patch.prototype.patch_apply = function (patches, text) {
                if (patches.length == 0) {
                    return[text, []]
                }
                patches = this.patch_deepCopy(patches);
                var nullPadding = this.patch_addPadding(patches);
                text = nullPadding + text + nullPadding;
                this.patch_splitMax(patches);
                var delta = 0;
                var results = [];
                for (var x = 0; x < patches.length; x++) {
                    var expected_loc = patches[x].start2 + delta;
                    var text1 = this.diff_text1(patches[x].diffs);
                    var start_loc;
                    var end_loc = -1;
                    if (text1.length > this.Match_MaxBits) {
                        start_loc = this.match_main(text, text1.substring(0, this.Match_MaxBits), expected_loc);
                        if (start_loc != -1) {
                            end_loc = this.match_main(text, text1.substring(text1.length - this.Match_MaxBits), expected_loc + text1.length - this.Match_MaxBits);
                            if (end_loc == -1 || start_loc >= end_loc) {
                                start_loc = -1
                            }
                        }
                    } else {
                        start_loc = this.match_main(text, text1, expected_loc)
                    }
                    if (start_loc == -1) {
                        results[x] = false;
                        delta -= patches[x].length2 - patches[x].length1
                    } else {
                        results[x] = true;
                        delta = start_loc - expected_loc;
                        var text2;
                        if (end_loc == -1) {
                            text2 = text.substring(start_loc, start_loc + text1.length)
                        } else {
                            text2 = text.substring(start_loc, end_loc + this.Match_MaxBits)
                        }
                        if (text1 == text2) {
                            text = text.substring(0, start_loc) + this.diff_text2(patches[x].diffs) + text.substring(start_loc + text1.length)
                        } else {
                            var diffs = this.diff_main(text1, text2, false);
                            if (text1.length > this.Match_MaxBits && this.diff_levenshtein(diffs) / text1.length > this.Patch_DeleteThreshold) {
                                results[x] = false
                            } else {
                                this.diff_cleanupSemanticLossless(diffs);
                                var index1 = 0;
                                var index2;
                                for (var y = 0; y < patches[x].diffs.length; y++) {
                                    var mod = patches[x].diffs[y];
                                    if (mod[0] !== DIFF_EQUAL) {
                                        index2 = this.diff_xIndex(diffs, index1)
                                    }
                                    if (mod[0] === DIFF_INSERT) {
                                        text = text.substring(0, start_loc + index2) + mod[1] + text.substring(start_loc + index2)
                                    } else if (mod[0] === DIFF_DELETE) {
                                        text = text.substring(0, start_loc + index2) + text.substring(start_loc + this.diff_xIndex(diffs, index1 + mod[1].length))
                                    }
                                    if (mod[0] !== DIFF_DELETE) {
                                        index1 += mod[1].length
                                    }
                                }
                            }
                        }
                    }
                }
                text = text.substring(nullPadding.length, text.length - nullPadding.length);
                return[text, results]
            };
            diff_match_patch.prototype.patch_addPadding = function (patches) {
                var paddingLength = this.Patch_Margin;
                var nullPadding = "";
                for (var x = 1; x <= paddingLength; x++) {
                    nullPadding += String.fromCharCode(x)
                }
                for (var x = 0; x < patches.length; x++) {
                    patches[x].start1 += paddingLength;
                    patches[x].start2 += paddingLength
                }
                var patch = patches[0];
                var diffs = patch.diffs;
                if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {
                    diffs.unshift([DIFF_EQUAL, nullPadding]);
                    patch.start1 -= paddingLength;
                    patch.start2 -= paddingLength;
                    patch.length1 += paddingLength;
                    patch.length2 += paddingLength
                } else if (paddingLength > diffs[0][1].length) {
                    var extraLength = paddingLength - diffs[0][1].length;
                    diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];
                    patch.start1 -= extraLength;
                    patch.start2 -= extraLength;
                    patch.length1 += extraLength;
                    patch.length2 += extraLength
                }
                patch = patches[patches.length - 1];
                diffs = patch.diffs;
                if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {
                    diffs.push([DIFF_EQUAL, nullPadding]);
                    patch.length1 += paddingLength;
                    patch.length2 += paddingLength
                } else if (paddingLength > diffs[diffs.length - 1][1].length) {
                    var extraLength = paddingLength - diffs[diffs.length - 1][1].length;
                    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);
                    patch.length1 += extraLength;
                    patch.length2 += extraLength
                }
                return nullPadding
            };
            diff_match_patch.prototype.patch_splitMax = function (patches) {
                var patch_size = this.Match_MaxBits;
                for (var x = 0; x < patches.length; x++) {
                    if (patches[x].length1 <= patch_size) {
                        continue
                    }
                    var bigpatch = patches[x];
                    patches.splice(x--, 1);
                    var start1 = bigpatch.start1;
                    var start2 = bigpatch.start2;
                    var precontext = "";
                    while (bigpatch.diffs.length !== 0) {
                        var patch = new diff_match_patch.patch_obj;
                        var empty = true;
                        patch.start1 = start1 - precontext.length;
                        patch.start2 = start2 - precontext.length;
                        if (precontext !== "") {
                            patch.length1 = patch.length2 = precontext.length;
                            patch.diffs.push([DIFF_EQUAL, precontext])
                        }
                        while (bigpatch.diffs.length !== 0 && patch.length1 < patch_size - this.Patch_Margin) {
                            var diff_type = bigpatch.diffs[0][0];
                            var diff_text = bigpatch.diffs[0][1];
                            if (diff_type === DIFF_INSERT) {
                                patch.length2 += diff_text.length;
                                start2 += diff_text.length;
                                patch.diffs.push(bigpatch.diffs.shift());
                                empty = false
                            } else if (diff_type === DIFF_DELETE && patch.diffs.length == 1 && patch.diffs[0][0] == DIFF_EQUAL && diff_text.length > 2 * patch_size) {
                                patch.length1 += diff_text.length;
                                start1 += diff_text.length;
                                empty = false;
                                patch.diffs.push([diff_type, diff_text]);
                                bigpatch.diffs.shift()
                            } else {
                                diff_text = diff_text.substring(0, patch_size - patch.length1 - this.Patch_Margin);
                                patch.length1 += diff_text.length;
                                start1 += diff_text.length;
                                if (diff_type === DIFF_EQUAL) {
                                    patch.length2 += diff_text.length;
                                    start2 += diff_text.length
                                } else {
                                    empty = false
                                }
                                patch.diffs.push([diff_type, diff_text]);
                                if (diff_text == bigpatch.diffs[0][1]) {
                                    bigpatch.diffs.shift()
                                } else {
                                    bigpatch.diffs[0][1] = bigpatch.diffs[0][1].substring(diff_text.length)
                                }
                            }
                        }
                        precontext = this.diff_text2(patch.diffs);
                        precontext = precontext.substring(precontext.length - this.Patch_Margin);
                        var postcontext = this.diff_text1(bigpatch.diffs).substring(0, this.Patch_Margin);
                        if (postcontext !== "") {
                            patch.length1 += postcontext.length;
                            patch.length2 += postcontext.length;
                            if (patch.diffs.length !== 0 && patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {
                                patch.diffs[patch.diffs.length - 1][1] += postcontext
                            } else {
                                patch.diffs.push([DIFF_EQUAL, postcontext])
                            }
                        }
                        if (!empty) {
                            patches.splice(++x, 0, patch)
                        }
                    }
                }
            };
            diff_match_patch.prototype.patch_toText = function (patches) {
                var text = [];
                for (var x = 0; x < patches.length; x++) {
                    text[x] = patches[x]
                }
                return text.join("")
            };
            diff_match_patch.prototype.patch_fromText = function (textline) {
                var patches = [];
                if (!textline) {
                    return patches
                }
                var text = textline.split("\n");
                var textPointer = 0;
                var patchHeader = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/;
                while (textPointer < text.length) {
                    var m = text[textPointer].match(patchHeader);
                    if (!m) {
                        throw new Error("Invalid patch string: " + text[textPointer])
                    }
                    var patch = new diff_match_patch.patch_obj;
                    patches.push(patch);
                    patch.start1 = parseInt(m[1], 10);
                    if (m[2] === "") {
                        patch.start1--;
                        patch.length1 = 1
                    } else if (m[2] == "0") {
                        patch.length1 = 0
                    } else {
                        patch.start1--;
                        patch.length1 = parseInt(m[2], 10)
                    }
                    patch.start2 = parseInt(m[3], 10);
                    if (m[4] === "") {
                        patch.start2--;
                        patch.length2 = 1
                    } else if (m[4] == "0") {
                        patch.length2 = 0
                    } else {
                        patch.start2--;
                        patch.length2 = parseInt(m[4], 10)
                    }
                    textPointer++;
                    while (textPointer < text.length) {
                        var sign = text[textPointer].charAt(0);
                        try {
                            var line = decodeURI(text[textPointer].substring(1))
                        } catch (ex) {
                            throw new Error("Illegal escape in patch_fromText: " + line)
                        }
                        if (sign == "-") {
                            patch.diffs.push([DIFF_DELETE, line])
                        } else if (sign == "+") {
                            patch.diffs.push([DIFF_INSERT, line])
                        } else if (sign == " ") {
                            patch.diffs.push([DIFF_EQUAL, line])
                        } else if (sign == "@") {
                            break
                        } else if (sign === "") {
                        } else {
                            throw new Error('Invalid patch mode "' + sign + '" in: ' + line)
                        }
                        textPointer++
                    }
                }
                return patches
            };
            diff_match_patch.patch_obj = function () {
                this.diffs = [];
                this.start1 = null;
                this.start2 = null;
                this.length1 = 0;
                this.length2 = 0
            };
            diff_match_patch.patch_obj.prototype.toString = function () {
                var coords1, coords2;
                if (this.length1 === 0) {
                    coords1 = this.start1 + ",0"
                } else if (this.length1 == 1) {
                    coords1 = this.start1 + 1
                } else {
                    coords1 = this.start1 + 1 + "," + this.length1
                }
                if (this.length2 === 0) {
                    coords2 = this.start2 + ",0"
                } else if (this.length2 == 1) {
                    coords2 = this.start2 + 1
                } else {
                    coords2 = this.start2 + 1 + "," + this.length2
                }
                var text = ["@@ -" + coords1 + " +" + coords2 + " @@\n"];
                var op;
                for (var x = 0; x < this.diffs.length; x++) {
                    switch (this.diffs[x][0]) {
                        case DIFF_INSERT:
                            op = "+";
                            break;
                        case DIFF_DELETE:
                            op = "-";
                            break;
                        case DIFF_EQUAL:
                            op = " ";
                            break
                    }
                    text[x + 1] = op + encodeURI(this.diffs[x][1]) + "\n"
                }
                return text.join("").replace(/%20/g, " ")
            };
            this["diff_match_patch"] = diff_match_patch;
            this["DIFF_DELETE"] = DIFF_DELETE;
            this["DIFF_INSERT"] = DIFF_INSERT;
            this["DIFF_EQUAL"] = DIFF_EQUAL;
            browserify_shim__define__module__export__(typeof diff_match_patch != "undefined" ? diff_match_patch : window.diff_match_patch)
        }).call(global, undefined, undefined, undefined, undefined, function defineExport(ex) {
                module.exports = ex
            })
    }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
}, {}], 231: [function (require, module, exports) {
    (function (global) {
        require("/home/wpcom/notifications-test-client/node_modules/simperium/src/jsondiff-wrapper/diff_match_patch-20120111.js");
        __browserify_shim_require__ = require;
        (function browserifyShim(module, exports, require, define, browserify_shim__define__module__export__) {
            (function () {
                var jsondiff, __bind = function (fn, me) {
                    return function () {
                        return fn.apply(me, arguments)
                    }
                }, __hasProp = {}.hasOwnProperty;
                jsondiff = function () {
                    var DIFF_DELETE, DIFF_EQUAL, DIFF_INSERT;
                    DIFF_INSERT = 1;
                    DIFF_DELETE = -1;
                    DIFF_EQUAL = 0;
                    function jsondiff() {
                        this.patch_apply_with_offsets = __bind(this.patch_apply_with_offsets, this);
                        this.transform_object_diff = __bind(this.transform_object_diff, this);
                        this.transform_list_diff_dmp = __bind(this.transform_list_diff_dmp, this);
                        this.transform_list_diff = __bind(this.transform_list_diff, this);
                        this.apply_diff = __bind(this.apply_diff, this);
                        this.apply_object_diff_with_offsets = __bind(this.apply_object_diff_with_offsets, this);
                        this.apply_object_diff = __bind(this.apply_object_diff, this);
                        this.apply_list_diff_dmp = __bind(this.apply_list_diff_dmp, this);
                        this.apply_list_diff = __bind(this.apply_list_diff, this);
                        this.diff = __bind(this.diff, this);
                        this.object_diff = __bind(this.object_diff, this);
                        this._text_to_array = __bind(this._text_to_array, this);
                        this._serialize_to_text = __bind(this._serialize_to_text, this);
                        this.list_diff_dmp = __bind(this.list_diff_dmp, this);
                        this.list_diff = __bind(this.list_diff, this);
                        this._common_suffix = __bind(this._common_suffix, this);
                        this._common_prefix = __bind(this._common_prefix, this);
                        this.object_equals = __bind(this.object_equals, this);
                        this.list_equals = __bind(this.list_equals, this);
                        this.equals = __bind(this.equals, this);
                        this.deepCopy = __bind(this.deepCopy, this);
                        this.typeOf = __bind(this.typeOf, this);
                        this.entries = __bind(this.entries, this);
                        this.dmp = new diff_match_patch
                    }

                    jsondiff.prototype.entries = function (obj) {
                        var key, n, value;
                        n = 0;
                        for (key in obj) {
                            if (!__hasProp.call(obj, key))continue;
                            value = obj[key];
                            n++
                        }
                        return n
                    };
                    jsondiff.prototype.typeOf = function (value) {
                        var s;
                        s = typeof value;
                        if (s === "object") {
                            if (value) {
                                if (typeof value.length === "number" && typeof value.splice === "function" && !value.propertyIsEnumerable("length")) {
                                    s = "array"
                                }
                            } else {
                                s = "null"
                            }
                        }
                        return s
                    };
                    jsondiff.prototype.deepCopy = function (obj) {
                        return JSON.parse(JSON.stringify(obj))
                    };
                    jsondiff.prototype.equals = function (a, b) {
                        var typea, typeb;
                        typea = this.typeOf(a);
                        typeb = this.typeOf(b);
                        if (typea === "boolean" && typeb === "number") {
                            return Number(a) === b
                        }
                        if (typea === "number" && typeb === "boolean") {
                            return Number(b) === a
                        }
                        if (typea !== typeb) {
                            return false
                        }
                        if (typea === "array") {
                            return this.list_equals(a, b)
                        } else if (typea === "object") {
                            return this.object_equals(a, b)
                        } else {
                            return a === b
                        }
                    };
                    jsondiff.prototype.list_equals = function (a, b) {
                        var alength, i, _i;
                        alength = a.length;
                        if (alength !== b.length) {
                            return false
                        }
                        for (i = _i = 0; 0 <= alength ? _i < alength : _i > alength; i = 0 <= alength ? ++_i : --_i) {
                            if (!this.equals(a[i], b[i])) {
                                return false
                            }
                        }
                        return true
                    };
                    jsondiff.prototype.object_equals = function (a, b) {
                        var key;
                        for (key in a) {
                            if (!__hasProp.call(a, key))continue;
                            if (!(key in b)) {
                                return false
                            }
                            if (!this.equals(a[key], b[key])) {
                                return false
                            }
                        }
                        for (key in b) {
                            if (!__hasProp.call(b, key))continue;
                            if (!(key in a)) {
                                return false
                            }
                        }
                        return true
                    };
                    jsondiff.prototype._common_prefix = function (a, b) {
                        var i, minlen, _i;
                        minlen = Math.min(a.length, b.length);
                        for (i = _i = 0; 0 <= minlen ? _i < minlen : _i > minlen; i = 0 <= minlen ? ++_i : --_i) {
                            if (!this.equals(a[i], b[i])) {
                                return i
                            }
                        }
                        return minlen
                    };
                    jsondiff.prototype._common_suffix = function (a, b) {
                        var i, lena, lenb, minlen, _i;
                        lena = a.length;
                        lenb = b.length;
                        minlen = Math.min(a.length, b.length);
                        if (minlen === 0) {
                            return 0
                        }
                        for (i = _i = 0; 0 <= minlen ? _i < minlen : _i > minlen; i = 0 <= minlen ? ++_i : --_i) {
                            if (!this.equals(a[lena - i - 1], b[lenb - i - 1])) {
                                return i
                            }
                        }
                        return minlen
                    };
                    jsondiff.prototype.list_diff = function (a, b, policy) {
                        var diffs, i, lena, lenb, maxlen, prefix_len, suffix_len, _i;
                        if (policy != null && "item"in policy) {
                            policy = policy["item"]
                        } else {
                            policy = null
                        }
                        diffs = {};
                        lena = a.length;
                        lenb = b.length;
                        prefix_len = this._common_prefix(a, b);
                        suffix_len = this._common_suffix(a, b);
                        a = a.slice(prefix_len, lena - suffix_len);
                        b = b.slice(prefix_len, lenb - suffix_len);
                        lena = a.length;
                        lenb = b.length;
                        maxlen = Math.max(lena, lenb);
                        for (i = _i = 0; 0 <= maxlen ? _i <= maxlen : _i >= maxlen; i = 0 <= maxlen ? ++_i : --_i) {
                            if (i < lena && i < lenb) {
                                if (!this.equals(a[i], b[i])) {
                                    diffs[i + prefix_len] = this.diff(a[i], b[i], policy)
                                }
                            } else if (i < lena) {
                                diffs[i + prefix_len] = {o: "-"}
                            } else if (i < lenb) {
                                diffs[i + prefix_len] = {o: "+", v: b[i]}
                            }
                        }
                        return diffs
                    };
                    jsondiff.prototype.list_diff_dmp = function (a, b, policy) {
                        var atext, btext, delta, diffs, lena, lenb;
                        lena = a.length;
                        lenb = b.length;
                        atext = this._serialize_to_text(a);
                        btext = this._serialize_to_text(b);
                        diffs = this.dmp.diff_lineMode_(atext, btext);
                        this.dmp.diff_cleanupEfficiency(diffs);
                        delta = this.dmp.diff_toDelta(diffs);
                        return delta
                    };
                    jsondiff.prototype._serialize_to_text = function (a) {
                        var i, s, _i, _len;
                        s = "";
                        for (_i = 0, _len = a.length; _i < _len; _i++) {
                            i = a[_i];
                            s += "" + JSON.stringify(i) + "\n"
                        }
                        return s
                    };
                    jsondiff.prototype._text_to_array = function (s) {
                        var a, sa, x;
                        a = [];
                        sa = s.split("\n");
                        a = function () {
                            var _i, _len, _results;
                            _results = [];
                            for (_i = 0, _len = sa.length; _i < _len; _i++) {
                                x = sa[_i];
                                if (x.length > 0) {
                                    _results.push(JSON.parse(x))
                                }
                            }
                            return _results
                        }();
                        return a
                    };
                    jsondiff.prototype.object_diff = function (a, b, policy) {
                        var diffs, key, sub_policy;
                        diffs = {};
                        if (policy != null && "attributes"in policy) {
                            policy = policy["attributes"]
                        }
                        if (a == null || b == null) {
                            return{}
                        }
                        for (key in a) {
                            if (!__hasProp.call(a, key))continue;
                            if (policy != null && key in policy) {
                                sub_policy = policy[key]
                            } else {
                                sub_policy = null
                            }
                            if (key in b) {
                                if (!this.equals(a[key], b[key])) {
                                    diffs[key] = this.diff(a[key], b[key], sub_policy)
                                }
                            } else {
                                diffs[key] = {o: "-"}
                            }
                        }
                        for (key in b) {
                            if (!__hasProp.call(b, key))continue;
                            if (!(key in a) && b[key] != null) {
                                diffs[key] = {o: "+", v: b[key]}
                            }
                        }
                        return diffs
                    };
                    jsondiff.prototype.diff = function (a, b, policy) {
                        var diffs, otype, typea;
                        if (this.equals(a, b)) {
                            return{}
                        }
                        if (policy != null && "attributes"in policy) {
                            policy = policy["attributes"]
                        }
                        if (policy != null && "otype"in policy) {
                            otype = policy["otype"];
                            switch (otype) {
                                case"replace":
                                    return{o: "r", v: b};
                                case"list":
                                    return{o: "L", v: this.list_diff(a, b, policy)};
                                case"list_dmp":
                                    return{o: "dL", v: this.list_diff_dmp(a, b, policy)};
                                case"integer":
                                    return{o: "I", v: b - a};
                                case"string":
                                    diffs = this.dmp.diff_main(a, b);
                                    if (diffs.length > 2) {
                                        this.dmp.diff_cleanupEfficiency(diffs)
                                    }
                                    if (diffs.length > 0) {
                                        return{o: "d", v: this.dmp.diff_toDelta(diffs)}
                                    }
                            }
                        }
                        typea = this.typeOf(a);
                        if (typea !== this.typeOf(b)) {
                            return{o: "r", v: b}
                        }
                        switch (typea) {
                            case"boolean":
                                return{o: "r", v: b};
                            case"number":
                                return{o: "r", v: b};
                            case"array":
                                return{o: "r", v: b};
                            case"object":
                                return{o: "O", v: this.object_diff(a, b, policy)};
                            case"string":
                                diffs = this.dmp.diff_main(a, b);
                                if (diffs.length > 2) {
                                    this.dmp.diff_cleanupEfficiency(diffs)
                                }
                                if (diffs.length > 0) {
                                    return{o: "d", v: this.dmp.diff_toDelta(diffs)}
                                }
                        }
                        return{}
                    };
                    jsondiff.prototype.apply_list_diff = function (s, diffs) {
                        var deleted, dmp_diffs, dmp_patches, dmp_result, index, indexes, key, op, patched, s_index, shift, x, _i, _len, _ref, _ref1;
                        patched = this.deepCopy(s);
                        indexes = [];
                        deleted = [];
                        for (key in diffs) {
                            if (!__hasProp.call(diffs, key))continue;
                            indexes.push(key);
                            indexes.sort()
                        }
                        for (_i = 0, _len = indexes.length; _i < _len; _i++) {
                            index = indexes[_i];
                            op = diffs[index];
                            shift = function () {
                                var _j, _len1, _results;
                                _results = [];
                                for (_j = 0, _len1 = deleted.length; _j < _len1; _j++) {
                                    x = deleted[_j];
                                    if (x <= index) {
                                        _results.push(x)
                                    }
                                }
                                return _results
                            }().length;
                            s_index = index - shift;
                            switch (op["o"]) {
                                case"+":
                                    [].splice.apply(patched, [s_index, s_index - 1 - s_index + 1].concat(_ref = op["v"])), _ref;
                                    break;
                                case"-":
                                    [].splice.apply(patched, [s_index, s_index - s_index + 1].concat(_ref1 = [])), _ref1;
                                    deleted[deleted.length] = s_index;
                                    break;
                                case"r":
                                    patched[s_index] = op["v"];
                                    break;
                                case"I":
                                    patched[s_index] += op["v"];
                                    break;
                                case"L":
                                    patched[s_index] = this.apply_list_diff(patched[s_index], op["v"]);
                                    break;
                                case"dL":
                                    patched[s_index] = this.apply_list_diff_dmp(patched[s_index], op["v"]);
                                    break;
                                case"O":
                                    patched[s_index] = this.apply_object_diff(patched[s_index], op["v"]);
                                    break;
                                case"d":
                                    dmp_diffs = this.dmp.diff_fromDelta(patched[s_index], op["v"]);
                                    dmp_patches = this.dmp.patch_make(patched[s_index], dmp_diffs);
                                    dmp_result = this.dmp.patch_apply(dmp_patches, patched[s_index]);
                                    patched[s_index] = dmp_result[0]
                            }
                        }
                        return patched
                    };
                    jsondiff.prototype.apply_list_diff_dmp = function (s, delta) {
                        var dmp_diffs, dmp_patches, dmp_result, ptext;
                        ptext = this._serialize_to_text(s);
                        dmp_diffs = this.dmp.diff_fromDelta(ptext, delta);
                        dmp_patches = this.dmp.patch_make(ptext, dmp_diffs);
                        dmp_result = this.dmp.patch_apply(dmp_patches, ptext);
                        return this._text_to_array(dmp_result[0])
                    };
                    jsondiff.prototype.apply_object_diff = function (s, diffs) {
                        var key, op, patched;
                        patched = this.deepCopy(s);
                        for (key in diffs) {
                            if (!__hasProp.call(diffs, key))continue;
                            op = diffs[key];
                            if (op["o"] === "-") {
                                delete patched[key]
                            } else {
                                patched[key] = this.apply_diff(patched[key], op)
                            }
                        }
                        return patched
                    };
                    jsondiff.prototype.apply_object_diff_with_offsets = function (s, diffs, field, offsets) {
                        var dmp_diffs, dmp_patches, dmp_result, key, op, patched;
                        patched = this.deepCopy(s);
                        for (key in diffs) {
                            if (!__hasProp.call(diffs, key))continue;
                            op = diffs[key];
                            switch (op["o"]) {
                                case"+":
                                    patched[key] = op["v"];
                                    break;
                                case"-":
                                    delete patched[key];
                                    break;
                                case"r":
                                    patched[key] = op["v"];
                                    break;
                                case"I":
                                    patched[key] += op["v"];
                                    break;
                                case"L":
                                    patched[key] = this.apply_list_diff(patched[key], op["v"]);
                                    break;
                                case"O":
                                    patched[key] = this.apply_object_diff(patched[key], op["v"]);
                                    break;
                                case"d":
                                    dmp_diffs = this.dmp.diff_fromDelta(patched[key], op["v"]);
                                    dmp_patches = this.dmp.patch_make(patched[key], dmp_diffs);
                                    if (key === field) {
                                        patched[key] = this.patch_apply_with_offsets(dmp_patches, patched[key], offsets)
                                    } else {
                                        dmp_result = this.dmp.patch_apply(dmp_patches, patched[key]);
                                        patched[key] = dmp_result[0]
                                    }
                            }
                        }
                        return patched
                    };
                    jsondiff.prototype.apply_diff = function (a, op) {
                        var dmp_diffs, dmp_patches, dmp_result;
                        switch (op["o"]) {
                            case"+":
                                return op["v"];
                            case"-":
                                return null;
                            case"r":
                                return op["v"];
                            case"I":
                                return a + op["v"];
                            case"L":
                                return this.apply_list_diff(a, op["v"]);
                            case"dL":
                                return this.apply_list_diff_dmp(a, op["v"]);
                            case"O":
                                return this.apply_object_diff(a, op["v"]);
                            case"d":
                                dmp_diffs = this.dmp.diff_fromDelta(a, op["v"]);
                                dmp_patches = this.dmp.patch_make(a, dmp_diffs);
                                dmp_result = this.dmp.patch_apply(dmp_patches, a);
                                return dmp_result[0]
                        }
                    };
                    jsondiff.prototype.transform_list_diff = function (ad, bd, s, policy) {
                        var ad_new, b_deletes, b_inserts, diff, index, last_index, last_shift, op, other_op, shift_l, shift_r, sindex, target_op, x;
                        ad_new = {};
                        b_inserts = [];
                        b_deletes = [];
                        if (policy != null && "item"in policy) {
                            policy = policy["item"]
                        } else {
                            policy = null
                        }
                        for (index in bd) {
                            if (!__hasProp.call(bd, index))continue;
                            op = bd[index];
                            index = parseInt(index);
                            if (op["o"] === "+") {
                                b_inserts.push(index)
                            }
                            if (op["o"] === "-") {
                                b_deletes.push(index)
                            }
                        }
                        last_index = 0;
                        last_shift = 0;
                        for (index in ad) {
                            if (!__hasProp.call(ad, index))continue;
                            op = ad[index];
                            index = parseInt(index);
                            shift_r = function () {
                                var _i, _len, _results;
                                _results = [];
                                for (_i = 0, _len = b_inserts.length; _i < _len; _i++) {
                                    x = b_inserts[_i];
                                    if (x < index) {
                                        _results.push(x)
                                    }
                                }
                                return _results
                            }().length;
                            shift_l = function () {
                                var _i, _len, _results;
                                _results = [];
                                for (_i = 0, _len = b_deletes.length; _i < _len; _i++) {
                                    x = b_deletes[_i];
                                    if (x < index) {
                                        _results.push(x)
                                    }
                                }
                                return _results
                            }().length;
                            if (last_index + 1 === index) {
                                index = index + last_shift
                            } else {
                                index = index + shift_r - shift_l
                            }
                            last_index = index;
                            last_shift = shift_r - shift_l;
                            sindex = String(index);
                            ad_new[sindex] = op;
                            if (sindex in bd) {
                                if (op["o"] === "+" && bd[index]["o"] === "+") {
                                    continue
                                } else if (op["o"] === "-") {
                                    if (bd[index]["o"] === "-") {
                                        delete ad_new[sindex]
                                    }
                                } else if (bd[index]["o"] === "-") {
                                    if (op["o"] === "r") {
                                        ad_new[sindex] = {o: "+", v: op["v"]}
                                    }
                                    if (op["o"] === !"+") {
                                        ad_new[sindex] = {o: "+", v: this.apply_object_diff(s[sindex], op["v"])}
                                    }
                                } else {
                                    target_op = {};
                                    target_op[sindex] = op;
                                    other_op = {};
                                    other_op[sindex] = bd[index];
                                    diff = this.transform_object_diff(target_op, other_op, s, policy);
                                    ad_new[sindex] = diff[sindex]
                                }
                            }
                        }
                        return ad_new
                    };
                    jsondiff.prototype.transform_list_diff_dmp = function (ad, bd, s, policy) {
                        var a_patches, ab_text, b_patches, b_text, dmp_diffs, stext;
                        stext = this._serialize_to_text(s);
                        a_patches = this.dmp.patch_make(stext, this.dmp.diff_fromDelta(stext, ad));
                        b_patches = this.dmp.patch_make(stext, this.dmp.diff_fromDelta(stext, bd));
                        b_text = this.dmp.patch_apply(b_patches, stext)[0];
                        ab_text = this.dmp.patch_apply(a_patches, b_text)[0];
                        if (ab_text !== b_text) {
                            dmp_diffs = this.dmp.diff_lineMode_(b_text, ab_text);
                            if (dmp_diffs.length > 2) {
                                this.dmp.diff_cleanupEfficiency(dmp_diffs)
                            }
                            if (dmp_diffs.length > 0) {
                                return this.dmp.diff_toDelta(dmp_diffs)
                            }
                        }
                        return""
                    };
                    jsondiff.prototype.transform_object_diff = function (ad, bd, s, policy) {
                        var a_patches, ab_text, ad_new, aop, b_patches, b_text, bop, dmp_diffs, key, sk, _ref;
                        ad_new = this.deepCopy(ad);
                        if (policy != null && "attributes"in policy) {
                            policy = policy["attributes"]
                        }
                        for (key in ad) {
                            if (!__hasProp.call(ad, key))continue;
                            aop = ad[key];
                            if (!(key in bd)) {
                                continue
                            }
                            if (policy != null && "attributes"in policy) {
                                policy = policy["attributes"];
                                if (policy != null && key in policy) {
                                    policy = policy[key]
                                } else {
                                    policy = null
                                }
                            } else {
                                policy = null
                            }
                            sk = s[key];
                            bop = bd[key];
                            if (aop["o"] === "+" && bop["o"] === "+") {
                                if (this.equals(aop["v"], bop["v"])) {
                                    delete ad_new[key]
                                } else {
                                    ad_new[key] = this.diff(bop["v"], aop["v"], policy)
                                }
                            } else if (aop["o"] === "-" && bop["o"] === "-") {
                                delete ad_new[key]
                            } else if (bop["o"] === "-" && ((_ref = aop["o"]) !== "+" && _ref !== "-")) {
                                ad_new[key] = {o: "+"};
                                ad_new[key]["v"] = this.apply_diff(sk, aop)
                            } else if (aop["o"] === "O" && bop["o"] === "O") {
                                ad_new[key] = {o: "O", v: this.transform_object_diff(aop["v"], bop["v"], sk, policy)}
                            } else if (aop["o"] === "L" && bop["o"] === "L") {
                                ad_new[key] = {o: "L", v: this.transform_list_diff(aop["v"], bop["v"], sk, policy)}
                            } else if (aop["o"] === "dL" && bop["o"] === "dL") {
                                ad_new[key] = {o: "dL", v: this.transform_list_diff_dmp(aop["v"], bop["v"], sk, policy)}
                            } else if (aop["o"] === "d" && bop["o"] === "d") {
                                delete ad_new[key];
                                a_patches = this.dmp.patch_make(sk, this.dmp.diff_fromDelta(sk, aop["v"]));
                                b_patches = this.dmp.patch_make(sk, this.dmp.diff_fromDelta(sk, bop["v"]));
                                b_text = this.dmp.patch_apply(b_patches, sk)[0];
                                ab_text = this.dmp.patch_apply(a_patches, b_text)[0];
                                if (ab_text !== b_text) {
                                    dmp_diffs = this.dmp.diff_main(b_text, ab_text);
                                    if (dmp_diffs.length > 2) {
                                        this.dmp.diff_cleanupEfficiency(dmp_diffs)
                                    }
                                    if (dmp_diffs.length > 0) {
                                        ad_new[key] = {o: "d", v: this.dmp.diff_toDelta(dmp_diffs)}
                                    }
                                }
                            }
                            return ad_new
                        }
                    };
                    jsondiff.prototype.patch_apply_with_offsets = function (patches, text, offsets) {
                        var del_end, del_start, delta, diffs, end_loc, expected_loc, i, index1, index2, mod, nullPadding, start_loc, text1, text2, x, y, _i, _j, _k, _l, _ref, _ref1, _ref2, _ref3;
                        if (patches.length === 0) {
                            return text
                        }
                        patches = this.dmp.patch_deepCopy(patches);
                        nullPadding = this.dmp.patch_addPadding(patches);
                        text = nullPadding + text + nullPadding;
                        this.dmp.patch_splitMax(patches);
                        delta = 0;
                        for (x = _i = 0, _ref = patches.length; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
                            expected_loc = patches[x].start2 + delta;
                            text1 = this.dmp.diff_text1(patches[x].diffs);
                            end_loc = -1;
                            if (text1.length > this.dmp.Match_MaxBits) {
                                start_loc = this.dmp.match_main(text, text1.substring(0, this.dmp.Match_MaxBits), expected_loc);
                                if (start_loc !== -1) {
                                    end_loc = this.dmp.match_main(text, text1.substring(text1.length - this.dmp.Match_MaxBits), expected_loc + text1.length - this.dmp.Match_MaxBits);
                                    if (end_loc === -1 || start_loc >= end_loc) {
                                        start_loc = -1
                                    }
                                }
                            } else {
                                start_loc = this.dmp.match_main(text, text1, expected_loc)
                            }
                            if (start_loc === -1) {
                                delta -= patches[x].length2 - patches[x].length1
                            } else {
                                delta = start_loc - expected_loc;
                                if (end_loc === -1) {
                                    text2 = text.substring(start_loc, start_loc + text1.length)
                                } else {
                                    text2 = text.substring(start_loc, end_loc + this.dmp.Match_MaxBits)
                                }
                                diffs = this.dmp.diff_main(text1, text2, false);
                                if (text1.length > this.dmp.Match_MaxBits && this.dmp.diff_levenshtein(diffs) / text1.length > this.dmp.Patch_DeleteThreshold) {
                                } else {
                                    index1 = 0;
                                    for (y = _j = 0, _ref1 = patches[x].diffs.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
                                        mod = patches[x].diffs[y];
                                        if (mod[0] !== DIFF_EQUAL) {
                                            index2 = this.dmp.diff_xIndex(diffs, index1)
                                        }
                                        if (mod[0] === DIFF_INSERT) {
                                            text = text.substring(0, start_loc + index2) + mod[1] + text.substring(start_loc + index2);
                                            for (i = _k = 0, _ref2 = offsets.length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; i = 0 <= _ref2 ? ++_k : --_k) {
                                                if (offsets[i] + nullPadding.length > start_loc + index2) {
                                                    offsets[i] += mod[1].length
                                                }
                                            }
                                        } else if (mod[0] === DIFF_DELETE) {
                                            del_start = start_loc + index2;
                                            del_end = start_loc + this.dmp.diff_xIndex(diffs, index1 + mod[1].length);
                                            text = text.substring(0, del_start) + text.substring(del_end);
                                            for (i = _l = 0, _ref3 = offsets.length; 0 <= _ref3 ? _l < _ref3 : _l > _ref3; i = 0 <= _ref3 ? ++_l : --_l) {
                                                if (offsets[i] + nullPadding.length > del_start) {
                                                    if (offsets[i] + nullPadding.length < del_end) {
                                                        offsets[i] = del_start - nullPadding.length
                                                    } else {
                                                        offsets[i] -= del_end - del_start
                                                    }
                                                }
                                            }
                                        }
                                        if (mod[0] !== DIFF_DELETE) {
                                            index1 += mod[1].length
                                        }
                                    }
                                }
                            }
                        }
                        text = text.substring(nullPadding.length, text.length - nullPadding.length);
                        return text
                    };
                    return jsondiff
                }();
                window["jsondiff"] = jsondiff
            }).call(this);
            browserify_shim__define__module__export__(typeof jsondiff != "undefined" ? jsondiff : window.jsondiff)
        }).call(global, undefined, undefined, undefined, undefined, function defineExport(ex) {
                module.exports = ex
            })
    }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
}, {"/home/wpcom/notifications-test-client/node_modules/simperium/src/jsondiff-wrapper/diff_match_patch-20120111.js": 230}], 232: [function (require, module, exports) {
    (function () {
        var inherits, Store, Binary;
        if (!("localStorage"in window) || null === window.localStorage === null) {
            module.exports = false;
            return
        }
        inherits = require("inherits");
        Store = require("./store");
        Binary = require("./binary");
        function LStore(prefix) {
            this.prefix = prefix;
            this.prefix_length = prefix.length;
            Store.call(this)
        }

        inherits(LStore, Store);
        function keys() {
            var i, key, keys;
            keys = [];
            for (i = 0; i < window.localStorage.length; i++) {
                key = window.localStorage.key(i);
                if (0 === key.indexOf(this.prefix)) {
                    keys.push(key.substr(this.prefix_length))
                }
            }
            return keys
        }

        LStore.prototype.keys = keys;
        function get(key) {
            var value;
            value = window.localStorage.getItem(this.prefix + key);
            if (null === value) {
                return
            }
            try {
                return JSON.parse(value)
            } catch (error) {
                this.delete(key);
                return
            }
        }

        LStore.prototype.get = get;
        function set(key, value) {
            var string, newValue, i;
            if (value && undefined !== typeof value.binary && Binary.hasBinary(value.binary)) {
                newValue = {};
                for (i in value) {
                    if (!value.hasOwnProperty(i)) {
                        continue
                    }
                    if ("binary" === i) {
                        newValue.binary = Binary.mapBinary(function () {
                            return true
                        }, value.binary)
                    } else {
                        newValue[i] = value[i]
                    }
                }
                string = JSON.stringify(newValue)
            } else {
                string = JSON.stringify(value)
            }
            window.localStorage.setItem(this.prefix + key, string);
            this.emit("set", key, value)
        }

        LStore.prototype.set = set;
        function deleteItem(key) {
            window.localStorage.removeItem(this.prefix + key);
            this.emit("delete", key)
        }

        LStore.prototype.delete = deleteItem;
        module.exports = LStore
    })()
}, {"./binary": 226, "./store": 236, inherits: 52}], 233: [function (require, module, exports) {
    var config = require("../package.json");
    var uuid = require("uuid");

    function Message(type) {
        this.type = type
    }

    Message.types = {auth: AUTH, init: INIT, i: INDEX, e: ENTITY, cv: CHANGE_VERSION, c: CHANGES, h: HEARTBEAT, o: OPTIONS, index: REMOTE_INDEX, log: LOG};
    Message.parse = function (string) {
        var type;
        var colon = string.indexOf(":");
        if (-1 === colon) {
            type = string;
            string = ""
        } else {
            type = string.slice(0, colon);
            string = string.slice(colon + 1)
        }
        if (!(type in Message.types)) {
            throw new Error("Unknown message type")
        }
        return new Message.types[type](string)
    };
    Message.prototype.parse = function (args) {
        if ("string" === typeof args) {
            if (args) {
                try {
                    return JSON.parse(args)
                } catch (e) {
                    return false
                }
            }
        }
        return args
    };
    Message.prototype.toString = function () {
        return this.type + ":" + JSON.stringify(this)
    };
    function AUTH(args) {
        args = this.parse(args) || {};
        this.msg = args.msg || undefined;
        this.code = args.code || undefined;
        this.username = args.username || undefined
    }

    AUTH.prototype = new Message("auth");
    AUTH.prototype.parse = function (args) {
        if ("string" === typeof args) {
            if (-1 !== args.indexOf("{")) {
                return Message.prototype.parse(args)
            }
            args = {username: args}
        }
        return args || {}
    };
    AUTH.prototype.toString = function () {
        if (this.username) {
            return this.type + ":" + this.username
        }
        return Message.prototype.toString.call(this)
    };
    function INIT(args) {
        args = this.parse(args) || {};
        this.clientid = args.clientid || "sjs-" + config.build + "-" + uuid();
        this.api = args.api || "1.1";
        this.token = args.token || "";
        this.app_id = args.app_id || "";
        this.name = args.name || "";
        this.library = args.library || "simperium-js-air";
        this.version = args.version || config.version;
        this.build = args.build || undefined;
        this.cmd = args.cmd || undefined;
        this.presence_session = args.presence_session || undefined;
        this.presence_debounce = args.presence_debounce || undefined
    }

    INIT.prototype = new Message("init");
    INIT.prototype.toString = function () {
        return this.type + ":" + JSON.stringify(this, function (key, value) {
            if ("cmd" === key && value instanceof Message) {
                return value.toString()
            }
            return value
        })
    };
    function INDEX(args) {
        args = this.parse(args) || {};
        this.data = args.data || undefined;
        this.mark = args.mark || undefined;
        this.since = args.since || undefined;
        this.limit = args.limit || undefined;
        this.current = args.current || undefined;
        this.index = args.index || undefined
    }

    INDEX.prototype = new Message("i");
    INDEX.prototype.parse = function (args) {
        var pieces;
        if ("string" === typeof args) {
            if (-1 !== args.indexOf("{")) {
                return Message.prototype.parse(args)
            }
            pieces = args.split(":");
            return{data: pieces[0] || undefined, mark: pieces[1] || undefined, since: pieces[2] || undefined, limit: pieces[3] || undefined}
        }
        return args || {}
    };
    INDEX.prototype.toString = function () {
        if (this.current) {
            return this.type + ":" + JSON.stringify(this)
        }
        return this.type + ":" + [this.data, this.mark, this.since, this.limit].join(":")
    };
    function ENTITY(args) {
        args = this.parse(args) || {};
        this.id = args.id || undefined;
        this.version = args.version || undefined;
        this.data = null === args.data ? null : args.data || undefined
    }

    ENTITY.prototype = new Message("e");
    ENTITY.prototype.parse = function (args) {
        var newline;
        var data;
        var period;
        var ret = {};
        if ("string" === typeof args) {
            newline = args.indexOf("\n");
            if (0 < newline) {
                ret.id = args.slice(0, newline);
                data = args.slice(newline + 1);
                if ("?" === data) {
                    ret.data = null
                } else {
                    ret.data = JSON.parse(args.slice(newline + 1))
                }
            } else {
                ret.id = args
            }
            period = ret.id.lastIndexOf(".");
            if (0 < period) {
                ret.version = parseInt(ret.id.slice(period + 1), 10);
                ret.id = ret.id.slice(0, period)
            }
            return ret
        }
        return args || {}
    };
    ENTITY.prototype.toString = function () {
        var ret = this.id;
        if (undefined !== this.version) {
            ret += "." + this.version
        }
        ret = this.type + ":" + ret;
        if (null === this.data) {
            ret = [ret, "?"]
        } else if (undefined === this.data) {
            ret = [ret]
        } else {
            ret = [ret, JSON.stringify(this.data)]
        }
        return ret.join("\n")
    };
    function CHANGE_VERSION(args) {
        args = this.parse(args) || {};
        this.version = null === args.version ? args.version : args.version || undefined
    }

    CHANGE_VERSION.prototype = new Message("cv");
    CHANGE_VERSION.prototype.parse = function (args) {
        var version;
        if ("string" === typeof args) {
            if ("?" === args) {
                version = null
            } else {
                version = args
            }
            return{version: version}
        }
        return args || {}
    };
    CHANGE_VERSION.prototype.toString = function () {
        return this.type + ":" + (null === this.version ? "?" : this.version)
    };
    function CHANGES(args) {
        args = this.parse(args);
        if ("[object Array]" === Object.prototype.toString.call(args)) {
            this.changes = [];
            args.forEach(function (change) {
                this.changes.push(new CHANGES(change))
            }, this)
        } else {
            this.clientid = args.clientid || undefined;
            this.cv = args.cv || undefined;
            this.ev = args.ev || undefined;
            this.sv = args.sv || undefined;
            this.id = args.id || undefined;
            this.o = args.o || undefined;
            this.v = args.v || undefined;
            this.ccid = args.ccid || undefined;
            this.d = args.d || undefined;
            this.ccids = args.ccids || undefined;
            this.error = args.error || undefined
        }
    }

    CHANGES.prototype = new Message("c");
    CHANGES.prototype.toString = function () {
        if (this.changes) {
            return this.type + ":" + JSON.stringify(this.changes)
        }
        return Message.prototype.toString.call(this)
    };
    function HEARTBEAT(args) {
        this.beat = parseInt(args, 10)
    }

    HEARTBEAT.prototype = new Message("h");
    HEARTBEAT.prototype.toString = function () {
        return this.type + ":" + this.beat
    };
    function OPTIONS(args) {
        args = this.parse(args);
        this.expose_namespace = args.expose_namespace || undefined;
        this.schema = args.schema || undefined;
        this.namespace = args.namespace || undefined;
        this.presence = args.presence || undefined;
        this.shared = args.shared || undefined;
        this.binary_backend = args.binary_backend || undefined
    }

    OPTIONS.prototype = new Message("o");
    function REMOTE_INDEX(args) {
        args = this.parse(args) || {};
        this.current = args.current || undefined;
        this.index = args.index || undefined;
        this.pending = args.pending || undefined;
        this.extra = args.extra || undefined
    }

    REMOTE_INDEX.prototype = new Message("index");
    REMOTE_INDEX.prototype.toString = function () {
        if (this.current === undefined && this.index === undefined) {
            return this.type
        }
        return Message.prototype.toString.call(this)
    };
    function LOG(args) {
        this.level = parseInt(args, 10);
        if (isNaN(this.level)) {
            args = this.parse(args) || {};
            this.log = args.log || undefined;
            this.level = undefined
        }
    }

    LOG.prototype = new Message("log");
    LOG.prototype.toString = function () {
        if (undefined === this.level) {
            return Message.prototype.toString.call(this)
        }
        return this.type + ":" + this.level
    };
    Message.AUTH = AUTH;
    Message.INIT = INIT;
    Message.INDEX = INDEX;
    Message.ENTITY = ENTITY;
    Message.CHANGE_VERSION = CHANGE_VERSION;
    Message.CHANGES = CHANGES;
    Message.HEARTBEAT = HEARTBEAT;
    Message.OPTIONS = OPTIONS;
    Message.REMOTE_INDEX = REMOTE_INDEX;
    Message.LOG = LOG;
    module.exports = Message
}, {"../package.json": 225, uuid: 224}], 234: [function (require, module, exports) {
    var events = require("events");
    var format = require("s");
    var inherits = require("inherits");
    var debug = require("debug")("simperium:simperium");
    var jsondiff = require("./jsondiff-wrapper");
    var Bucket = require("./bucket");
    var Connection = require("./connection");
    var Message = require("./message");
    var Binary = require("./binary");
    var bound_methods = ["bucket", "on", "start", "stop", "send", "synced"];

    function Simperium(app_id, options) {
        var key, connection_options;
        this.app_id = app_id;
        this.options = options || {};
        events.EventEmitter.call(this);
        bound_methods.forEach(function (bound_method) {
            this[bound_method] = this[bound_method].bind(this)
        }, this);
        this.buckets = {};
        this.channels = 0;
        this.logging = 0;
        this.jsondiff = new jsondiff;
        this.options["app_id"] = this.app_id;
        if ("sockjs"in this.options) {
            connection_options = this.options.sockjs
        } else {
            connection_options = {}
        }
        if ("path"in this.options) {
            connection_options.path = this.options.path
        } else {
            connection_options.path = format("sock/1/%s", this.app_id)
        }
        if ("host"in this.options) {
            connection_options.host = this.options.host
        }
        if ("port"in this.options) {
            connection_options.port = parseInt(this.options.port, 10)
        }
        if ("update_delay"in this.options) {
            this.options.update_delay = parseInt(this.options.update_delay, 10)
        } else {
            this.options.update_delay = 0
        }
        if ("page_delay"in this.options) {
            this.options.page_delay = parseInt(this.options.page_delay, 10)
        } else {
            this.options.page_delay = 0
        }
        this.connected = false;
        this.authorized = false;
        this.connection = new Connection(connection_options);
        this.connection.on("open", this._on_open.bind(this)).on("error", this._on_error.bind(this)).on("message", this._on_message.bind(this)).on("close", this._on_close.bind(this))
    }

    inherits(Simperium, events.EventEmitter);
    Simperium.prototype._send_log = function (log) {
        if (this.connected) {
            if (this.logging > 0) {
                log[0] = log[0].replace("%o", "%j");
                log = format.apply(null, log);
                this.connection.send(format("log:%j", {log: log}))
            }
        }
    };
    Simperium.prototype._log = function (log) {
        var args = Array.prototype.slice.call(arguments);
        debug.apply(debug, args);
        args[0] = "simperium: " + args[0];
        this._send_log(args)
    };
    Simperium.prototype.bucket = function (name, bucket_options) {
        var bucket, options, _this = this;
        name = name.toLowerCase().trim();
        bucket_options = bucket_options || {};
        bucket_options.n = this.channels++;
        options = this.jsondiff.deepCopy(this.options);
        for (key in bucket_options) {
            if (bucket_options.hasOwnProperty(key)) {
                options[key] = bucket_options[key]
            }
        }
        bucket = new Bucket(name, options, this.jsondiff);
        this.buckets[bucket_options.n] = bucket;
        this.on_event("start", bucket.start).on_event("open", bucket.on_open).on_event("close", bucket.on_close).on_event(format("message_%d", bucket_options.n), bucket.on_data);
        return bucket.on("log", function (message_format) {
            var args = Array.prototype.slice.call(arguments);
            args[0] = format("%s:%s", bucket.space, args[0]);
            _this._send_log(args)
        }).on("message", function (message, channel) {
            _this.send(format("%d:%s", channel, message))
        })
    };
    Simperium.prototype.on_event = Simperium.prototype.on;
    Simperium.prototype.on = function (bucket, event, callback) {
        this.buckets[bucket].on(event, callback)
    };
    Simperium.prototype.start = function () {
        this.connection.start();
        this.emit("start")
    };
    Simperium.prototype.stop = function () {
        this.connection.stop()
    };
    Simperium.prototype.send = function (data) {
        this.connection.send(data)
    };
    Simperium.prototype.synced = function () {
        var channel;
        for (channel in this.buckets) {
            if (!this.buckets.hasOwnProperty(channel)) {
                continue
            }
            if (this.buckets[channel].pending().length > 0) {
                return false
            }
        }
        return true
    };
    Simperium.prototype._on_open = function () {
        this._log("connection opened");
        this.connected = true;
        this.emit("open")
    };
    Simperium.prototype._on_close = function () {
        this.connected = false;
        this.emit("close");
        this._log("connection closed")
    };
    Simperium.prototype._on_error = function (error) {
        this._log("connection error: %s", error.toString())
    };
    Simperium.prototype._on_message = function (message, channel) {
        if (message instanceof Message.LOG) {
            this._log("got logging command: %s", message.level);
            this.logging = message.level || 0;
            return
        }
        if (null === channel) {
            return
        }
        if (!(channel in this.buckets)) {
            return
        }
        this.emit(format("message_%d", channel), message)
    };
    Simperium.Binary = Binary;
    module.exports = Simperium
}, {"./binary": 226, "./bucket": 227, "./connection": 228, "./jsondiff-wrapper": 231, "./message": 233, debug: 215, events: 44, inherits: 52, s: 218}], 235: [function (require, module, exports) {
    (function (global) {
        __browserify_shim_require__ = require;
        (function browserifyShim(module, exports, require, define, browserify_shim__define__module__export__) {
            var JSON;
            JSON || (JSON = {}), function () {
                function str(a, b) {
                    var c, d, e, f, g = gap, h, i = b[a];
                    i && typeof i == "object" && typeof i.toJSON == "function" && (i = i.toJSON(a)), typeof rep == "function" && (i = rep.call(b, a, i));
                    switch (typeof i) {
                        case"string":
                            return quote(i);
                        case"number":
                            return isFinite(i) ? String(i) : "null";
                        case"boolean":
                        case"null":
                            return String(i);
                        case"object":
                            if (!i)return"null";
                            gap += indent, h = [];
                            if (Object.prototype.toString.apply(i) === "[object Array]") {
                                f = i.length;
                                for (c = 0; c < f; c += 1)h[c] = str(c, i) || "null";
                                e = h.length === 0 ? "[]" : gap ? "[\n" + gap + h.join(",\n" + gap) + "\n" + g + "]" : "[" + h.join(",") + "]", gap = g;
                                return e
                            }
                            if (rep && typeof rep == "object") {
                                f = rep.length;
                                for (c = 0; c < f; c += 1)typeof rep[c] == "string" && (d = rep[c], e = str(d, i), e && h.push(quote(d) + (gap ? ": " : ":") + e))
                            } else for (d in i)Object.prototype.hasOwnProperty.call(i, d) && (e = str(d, i), e && h.push(quote(d) + (gap ? ": " : ":") + e));
                            e = h.length === 0 ? "{}" : gap ? "{\n" + gap + h.join(",\n" + gap) + "\n" + g + "}" : "{" + h.join(",") + "}", gap = g;
                            return e
                    }
                }

                function quote(a) {
                    escapable.lastIndex = 0;
                    return escapable.test(a) ? '"' + a.replace(escapable, function (a) {
                        var b = meta[a];
                        return typeof b == "string" ? b : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4)
                    }) + '"' : '"' + a + '"'
                }

                function f(a) {
                    return a < 10 ? "0" + a : a
                }

                "use strict", typeof Date.prototype.toJSON != "function" && (Date.prototype.toJSON = function (a) {
                    return isFinite(this.valueOf()) ? this.getUTCFullYear() + "-" + f(this.getUTCMonth() + 1) + "-" + f(this.getUTCDate()) + "T" + f(this.getUTCHours()) + ":" + f(this.getUTCMinutes()) + ":" + f(this.getUTCSeconds()) + "Z" : null
                }, String.prototype.toJSON = Number.prototype.toJSON = Boolean.prototype.toJSON = function (a) {
                    return this.valueOf()
                });
                var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, gap, indent, meta = {"\b": "\\b", "	": "\\t", "\n": "\\n", "\f": "\\f", "\r": "\\r", '"': '\\"', "\\": "\\\\"}, rep;
                typeof JSON.stringify != "function" && (JSON.stringify = function (a, b, c) {
                    var d;
                    gap = "", indent = "";
                    if (typeof c == "number")for (d = 0; d < c; d += 1)indent += " "; else typeof c == "string" && (indent = c);
                    rep = b;
                    if (!b || typeof b == "function" || typeof b == "object" && typeof b.length == "number")return str("", {"": a});
                    throw new Error("JSON.stringify")
                }), typeof JSON.parse != "function" && (JSON.parse = function (text, reviver) {
                    function walk(a, b) {
                        var c, d, e = a[b];
                        if (e && typeof e == "object")for (c in e)Object.prototype.hasOwnProperty.call(e, c) && (d = walk(e, c), d !== undefined ? e[c] = d : delete e[c]);
                        return reviver.call(a, b, e)
                    }

                    var j;
                    text = String(text), cx.lastIndex = 0, cx.test(text) && (text = text.replace(cx, function (a) {
                        return"\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4)
                    }));
                    if (/^[\],:{}\s]*$/.test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, "@").replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, "]").replace(/(?:^|:|,)(?:\s*\[)+/g, ""))) {
                        j = eval("(" + text + ")");
                        return typeof reviver == "function" ? walk({"": j}, "") : j
                    }
                    throw new SyntaxError("JSON.parse")
                })
            }();
            SockJS = function () {
                var _document = document;
                var _window = window;
                var utils = {};
                var REventTarget = function () {
                };
                REventTarget.prototype.addEventListener = function (eventType, listener) {
                    if (!this._listeners) {
                        this._listeners = {}
                    }
                    if (!(eventType in this._listeners)) {
                        this._listeners[eventType] = []
                    }
                    var arr = this._listeners[eventType];
                    if (utils.arrIndexOf(arr, listener) === -1) {
                        arr.push(listener)
                    }
                    return
                };
                REventTarget.prototype.removeEventListener = function (eventType, listener) {
                    if (!(this._listeners && eventType in this._listeners)) {
                        return
                    }
                    var arr = this._listeners[eventType];
                    var idx = utils.arrIndexOf(arr, listener);
                    if (idx !== -1) {
                        if (arr.length > 1) {
                            this._listeners[eventType] = arr.slice(0, idx).concat(arr.slice(idx + 1))
                        } else {
                            delete this._listeners[eventType]
                        }
                        return
                    }
                    return
                };
                REventTarget.prototype.dispatchEvent = function (event) {
                    var t = event.type;
                    var args = Array.prototype.slice.call(arguments, 0);
                    if (this["on" + t]) {
                        this["on" + t].apply(this, args)
                    }
                    if (this._listeners && t in this._listeners) {
                        for (var i = 0; i < this._listeners[t].length; i++) {
                            this._listeners[t][i].apply(this, args)
                        }
                    }
                };
                var SimpleEvent = function (type, obj) {
                    this.type = type;
                    if (typeof obj !== "undefined") {
                        for (var k in obj) {
                            if (!obj.hasOwnProperty(k))continue;
                            this[k] = obj[k]
                        }
                    }
                };
                SimpleEvent.prototype.toString = function () {
                    var r = [];
                    for (var k in this) {
                        if (!this.hasOwnProperty(k))continue;
                        var v = this[k];
                        if (typeof v === "function")v = "[function]";
                        r.push(k + "=" + v)
                    }
                    return"SimpleEvent(" + r.join(", ") + ")"
                };
                var EventEmitter = function (events) {
                    var that = this;
                    that._events = events || [];
                    that._listeners = {}
                };
                EventEmitter.prototype.emit = function (type) {
                    var that = this;
                    that._verifyType(type);
                    if (that._nuked)return;
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (that["on" + type]) {
                        that["on" + type].apply(that, args)
                    }
                    if (type in that._listeners) {
                        for (var i = 0; i < that._listeners[type].length; i++) {
                            that._listeners[type][i].apply(that, args)
                        }
                    }
                };
                EventEmitter.prototype.on = function (type, callback) {
                    var that = this;
                    that._verifyType(type);
                    if (that._nuked)return;
                    if (!(type in that._listeners)) {
                        that._listeners[type] = []
                    }
                    that._listeners[type].push(callback)
                };
                EventEmitter.prototype._verifyType = function (type) {
                    var that = this;
                    if (utils.arrIndexOf(that._events, type) === -1) {
                        utils.log("Event " + JSON.stringify(type) + " not listed " + JSON.stringify(that._events) + " in " + that)
                    }
                };
                EventEmitter.prototype.nuke = function () {
                    var that = this;
                    that._nuked = true;
                    for (var i = 0; i < that._events.length; i++) {
                        delete that[that._events[i]]
                    }
                    that._listeners = {}
                };
                var random_string_chars = "abcdefghijklmnopqrstuvwxyz0123456789_";
                utils.random_string = function (length, max) {
                    max = max || random_string_chars.length;
                    var i, ret = [];
                    for (i = 0; i < length; i++) {
                        ret.push(random_string_chars.substr(Math.floor(Math.random() * max), 1))
                    }
                    return ret.join("")
                };
                utils.random_number = function (max) {
                    return Math.floor(Math.random() * max)
                };
                utils.random_number_string = function (max) {
                    var t = ("" + (max - 1)).length;
                    var p = Array(t + 1).join("0");
                    return(p + utils.random_number(max)).slice(-t)
                };
                utils.getOrigin = function (url) {
                    url += "/";
                    var parts = url.split("/").slice(0, 3);
                    return parts.join("/")
                };
                utils.isSameOriginUrl = function (url_a, url_b) {
                    if (!url_b)url_b = _window.location.href;
                    return url_a.split("/").slice(0, 3).join("/") === url_b.split("/").slice(0, 3).join("/")
                };
                utils.getParentDomain = function (url) {
                    if (/^[0-9.]*$/.test(url))return url;
                    if (/^\[/.test(url))return url;
                    if (!/[.]/.test(url))return url;
                    var parts = url.split(".").slice(1);
                    return parts.join(".")
                };
                utils.objectExtend = function (dst, src) {
                    for (var k in src) {
                        if (src.hasOwnProperty(k)) {
                            dst[k] = src[k]
                        }
                    }
                    return dst
                };
                var WPrefix = "_jp";
                utils.polluteGlobalNamespace = function () {
                    if (!(WPrefix in _window)) {
                        _window[WPrefix] = {}
                    }
                };
                utils.closeFrame = function (code, reason) {
                    return"c" + JSON.stringify([code, reason])
                };
                utils.userSetCode = function (code) {
                    return code === 1e3 || code >= 3e3 && code <= 4999
                };
                utils.countRTO = function (rtt) {
                    var rto;
                    if (rtt > 100) {
                        rto = 3 * rtt
                    } else {
                        rto = rtt + 200
                    }
                    return rto
                };
                utils.log = function () {
                    if (_window.console && console.log && console.log.apply) {
                        console.log.apply(console, arguments)
                    }
                };
                utils.bind = function (fun, that) {
                    if (fun.bind) {
                        return fun.bind(that)
                    } else {
                        return function () {
                            return fun.apply(that, arguments)
                        }
                    }
                };
                utils.flatUrl = function (url) {
                    return url.indexOf("?") === -1 && url.indexOf("#") === -1
                };
                utils.amendUrl = function (url) {
                    var dl = _document.location;
                    if (!url) {
                        throw new Error("Wrong url for SockJS")
                    }
                    if (!utils.flatUrl(url)) {
                        throw new Error("Only basic urls are supported in SockJS")
                    }
                    if (url.indexOf("//") === 0) {
                        url = dl.protocol + url
                    }
                    if (url.indexOf("/") === 0) {
                        url = dl.protocol + "//" + dl.host + url
                    }
                    url = url.replace(/[/]+$/, "");
                    return url
                };
                utils.arrIndexOf = function (arr, obj) {
                    for (var i = 0; i < arr.length; i++) {
                        if (arr[i] === obj) {
                            return i
                        }
                    }
                    return-1
                };
                utils.arrSkip = function (arr, obj) {
                    var idx = utils.arrIndexOf(arr, obj);
                    if (idx === -1) {
                        return arr.slice()
                    } else {
                        var dst = arr.slice(0, idx);
                        return dst.concat(arr.slice(idx + 1))
                    }
                };
                utils.isArray = Array.isArray || function (value) {
                    return{}.toString.call(value).indexOf("Array") >= 0
                };
                utils.delay = function (t, fun) {
                    if (typeof t === "function") {
                        fun = t;
                        t = 0
                    }
                    return setTimeout(fun, t)
                };
                var json_escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, json_lookup = {"\x00": "\\u0000", "": "\\u0001", "": "\\u0002", "": "\\u0003", "": "\\u0004", "": "\\u0005", "": "\\u0006", "": "\\u0007", "\b": "\\b", "	": "\\t", "\n": "\\n", "": "\\u000b", "\f": "\\f", "\r": "\\r", "": "\\u000e", "": "\\u000f", "": "\\u0010", "": "\\u0011", "": "\\u0012", "": "\\u0013", "": "\\u0014", "": "\\u0015", "": "\\u0016", "": "\\u0017", "": "\\u0018", "": "\\u0019", "": "\\u001a", "": "\\u001b", "": "\\u001c", "": "\\u001d", "": "\\u001e", "": "\\u001f", '"': '\\"', "\\": "\\\\", "": "\\u007f", "": "\\u0080", "": "\\u0081", "": "\\u0082", "": "\\u0083", "": "\\u0084", "": "\\u0085", "": "\\u0086", "": "\\u0087", "": "\\u0088", "": "\\u0089", "": "\\u008a", "": "\\u008b", "": "\\u008c", "": "\\u008d", "": "\\u008e", "": "\\u008f", "": "\\u0090", "": "\\u0091", "": "\\u0092", "": "\\u0093", "": "\\u0094", "": "\\u0095", "": "\\u0096", "": "\\u0097", "": "\\u0098", "": "\\u0099", "": "\\u009a", "": "\\u009b", "": "\\u009c", "": "\\u009d", "": "\\u009e", "": "\\u009f", "": "\\u00ad", "": "\\u0600", "": "\\u0601", "": "\\u0602", "": "\\u0603", "": "\\u0604", "": "\\u070f", "": "\\u17b4", "": "\\u17b5", "": "\\u200c", "": "\\u200d", "": "\\u200e", "": "\\u200f", "\u2028": "\\u2028", "\u2029": "\\u2029", "": "\\u202a", "": "\\u202b", "": "\\u202c", "": "\\u202d", "": "\\u202e", "": "\\u202f", "": "\\u2060", "": "\\u2061", "": "\\u2062", "": "\\u2063", "": "\\u2064", "": "\\u2065", "": "\\u2066", "": "\\u2067", "": "\\u2068", "": "\\u2069", "": "\\u206a", "": "\\u206b", "": "\\u206c", "": "\\u206d", "": "\\u206e", "": "\\u206f", "": "\\ufeff", "": "\\ufff0", "": "\\ufff1", "": "\\ufff2", "": "\\ufff3", "": "\\ufff4", "": "\\ufff5", "": "\\ufff6", "": "\\ufff7", "": "\\ufff8", "": "\\ufff9", "": "\\ufffa", "": "\\ufffb", "": "\\ufffc", "": "\\ufffd", "": "\\ufffe", "": "\\uffff"};
                var extra_escapable = /[\x00-\x1f\ud800-\udfff\ufffe\uffff\u0300-\u0333\u033d-\u0346\u034a-\u034c\u0350-\u0352\u0357-\u0358\u035c-\u0362\u0374\u037e\u0387\u0591-\u05af\u05c4\u0610-\u0617\u0653-\u0654\u0657-\u065b\u065d-\u065e\u06df-\u06e2\u06eb-\u06ec\u0730\u0732-\u0733\u0735-\u0736\u073a\u073d\u073f-\u0741\u0743\u0745\u0747\u07eb-\u07f1\u0951\u0958-\u095f\u09dc-\u09dd\u09df\u0a33\u0a36\u0a59-\u0a5b\u0a5e\u0b5c-\u0b5d\u0e38-\u0e39\u0f43\u0f4d\u0f52\u0f57\u0f5c\u0f69\u0f72-\u0f76\u0f78\u0f80-\u0f83\u0f93\u0f9d\u0fa2\u0fa7\u0fac\u0fb9\u1939-\u193a\u1a17\u1b6b\u1cda-\u1cdb\u1dc0-\u1dcf\u1dfc\u1dfe\u1f71\u1f73\u1f75\u1f77\u1f79\u1f7b\u1f7d\u1fbb\u1fbe\u1fc9\u1fcb\u1fd3\u1fdb\u1fe3\u1feb\u1fee-\u1fef\u1ff9\u1ffb\u1ffd\u2000-\u2001\u20d0-\u20d1\u20d4-\u20d7\u20e7-\u20e9\u2126\u212a-\u212b\u2329-\u232a\u2adc\u302b-\u302c\uaab2-\uaab3\uf900-\ufa0d\ufa10\ufa12\ufa15-\ufa1e\ufa20\ufa22\ufa25-\ufa26\ufa2a-\ufa2d\ufa30-\ufa6d\ufa70-\ufad9\ufb1d\ufb1f\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufb4e\ufff0-\uffff]/g, extra_lookup;
                var JSONQuote = JSON && JSON.stringify || function (string) {
                    json_escapable.lastIndex = 0;
                    if (json_escapable.test(string)) {
                        string = string.replace(json_escapable, function (a) {
                            return json_lookup[a]
                        })
                    }
                    return'"' + string + '"'
                };
                var unroll_lookup = function (escapable) {
                    var i;
                    var unrolled = {};
                    var c = [];
                    for (i = 0; i < 65536; i++) {
                        c.push(String.fromCharCode(i))
                    }
                    escapable.lastIndex = 0;
                    c.join("").replace(escapable, function (a) {
                        unrolled[a] = "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
                        return""
                    });
                    escapable.lastIndex = 0;
                    return unrolled
                };
                utils.quote = function (string) {
                    var quoted = JSONQuote(string);
                    extra_escapable.lastIndex = 0;
                    if (!extra_escapable.test(quoted)) {
                        return quoted
                    }
                    if (!extra_lookup)extra_lookup = unroll_lookup(extra_escapable);
                    return quoted.replace(extra_escapable, function (a) {
                        return extra_lookup[a]
                    })
                };
                var _all_protocols = ["websocket", "xdr-streaming", "xhr-streaming", "iframe-eventsource", "iframe-htmlfile", "xdr-polling", "xhr-polling", "iframe-xhr-polling", "jsonp-polling"];
                utils.probeProtocols = function () {
                    var probed = {};
                    for (var i = 0; i < _all_protocols.length; i++) {
                        var protocol = _all_protocols[i];
                        probed[protocol] = SockJS[protocol] && SockJS[protocol].enabled()
                    }
                    return probed
                };
                utils.detectProtocols = function (probed, protocols_whitelist, info) {
                    var pe = {}, protocols = [];
                    if (!protocols_whitelist)protocols_whitelist = _all_protocols;
                    for (var i = 0; i < protocols_whitelist.length; i++) {
                        var protocol = protocols_whitelist[i];
                        pe[protocol] = probed[protocol]
                    }
                    var maybe_push = function (protos) {
                        var proto = protos.shift();
                        if (pe[proto]) {
                            protocols.push(proto)
                        } else {
                            if (protos.length > 0) {
                                maybe_push(protos)
                            }
                        }
                    };
                    if (info.websocket !== false) {
                        maybe_push(["websocket"])
                    }
                    if (pe["xhr-streaming"] && !info.null_origin) {
                        protocols.push("xhr-streaming")
                    } else {
                        if (pe["xdr-streaming"] && !info.cookie_needed && !info.null_origin) {
                            protocols.push("xdr-streaming")
                        } else {
                            maybe_push(["iframe-eventsource", "iframe-htmlfile"])
                        }
                    }
                    if (pe["xhr-polling"] && !info.null_origin) {
                        protocols.push("xhr-polling")
                    } else {
                        if (pe["xdr-polling"] && !info.cookie_needed && !info.null_origin) {
                            protocols.push("xdr-polling")
                        } else {
                            maybe_push(["iframe-xhr-polling", "jsonp-polling"])
                        }
                    }
                    return protocols
                };
                var MPrefix = "_sockjs_global";
                utils.createHook = function () {
                    var window_id = "a" + utils.random_string(8);
                    if (!(MPrefix in _window)) {
                        var map = {};
                        _window[MPrefix] = function (window_id) {
                            if (!(window_id in map)) {
                                map[window_id] = {id: window_id, del: function () {
                                    delete map[window_id]
                                }}
                            }
                            return map[window_id]
                        }
                    }
                    return _window[MPrefix](window_id)
                };
                utils.attachMessage = function (listener) {
                    utils.attachEvent("message", listener)
                };
                utils.attachEvent = function (event, listener) {
                    if (typeof _window.addEventListener !== "undefined") {
                        _window.addEventListener(event, listener, false)
                    } else {
                        _document.attachEvent("on" + event, listener);
                        _window.attachEvent("on" + event, listener)
                    }
                };
                utils.detachMessage = function (listener) {
                    utils.detachEvent("message", listener)
                };
                utils.detachEvent = function (event, listener) {
                    if (typeof _window.addEventListener !== "undefined") {
                        _window.removeEventListener(event, listener, false)
                    } else {
                        _document.detachEvent("on" + event, listener);
                        _window.detachEvent("on" + event, listener)
                    }
                };
                var on_unload = {};
                var after_unload = false;
                var trigger_unload_callbacks = function () {
                    for (var ref in on_unload) {
                        on_unload[ref]();
                        delete on_unload[ref]
                    }
                };
                var unload_triggered = function () {
                    if (after_unload)return;
                    after_unload = true;
                    trigger_unload_callbacks()
                };
                utils.attachEvent("unload", unload_triggered);
                utils.unload_add = function (listener) {
                    var ref = utils.random_string(8);
                    on_unload[ref] = listener;
                    if (after_unload) {
                        utils.delay(trigger_unload_callbacks)
                    }
                    return ref
                };
                utils.unload_del = function (ref) {
                    if (ref in on_unload)delete on_unload[ref]
                };
                utils.createIframe = function (iframe_url, error_callback) {
                    var iframe = _document.createElement("iframe");
                    var tref, unload_ref;
                    var unattach = function () {
                        clearTimeout(tref);
                        try {
                            iframe.onload = null
                        } catch (x) {
                        }
                        iframe.onerror = null
                    };
                    var cleanup = function () {
                        if (iframe) {
                            unattach();
                            setTimeout(function () {
                                if (iframe) {
                                    iframe.parentNode.removeChild(iframe)
                                }
                                iframe = null
                            }, 0);
                            utils.unload_del(unload_ref)
                        }
                    };
                    var onerror = function (r) {
                        if (iframe) {
                            cleanup();
                            error_callback(r)
                        }
                    };
                    var post = function (msg, origin) {
                        try {
                            if (iframe && iframe.contentWindow) {
                                iframe.contentWindow.postMessage(msg, origin)
                            }
                        } catch (x) {
                        }
                    };
                    iframe.src = iframe_url;
                    iframe.style.display = "none";
                    iframe.style.position = "absolute";
                    iframe.onerror = function () {
                        onerror("onerror")
                    };
                    iframe.onload = function () {
                        clearTimeout(tref);
                        tref = setTimeout(function () {
                            onerror("onload timeout")
                        }, 2e3)
                    };
                    _document.body.appendChild(iframe);
                    tref = setTimeout(function () {
                        onerror("timeout")
                    }, 15e3);
                    unload_ref = utils.unload_add(cleanup);
                    return{post: post, cleanup: cleanup, loaded: unattach}
                };
                utils.createHtmlfile = function (iframe_url, error_callback) {
                    var doc = new ActiveXObject("htmlfile");
                    var tref, unload_ref;
                    var iframe;
                    var unattach = function () {
                        clearTimeout(tref)
                    };
                    var cleanup = function () {
                        if (doc) {
                            unattach();
                            utils.unload_del(unload_ref);
                            iframe.parentNode.removeChild(iframe);
                            iframe = doc = null;
                            CollectGarbage()
                        }
                    };
                    var onerror = function (r) {
                        if (doc) {
                            cleanup();
                            error_callback(r)
                        }
                    };
                    var post = function (msg, origin) {
                        try {
                            if (iframe && iframe.contentWindow) {
                                iframe.contentWindow.postMessage(msg, origin)
                            }
                        } catch (x) {
                        }
                    };
                    doc.open();
                    doc.write("<html><s" + "cript>" + 'document.domain="' + document.domain + '";' + "</s" + "cript></html>");
                    doc.close();
                    doc.parentWindow[WPrefix] = _window[WPrefix];
                    var c = doc.createElement("div");
                    doc.body.appendChild(c);
                    iframe = doc.createElement("iframe");
                    c.appendChild(iframe);
                    iframe.src = iframe_url;
                    tref = setTimeout(function () {
                        onerror("timeout")
                    }, 15e3);
                    unload_ref = utils.unload_add(cleanup);
                    return{post: post, cleanup: cleanup, loaded: unattach}
                };
                var AbstractXHRObject = function () {
                };
                AbstractXHRObject.prototype = new EventEmitter(["chunk", "finish"]);
                AbstractXHRObject.prototype._start = function (method, url, payload, opts) {
                    var that = this;
                    try {
                        that.xhr = new XMLHttpRequest
                    } catch (x) {
                    }
                    if (!that.xhr) {
                        try {
                            that.xhr = new _window.ActiveXObject("Microsoft.XMLHTTP")
                        } catch (x) {
                        }
                    }
                    if (_window.ActiveXObject || _window.XDomainRequest) {
                        url += (url.indexOf("?") === -1 ? "?" : "&") + "t=" + +new Date
                    }
                    that.unload_ref = utils.unload_add(function () {
                        that._cleanup(true)
                    });
                    try {
                        that.xhr.open(method, url, true)
                    } catch (e) {
                        that.emit("finish", 0, "");
                        that._cleanup();
                        return
                    }
                    if (!opts || !opts.no_credentials) {
                        that.xhr.withCredentials = "true"
                    }
                    if (opts && opts.headers) {
                        for (var key in opts.headers) {
                            that.xhr.setRequestHeader(key, opts.headers[key])
                        }
                    }
                    that.xhr.onreadystatechange = function () {
                        if (that.xhr) {
                            var x = that.xhr;
                            switch (x.readyState) {
                                case 3:
                                    try {
                                        var status = x.status;
                                        var text = x.responseText
                                    } catch (x) {
                                    }
                                    ;
                                    if (status === 1223)status = 204;
                                    if (text && text.length > 0) {
                                        that.emit("chunk", status, text)
                                    }
                                    break;
                                case 4:
                                    var status = x.status;
                                    if (status === 1223)status = 204;
                                    that.emit("finish", status, x.responseText);
                                    that._cleanup(false);
                                    break
                            }
                        }
                    };
                    that.xhr.send(payload)
                };
                AbstractXHRObject.prototype._cleanup = function (abort) {
                    var that = this;
                    if (!that.xhr)return;
                    utils.unload_del(that.unload_ref);
                    that.xhr.onreadystatechange = function () {
                    };
                    if (abort) {
                        try {
                            that.xhr.abort()
                        } catch (x) {
                        }
                    }
                    that.unload_ref = that.xhr = null
                };
                AbstractXHRObject.prototype.close = function () {
                    var that = this;
                    that.nuke();
                    that._cleanup(true)
                };
                var XHRCorsObject = utils.XHRCorsObject = function () {
                    var that = this, args = arguments;
                    utils.delay(function () {
                        that._start.apply(that, args)
                    })
                };
                XHRCorsObject.prototype = new AbstractXHRObject;
                var XHRLocalObject = utils.XHRLocalObject = function (method, url, payload) {
                    var that = this;
                    utils.delay(function () {
                        that._start(method, url, payload, {no_credentials: true})
                    })
                };
                XHRLocalObject.prototype = new AbstractXHRObject;
                var XDRObject = utils.XDRObject = function (method, url, payload) {
                    var that = this;
                    utils.delay(function () {
                        that._start(method, url, payload)
                    })
                };
                XDRObject.prototype = new EventEmitter(["chunk", "finish"]);
                XDRObject.prototype._start = function (method, url, payload) {
                    var that = this;
                    var xdr = new XDomainRequest;
                    url += (url.indexOf("?") === -1 ? "?" : "&") + "t=" + +new Date;
                    var onerror = xdr.ontimeout = xdr.onerror = function () {
                        that.emit("finish", 0, "");
                        that._cleanup(false)
                    };
                    xdr.onprogress = function () {
                        that.emit("chunk", 200, xdr.responseText)
                    };
                    xdr.onload = function () {
                        that.emit("finish", 200, xdr.responseText);
                        that._cleanup(false)
                    };
                    that.xdr = xdr;
                    that.unload_ref = utils.unload_add(function () {
                        that._cleanup(true)
                    });
                    try {
                        that.xdr.open(method, url);
                        that.xdr.send(payload)
                    } catch (x) {
                        onerror()
                    }
                };
                XDRObject.prototype._cleanup = function (abort) {
                    var that = this;
                    if (!that.xdr)return;
                    utils.unload_del(that.unload_ref);
                    that.xdr.ontimeout = that.xdr.onerror = that.xdr.onprogress = that.xdr.onload = null;
                    if (abort) {
                        try {
                            that.xdr.abort()
                        } catch (x) {
                        }
                    }
                    that.unload_ref = that.xdr = null
                };
                XDRObject.prototype.close = function () {
                    var that = this;
                    that.nuke();
                    that._cleanup(true)
                };
                utils.isXHRCorsCapable = function () {
                    if (_window.XMLHttpRequest && "withCredentials"in new XMLHttpRequest) {
                        return 1
                    }
                    if (_window.XDomainRequest && _document.domain) {
                        return 2
                    }
                    if (IframeTransport.enabled()) {
                        return 3
                    }
                    return 4
                };
                var SockJS = function (url, dep_protocols_whitelist, options) {
                    if (this === _window) {
                        return new SockJS(url, dep_protocols_whitelist, options)
                    }
                    var that = this, protocols_whitelist;
                    that._options = {devel: false, debug: false, protocols_whitelist: [], info: undefined, rtt: undefined};
                    if (options) {
                        utils.objectExtend(that._options, options)
                    }
                    that._base_url = utils.amendUrl(url);
                    that._server = that._options.server || utils.random_number_string(1e3);
                    if (that._options.protocols_whitelist && that._options.protocols_whitelist.length) {
                        protocols_whitelist = that._options.protocols_whitelist
                    } else {
                        if (typeof dep_protocols_whitelist === "string" && dep_protocols_whitelist.length > 0) {
                            protocols_whitelist = [dep_protocols_whitelist]
                        } else if (utils.isArray(dep_protocols_whitelist)) {
                            protocols_whitelist = dep_protocols_whitelist
                        } else {
                            protocols_whitelist = null
                        }
                        if (protocols_whitelist) {
                            that._debug('Deprecated API: Use "protocols_whitelist" option ' + "instead of supplying protocol list as a second " + "parameter to SockJS constructor.")
                        }
                    }
                    that._protocols = [];
                    that.protocol = null;
                    that.readyState = SockJS.CONNECTING;
                    that._ir = createInfoReceiver(that._base_url);
                    that._ir.onfinish = function (info, rtt) {
                        that._ir = null;
                        if (info) {
                            if (that._options.info) {
                                info = utils.objectExtend(info, that._options.info)
                            }
                            if (that._options.rtt) {
                                rtt = that._options.rtt
                            }
                            that._applyInfo(info, rtt, protocols_whitelist);
                            that._didClose()
                        } else {
                            that._didClose(1002, "Can't connect to server", true)
                        }
                    }
                };
                SockJS.prototype = new REventTarget;
                SockJS.version = "0.3.4";
                SockJS.CONNECTING = 0;
                SockJS.OPEN = 1;
                SockJS.CLOSING = 2;
                SockJS.CLOSED = 3;
                SockJS.prototype._debug = function () {
                    if (this._options.debug)utils.log.apply(utils, arguments)
                };
                SockJS.prototype._dispatchOpen = function () {
                    var that = this;
                    if (that.readyState === SockJS.CONNECTING) {
                        if (that._transport_tref) {
                            clearTimeout(that._transport_tref);
                            that._transport_tref = null
                        }
                        that.readyState = SockJS.OPEN;
                        that.dispatchEvent(new SimpleEvent("open"))
                    } else {
                        that._didClose(1006, "Server lost session")
                    }
                };
                SockJS.prototype._dispatchMessage = function (data) {
                    var that = this;
                    if (that.readyState !== SockJS.OPEN)return;
                    that.dispatchEvent(new SimpleEvent("message", {data: data}))
                };
                SockJS.prototype._dispatchHeartbeat = function (data) {
                    var that = this;
                    if (that.readyState !== SockJS.OPEN)return;
                    that.dispatchEvent(new SimpleEvent("heartbeat", {}))
                };
                SockJS.prototype._didClose = function (code, reason, force) {
                    var that = this;
                    if (that.readyState !== SockJS.CONNECTING && that.readyState !== SockJS.OPEN && that.readyState !== SockJS.CLOSING)throw new Error("INVALID_STATE_ERR");
                    if (that._ir) {
                        that._ir.nuke();
                        that._ir = null
                    }
                    if (that._transport) {
                        that._transport.doCleanup();
                        that._transport = null
                    }
                    var close_event = new SimpleEvent("close", {code: code, reason: reason, wasClean: utils.userSetCode(code)});
                    if (!utils.userSetCode(code) && that.readyState === SockJS.CONNECTING && !force) {
                        if (that._try_next_protocol(close_event)) {
                            return
                        }
                        close_event = new SimpleEvent("close", {code: 2e3, reason: "All transports failed", wasClean: false, last_event: close_event})
                    }
                    that.readyState = SockJS.CLOSED;
                    utils.delay(function () {
                        that.dispatchEvent(close_event)
                    })
                };
                SockJS.prototype._didMessage = function (data) {
                    var that = this;
                    var type = data.slice(0, 1);
                    switch (type) {
                        case"o":
                            that._dispatchOpen();
                            break;
                        case"a":
                            var payload = JSON.parse(data.slice(1) || "[]");
                            for (var i = 0; i < payload.length; i++) {
                                that._dispatchMessage(payload[i])
                            }
                            break;
                        case"m":
                            var payload = JSON.parse(data.slice(1) || "null");
                            that._dispatchMessage(payload);
                            break;
                        case"c":
                            var payload = JSON.parse(data.slice(1) || "[]");
                            that._didClose(payload[0], payload[1]);
                            break;
                        case"h":
                            that._dispatchHeartbeat();
                            break
                    }
                };
                SockJS.prototype._try_next_protocol = function (close_event) {
                    var that = this;
                    if (that.protocol) {
                        that._debug("Closed transport:", that.protocol, "" + close_event);
                        that.protocol = null
                    }
                    if (that._transport_tref) {
                        clearTimeout(that._transport_tref);
                        that._transport_tref = null
                    }
                    while (1) {
                        var protocol = that.protocol = that._protocols.shift();
                        if (!protocol) {
                            return false
                        }
                        if (SockJS[protocol] && SockJS[protocol].need_body === true && (!_document.body || typeof _document.readyState !== "undefined" && _document.readyState !== "complete")) {
                            that._protocols.unshift(protocol);
                            that.protocol = "waiting-for-load";
                            utils.attachEvent("load", function () {
                                that._try_next_protocol()
                            });
                            return true
                        }
                        if (!SockJS[protocol] || !SockJS[protocol].enabled(that._options)) {
                            that._debug("Skipping transport:", protocol)
                        } else {
                            var roundTrips = SockJS[protocol].roundTrips || 1;
                            var to = (that._options.rto || 0) * roundTrips || 5e3;
                            that._transport_tref = utils.delay(to, function () {
                                if (that.readyState === SockJS.CONNECTING) {
                                    that._didClose(2007, "Transport timeouted")
                                }
                            });
                            var connid = utils.random_string(8);
                            var trans_url = that._base_url + "/" + that._server + "/" + connid;
                            that._debug("Opening transport:", protocol, " url:" + trans_url, " RTO:" + that._options.rto);
                            that._transport = new SockJS[protocol](that, trans_url, that._base_url);
                            return true
                        }
                    }
                };
                SockJS.prototype.close = function (code, reason) {
                    var that = this;
                    if (code && !utils.userSetCode(code))throw new Error("INVALID_ACCESS_ERR");
                    if (that.readyState !== SockJS.CONNECTING && that.readyState !== SockJS.OPEN) {
                        return false
                    }
                    that.readyState = SockJS.CLOSING;
                    that._didClose(code || 1e3, reason || "Normal closure");
                    return true
                };
                SockJS.prototype.send = function (data) {
                    var that = this;
                    if (that.readyState === SockJS.CONNECTING)throw new Error("INVALID_STATE_ERR");
                    if (that.readyState === SockJS.OPEN) {
                        that._transport.doSend(utils.quote("" + data))
                    }
                    return true
                };
                SockJS.prototype._applyInfo = function (info, rtt, protocols_whitelist) {
                    var that = this;
                    that._options.info = info;
                    that._options.rtt = rtt;
                    that._options.rto = utils.countRTO(rtt);
                    that._options.info.null_origin = !_document.domain;
                    var probed = utils.probeProtocols();
                    that._protocols = utils.detectProtocols(probed, protocols_whitelist, info)
                };
                var WebSocketTransport = SockJS.websocket = function (ri, trans_url) {
                    var that = this;
                    var url = trans_url + "/websocket";
                    if (url.slice(0, 5) === "https") {
                        url = "wss" + url.slice(5)
                    } else {
                        url = "ws" + url.slice(4)
                    }
                    that.ri = ri;
                    that.url = url;
                    var Constructor = _window.WebSocket || _window.MozWebSocket;
                    that.ws = new Constructor(that.url);
                    that.ws.onmessage = function (e) {
                        that.ri._didMessage(e.data)
                    };
                    that.unload_ref = utils.unload_add(function () {
                        that.ws.close()
                    });
                    that.ws.onclose = function () {
                        that.ri._didMessage(utils.closeFrame(1006, "WebSocket connection broken"))
                    }
                };
                WebSocketTransport.prototype.doSend = function (data) {
                    this.ws.send("[" + data + "]")
                };
                WebSocketTransport.prototype.doCleanup = function () {
                    var that = this;
                    var ws = that.ws;
                    if (ws) {
                        ws.onmessage = ws.onclose = null;
                        ws.close();
                        utils.unload_del(that.unload_ref);
                        that.unload_ref = that.ri = that.ws = null
                    }
                };
                WebSocketTransport.enabled = function () {
                    return!!(_window.WebSocket || _window.MozWebSocket)
                };
                WebSocketTransport.roundTrips = 2;
                var BufferedSender = function () {
                };
                BufferedSender.prototype.send_constructor = function (sender) {
                    var that = this;
                    that.send_buffer = [];
                    that.sender = sender
                };
                BufferedSender.prototype.doSend = function (message) {
                    var that = this;
                    that.send_buffer.push(message);
                    if (!that.send_stop) {
                        that.send_schedule()
                    }
                };
                BufferedSender.prototype.send_schedule_wait = function () {
                    var that = this;
                    var tref;
                    that.send_stop = function () {
                        that.send_stop = null;
                        clearTimeout(tref)
                    };
                    tref = utils.delay(25, function () {
                        that.send_stop = null;
                        that.send_schedule()
                    })
                };
                BufferedSender.prototype.send_schedule = function () {
                    var that = this;
                    if (that.send_buffer.length > 0) {
                        var payload = "[" + that.send_buffer.join(",") + "]";
                        that.send_stop = that.sender(that.trans_url, payload, function (success, abort_reason) {
                            that.send_stop = null;
                            if (success === false) {
                                that.ri._didClose(1006, "Sending error " + abort_reason)
                            } else {
                                that.send_schedule_wait()
                            }
                        });
                        that.send_buffer = []
                    }
                };
                BufferedSender.prototype.send_destructor = function () {
                    var that = this;
                    if (that._send_stop) {
                        that._send_stop()
                    }
                    that._send_stop = null
                };
                var jsonPGenericSender = function (url, payload, callback) {
                    var that = this;
                    if (!("_send_form"in that)) {
                        var form = that._send_form = _document.createElement("form");
                        var area = that._send_area = _document.createElement("textarea");
                        area.name = "d";
                        form.style.display = "none";
                        form.style.position = "absolute";
                        form.method = "POST";
                        form.enctype = "application/x-www-form-urlencoded";
                        form.acceptCharset = "UTF-8";
                        form.appendChild(area);
                        _document.body.appendChild(form)
                    }
                    var form = that._send_form;
                    var area = that._send_area;
                    var id = "a" + utils.random_string(8);
                    form.target = id;
                    form.action = url + "/jsonp_send?i=" + id;
                    var iframe;
                    try {
                        iframe = _document.createElement('<iframe name="' + id + '">')
                    } catch (x) {
                        iframe = _document.createElement("iframe");
                        iframe.name = id
                    }
                    iframe.id = id;
                    form.appendChild(iframe);
                    iframe.style.display = "none";
                    try {
                        area.value = payload
                    } catch (e) {
                        utils.log("Your browser is seriously broken. Go home! " + e.message)
                    }
                    form.submit();
                    var completed = function (e) {
                        if (!iframe.onerror)return;
                        iframe.onreadystatechange = iframe.onerror = iframe.onload = null;
                        utils.delay(500, function () {
                            iframe.parentNode.removeChild(iframe);
                            iframe = null
                        });
                        area.value = "";
                        callback(true)
                    };
                    iframe.onerror = iframe.onload = completed;
                    iframe.onreadystatechange = function (e) {
                        if (iframe.readyState == "complete")completed()
                    };
                    return completed
                };
                var createAjaxSender = function (AjaxObject) {
                    return function (url, payload, callback) {
                        var xo = new AjaxObject("POST", url + "/xhr_send", payload);
                        xo.onfinish = function (status, text) {
                            callback(status === 200 || status === 204, "http status " + status)
                        };
                        return function (abort_reason) {
                            callback(false, abort_reason)
                        }
                    }
                };
                var jsonPGenericReceiver = function (url, callback) {
                    var tref;
                    var script = _document.createElement("script");
                    var script2;
                    var close_script = function (frame) {
                        if (script2) {
                            script2.parentNode.removeChild(script2);
                            script2 = null
                        }
                        if (script) {
                            clearTimeout(tref);
                            script.parentNode.removeChild(script);
                            script.onreadystatechange = script.onerror = script.onload = script.onclick = null;
                            script = null;
                            callback(frame);
                            callback = null
                        }
                    };
                    var loaded_okay = false;
                    var error_timer = null;
                    script.id = "a" + utils.random_string(8);
                    script.src = url;
                    script.type = "text/javascript";
                    script.charset = "UTF-8";
                    script.onerror = function (e) {
                        if (!error_timer) {
                            error_timer = setTimeout(function () {
                                if (!loaded_okay) {
                                    close_script(utils.closeFrame(1006, "JSONP script loaded abnormally (onerror)"))
                                }
                            }, 1e3)
                        }
                    };
                    script.onload = function (e) {
                        close_script(utils.closeFrame(1006, "JSONP script loaded abnormally (onload)"))
                    };
                    script.onreadystatechange = function (e) {
                        if (/loaded|closed/.test(script.readyState)) {
                            if (script && script.htmlFor && script.onclick) {
                                loaded_okay = true;
                                try {
                                    script.onclick()
                                } catch (x) {
                                }
                            }
                            if (script) {
                                close_script(utils.closeFrame(1006, "JSONP script loaded abnormally (onreadystatechange)"))
                            }
                        }
                    };
                    if (typeof script.async === "undefined" && _document.attachEvent) {
                        if (!/opera/i.test(navigator.userAgent)) {
                            try {
                                script.htmlFor = script.id;
                                script.event = "onclick"
                            } catch (x) {
                            }
                            script.async = true
                        } else {
                            script2 = _document.createElement("script");
                            script2.text = "try{var a = document.getElementById('" + script.id + "'); if(a)a.onerror();}catch(x){};";
                            script.async = script2.async = false
                        }
                    }
                    if (typeof script.async !== "undefined") {
                        script.async = true
                    }
                    tref = setTimeout(function () {
                        close_script(utils.closeFrame(1006, "JSONP script loaded abnormally (timeout)"))
                    }, 35e3);
                    var head = _document.getElementsByTagName("head")[0];
                    head.insertBefore(script, head.firstChild);
                    if (script2) {
                        head.insertBefore(script2, head.firstChild)
                    }
                    return close_script
                };
                var JsonPTransport = SockJS["jsonp-polling"] = function (ri, trans_url) {
                    utils.polluteGlobalNamespace();
                    var that = this;
                    that.ri = ri;
                    that.trans_url = trans_url;
                    that.send_constructor(jsonPGenericSender);
                    that._schedule_recv()
                };
                JsonPTransport.prototype = new BufferedSender;
                JsonPTransport.prototype._schedule_recv = function () {
                    var that = this;
                    var callback = function (data) {
                        that._recv_stop = null;
                        if (data) {
                            if (!that._is_closing) {
                                that.ri._didMessage(data)
                            }
                        }
                        if (!that._is_closing) {
                            that._schedule_recv()
                        }
                    };
                    that._recv_stop = jsonPReceiverWrapper(that.trans_url + "/jsonp", jsonPGenericReceiver, callback)
                };
                JsonPTransport.enabled = function () {
                    return true
                };
                JsonPTransport.need_body = true;
                JsonPTransport.prototype.doCleanup = function () {
                    var that = this;
                    that._is_closing = true;
                    if (that._recv_stop) {
                        that._recv_stop()
                    }
                    that.ri = that._recv_stop = null;
                    that.send_destructor()
                };
                var jsonPReceiverWrapper = function (url, constructReceiver, user_callback) {
                    var id = "a" + utils.random_string(6);
                    var url_id = url + "?c=" + escape(WPrefix + "." + id);
                    var aborting = 0;
                    var callback = function (frame) {
                        switch (aborting) {
                            case 0:
                                delete _window[WPrefix][id];
                                user_callback(frame);
                                break;
                            case 1:
                                user_callback(frame);
                                aborting = 2;
                                break;
                            case 2:
                                delete _window[WPrefix][id];
                                break
                        }
                    };
                    var close_script = constructReceiver(url_id, callback);
                    _window[WPrefix][id] = close_script;
                    var stop = function () {
                        if (_window[WPrefix][id]) {
                            aborting = 1;
                            _window[WPrefix][id](utils.closeFrame(1e3, "JSONP user aborted read"))
                        }
                    };
                    return stop
                };
                var AjaxBasedTransport = function () {
                };
                AjaxBasedTransport.prototype = new BufferedSender;
                AjaxBasedTransport.prototype.run = function (ri, trans_url, url_suffix, Receiver, AjaxObject) {
                    var that = this;
                    that.ri = ri;
                    that.trans_url = trans_url;
                    that.send_constructor(createAjaxSender(AjaxObject));
                    that.poll = new Polling(ri, Receiver, trans_url + url_suffix, AjaxObject)
                };
                AjaxBasedTransport.prototype.doCleanup = function () {
                    var that = this;
                    if (that.poll) {
                        that.poll.abort();
                        that.poll = null
                    }
                };
                var XhrStreamingTransport = SockJS["xhr-streaming"] = function (ri, trans_url) {
                    this.run(ri, trans_url, "/xhr_streaming", XhrReceiver, utils.XHRCorsObject)
                };
                XhrStreamingTransport.prototype = new AjaxBasedTransport;
                XhrStreamingTransport.enabled = function () {
                    return _window.XMLHttpRequest && "withCredentials"in new XMLHttpRequest && !/opera/i.test(navigator.userAgent)
                };
                XhrStreamingTransport.roundTrips = 2;
                XhrStreamingTransport.need_body = true;
                var XdrStreamingTransport = SockJS["xdr-streaming"] = function (ri, trans_url) {
                    this.run(ri, trans_url, "/xhr_streaming", XhrReceiver, utils.XDRObject)
                };
                XdrStreamingTransport.prototype = new AjaxBasedTransport;
                XdrStreamingTransport.enabled = function () {
                    return!!_window.XDomainRequest
                };
                XdrStreamingTransport.roundTrips = 2;
                var XhrPollingTransport = SockJS["xhr-polling"] = function (ri, trans_url) {
                    this.run(ri, trans_url, "/xhr", XhrReceiver, utils.XHRCorsObject)
                };
                XhrPollingTransport.prototype = new AjaxBasedTransport;
                XhrPollingTransport.enabled = XhrStreamingTransport.enabled;
                XhrPollingTransport.roundTrips = 2;
                var XdrPollingTransport = SockJS["xdr-polling"] = function (ri, trans_url) {
                    this.run(ri, trans_url, "/xhr", XhrReceiver, utils.XDRObject)
                };
                XdrPollingTransport.prototype = new AjaxBasedTransport;
                XdrPollingTransport.enabled = XdrStreamingTransport.enabled;
                XdrPollingTransport.roundTrips = 2;
                var IframeTransport = function () {
                };
                IframeTransport.prototype.i_constructor = function (ri, trans_url, base_url) {
                    var that = this;
                    that.ri = ri;
                    that.origin = utils.getOrigin(base_url);
                    that.base_url = base_url;
                    that.trans_url = trans_url;
                    var iframe_url = base_url + "/iframe.html";
                    if (that.ri._options.devel) {
                        iframe_url += "?t=" + +new Date
                    }
                    that.window_id = utils.random_string(8);
                    iframe_url += "#" + that.window_id;
                    that.iframeObj = utils.createIframe(iframe_url, function (r) {
                        that.ri._didClose(1006, "Unable to load an iframe (" + r + ")")
                    });
                    that.onmessage_cb = utils.bind(that.onmessage, that);
                    utils.attachMessage(that.onmessage_cb)
                };
                IframeTransport.prototype.doCleanup = function () {
                    var that = this;
                    if (that.iframeObj) {
                        utils.detachMessage(that.onmessage_cb);
                        try {
                            if (that.iframeObj.iframe.contentWindow) {
                                that.postMessage("c")
                            }
                        } catch (x) {
                        }
                        that.iframeObj.cleanup();
                        that.iframeObj = null;
                        that.onmessage_cb = that.iframeObj = null
                    }
                };
                IframeTransport.prototype.onmessage = function (e) {
                    var that = this;
                    if (e.origin !== that.origin)return;
                    var window_id = e.data.slice(0, 8);
                    var type = e.data.slice(8, 9);
                    var data = e.data.slice(9);
                    if (window_id !== that.window_id)return;
                    switch (type) {
                        case"s":
                            that.iframeObj.loaded();
                            that.postMessage("s", JSON.stringify([SockJS.version, that.protocol, that.trans_url, that.base_url]));
                            break;
                        case"t":
                            that.ri._didMessage(data);
                            break
                    }
                };
                IframeTransport.prototype.postMessage = function (type, data) {
                    var that = this;
                    that.iframeObj.post(that.window_id + type + (data || ""), that.origin)
                };
                IframeTransport.prototype.doSend = function (message) {
                    this.postMessage("m", message)
                };
                IframeTransport.enabled = function () {
                    var konqueror = navigator && navigator.userAgent && navigator.userAgent.indexOf("Konqueror") !== -1;
                    return(typeof _window.postMessage === "function" || typeof _window.postMessage === "object") && !konqueror
                };
                var curr_window_id;
                var postMessage = function (type, data) {
                    if (parent !== _window) {
                        parent.postMessage(curr_window_id + type + (data || ""), "*")
                    } else {
                        utils.log("Can't postMessage, no parent window.", type, data)
                    }
                };
                var FacadeJS = function () {
                };
                FacadeJS.prototype._didClose = function (code, reason) {
                    postMessage("t", utils.closeFrame(code, reason))
                };
                FacadeJS.prototype._didMessage = function (frame) {
                    postMessage("t", frame)
                };
                FacadeJS.prototype._doSend = function (data) {
                    this._transport.doSend(data)
                };
                FacadeJS.prototype._doCleanup = function () {
                    this._transport.doCleanup()
                };
                utils.parent_origin = undefined;
                SockJS.bootstrap_iframe = function () {
                    var facade;
                    curr_window_id = _document.location.hash.slice(1);
                    var onMessage = function (e) {
                        if (e.source !== parent)return;
                        if (typeof utils.parent_origin === "undefined")utils.parent_origin = e.origin;
                        if (e.origin !== utils.parent_origin)return;
                        var window_id = e.data.slice(0, 8);
                        var type = e.data.slice(8, 9);
                        var data = e.data.slice(9);
                        if (window_id !== curr_window_id)return;
                        switch (type) {
                            case"s":
                                var p = JSON.parse(data);
                                var version = p[0];
                                var protocol = p[1];
                                var trans_url = p[2];
                                var base_url = p[3];
                                if (version !== SockJS.version) {
                                    utils.log("Incompatibile SockJS! Main site uses:" + ' "' + version + '", the iframe:' + ' "' + SockJS.version + '".')
                                }
                                if (!utils.flatUrl(trans_url) || !utils.flatUrl(base_url)) {
                                    utils.log("Only basic urls are supported in SockJS");
                                    return
                                }
                                if (!utils.isSameOriginUrl(trans_url) || !utils.isSameOriginUrl(base_url)) {
                                    utils.log("Can't connect to different domain from within an " + "iframe. (" + JSON.stringify([_window.location.href, trans_url, base_url]) + ")");
                                    return
                                }
                                facade = new FacadeJS;
                                facade._transport = new FacadeJS[protocol](facade, trans_url, base_url);
                                break;
                            case"m":
                                facade._doSend(data);
                                break;
                            case"c":
                                if (facade)facade._doCleanup();
                                facade = null;
                                break
                        }
                    };
                    utils.attachMessage(onMessage);
                    postMessage("s")
                };
                var InfoReceiver = function (base_url, AjaxObject) {
                    var that = this;
                    utils.delay(function () {
                        that.doXhr(base_url, AjaxObject)
                    })
                };
                InfoReceiver.prototype = new EventEmitter(["finish"]);
                InfoReceiver.prototype.doXhr = function (base_url, AjaxObject) {
                    var that = this;
                    var t0 = (new Date).getTime();
                    var xo = new AjaxObject("GET", base_url + "/info");
                    var tref = utils.delay(8e3, function () {
                        xo.ontimeout()
                    });
                    xo.onfinish = function (status, text) {
                        clearTimeout(tref);
                        tref = null;
                        if (status === 200) {
                            var rtt = (new Date).getTime() - t0;
                            var info = JSON.parse(text);
                            if (typeof info !== "object")info = {};
                            that.emit("finish", info, rtt)
                        } else {
                            that.emit("finish")
                        }
                    };
                    xo.ontimeout = function () {
                        xo.close();
                        that.emit("finish")
                    }
                };
                var InfoReceiverIframe = function (base_url) {
                    var that = this;
                    var go = function () {
                        var ifr = new IframeTransport;
                        ifr.protocol = "w-iframe-info-receiver";
                        var fun = function (r) {
                            if (typeof r === "string" && r.substr(0, 1) === "m") {
                                var d = JSON.parse(r.substr(1));
                                var info = d[0], rtt = d[1];
                                that.emit("finish", info, rtt)
                            } else {
                                that.emit("finish")
                            }
                            ifr.doCleanup();
                            ifr = null
                        };
                        var mock_ri = {_options: {}, _didClose: fun, _didMessage: fun};
                        ifr.i_constructor(mock_ri, base_url, base_url)
                    };
                    if (!_document.body) {
                        utils.attachEvent("load", go)
                    } else {
                        go()
                    }
                };
                InfoReceiverIframe.prototype = new EventEmitter(["finish"]);
                var InfoReceiverFake = function () {
                    var that = this;
                    utils.delay(function () {
                        that.emit("finish", {}, 2e3)
                    })
                };
                InfoReceiverFake.prototype = new EventEmitter(["finish"]);
                var createInfoReceiver = function (base_url) {
                    if (utils.isSameOriginUrl(base_url)) {
                        return new InfoReceiver(base_url, utils.XHRLocalObject)
                    }
                    switch (utils.isXHRCorsCapable()) {
                        case 1:
                            return new InfoReceiver(base_url, utils.XHRLocalObject);
                        case 2:
                            return new InfoReceiver(base_url, utils.XDRObject);
                        case 3:
                            return new InfoReceiverIframe(base_url);
                        default:
                            return new InfoReceiverFake
                    }
                };
                var WInfoReceiverIframe = FacadeJS["w-iframe-info-receiver"] = function (ri, _trans_url, base_url) {
                    var ir = new InfoReceiver(base_url, utils.XHRLocalObject);
                    ir.onfinish = function (info, rtt) {
                        ri._didMessage("m" + JSON.stringify([info, rtt]));
                        ri._didClose()
                    }
                };
                WInfoReceiverIframe.prototype.doCleanup = function () {
                };
                var EventSourceIframeTransport = SockJS["iframe-eventsource"] = function () {
                    var that = this;
                    that.protocol = "w-iframe-eventsource";
                    that.i_constructor.apply(that, arguments)
                };
                EventSourceIframeTransport.prototype = new IframeTransport;
                EventSourceIframeTransport.enabled = function () {
                    return"EventSource"in _window && IframeTransport.enabled()
                };
                EventSourceIframeTransport.need_body = true;
                EventSourceIframeTransport.roundTrips = 3;
                var EventSourceTransport = FacadeJS["w-iframe-eventsource"] = function (ri, trans_url) {
                    this.run(ri, trans_url, "/eventsource", EventSourceReceiver, utils.XHRLocalObject)
                };
                EventSourceTransport.prototype = new AjaxBasedTransport;
                var XhrPollingIframeTransport = SockJS["iframe-xhr-polling"] = function () {
                    var that = this;
                    that.protocol = "w-iframe-xhr-polling";
                    that.i_constructor.apply(that, arguments)
                };
                XhrPollingIframeTransport.prototype = new IframeTransport;
                XhrPollingIframeTransport.enabled = function () {
                    return _window.XMLHttpRequest && IframeTransport.enabled()
                };
                XhrPollingIframeTransport.need_body = true;
                XhrPollingIframeTransport.roundTrips = 3;
                var XhrPollingITransport = FacadeJS["w-iframe-xhr-polling"] = function (ri, trans_url) {
                    this.run(ri, trans_url, "/xhr", XhrReceiver, utils.XHRLocalObject)
                };
                XhrPollingITransport.prototype = new AjaxBasedTransport;
                var HtmlFileIframeTransport = SockJS["iframe-htmlfile"] = function () {
                    var that = this;
                    that.protocol = "w-iframe-htmlfile";
                    that.i_constructor.apply(that, arguments)
                };
                HtmlFileIframeTransport.prototype = new IframeTransport;
                HtmlFileIframeTransport.enabled = function () {
                    return IframeTransport.enabled()
                };
                HtmlFileIframeTransport.need_body = true;
                HtmlFileIframeTransport.roundTrips = 3;
                var HtmlFileTransport = FacadeJS["w-iframe-htmlfile"] = function (ri, trans_url) {
                    this.run(ri, trans_url, "/htmlfile", HtmlfileReceiver, utils.XHRLocalObject)
                };
                HtmlFileTransport.prototype = new AjaxBasedTransport;
                var Polling = function (ri, Receiver, recv_url, AjaxObject) {
                    var that = this;
                    that.ri = ri;
                    that.Receiver = Receiver;
                    that.recv_url = recv_url;
                    that.AjaxObject = AjaxObject;
                    that._scheduleRecv()
                };
                Polling.prototype._scheduleRecv = function () {
                    var that = this;
                    var poll = that.poll = new that.Receiver(that.recv_url, that.AjaxObject);
                    var msg_counter = 0;
                    poll.onmessage = function (e) {
                        msg_counter += 1;
                        that.ri._didMessage(e.data)
                    };
                    poll.onclose = function (e) {
                        that.poll = poll = poll.onmessage = poll.onclose = null;
                        if (!that.poll_is_closing) {
                            if (e.reason === "permanent") {
                                that.ri._didClose(1006, "Polling error (" + e.reason + ")")
                            } else {
                                that._scheduleRecv()
                            }
                        }
                    }
                };
                Polling.prototype.abort = function () {
                    var that = this;
                    that.poll_is_closing = true;
                    if (that.poll) {
                        that.poll.abort()
                    }
                };
                var EventSourceReceiver = function (url) {
                    var that = this;
                    var es = new EventSource(url);
                    es.onmessage = function (e) {
                        that.dispatchEvent(new SimpleEvent("message", {data: unescape(e.data)}))
                    };
                    that.es_close = es.onerror = function (e, abort_reason) {
                        var reason = abort_reason ? "user" : es.readyState !== 2 ? "network" : "permanent";
                        that.es_close = es.onmessage = es.onerror = null;
                        es.close();
                        es = null;
                        utils.delay(200, function () {
                            that.dispatchEvent(new SimpleEvent("close", {reason: reason}))
                        })
                    }
                };
                EventSourceReceiver.prototype = new REventTarget;
                EventSourceReceiver.prototype.abort = function () {
                    var that = this;
                    if (that.es_close) {
                        that.es_close({}, true)
                    }
                };
                var _is_ie_htmlfile_capable;
                var isIeHtmlfileCapable = function () {
                    if (_is_ie_htmlfile_capable === undefined) {
                        if ("ActiveXObject"in _window) {
                            try {
                                _is_ie_htmlfile_capable = !!new ActiveXObject("htmlfile")
                            } catch (x) {
                            }
                        } else {
                            _is_ie_htmlfile_capable = false
                        }
                    }
                    return _is_ie_htmlfile_capable
                };
                var HtmlfileReceiver = function (url) {
                    var that = this;
                    utils.polluteGlobalNamespace();
                    that.id = "a" + utils.random_string(6, 26);
                    url += (url.indexOf("?") === -1 ? "?" : "&") + "c=" + escape(WPrefix + "." + that.id);
                    var constructor = isIeHtmlfileCapable() ? utils.createHtmlfile : utils.createIframe;
                    var iframeObj;
                    _window[WPrefix][that.id] = {start: function () {
                        iframeObj.loaded()
                    }, message: function (data) {
                        that.dispatchEvent(new SimpleEvent("message", {data: data}))
                    }, stop: function () {
                        that.iframe_close({}, "network")
                    }};
                    that.iframe_close = function (e, abort_reason) {
                        iframeObj.cleanup();
                        that.iframe_close = iframeObj = null;
                        delete _window[WPrefix][that.id];
                        that.dispatchEvent(new SimpleEvent("close", {reason: abort_reason}))
                    };
                    iframeObj = constructor(url, function (e) {
                        that.iframe_close({}, "permanent")
                    })
                };
                HtmlfileReceiver.prototype = new REventTarget;
                HtmlfileReceiver.prototype.abort = function () {
                    var that = this;
                    if (that.iframe_close) {
                        that.iframe_close({}, "user")
                    }
                };
                var XhrReceiver = function (url, AjaxObject) {
                    var that = this;
                    var buf_pos = 0;
                    that.xo = new AjaxObject("POST", url, null);
                    that.xo.onchunk = function (status, text) {
                        if (status !== 200)return;
                        while (1) {
                            var buf = text.slice(buf_pos);
                            var p = buf.indexOf("\n");
                            if (p === -1)break;
                            buf_pos += p + 1;
                            var msg = buf.slice(0, p);
                            that.dispatchEvent(new SimpleEvent("message", {data: msg}))
                        }
                    };
                    that.xo.onfinish = function (status, text) {
                        that.xo.onchunk(status, text);
                        that.xo = null;
                        var reason = status === 200 ? "network" : "permanent";
                        that.dispatchEvent(new SimpleEvent("close", {reason: reason}))
                    }
                };
                XhrReceiver.prototype = new REventTarget;
                XhrReceiver.prototype.abort = function () {
                    var that = this;
                    if (that.xo) {
                        that.xo.close();
                        that.dispatchEvent(new SimpleEvent("close", {reason: "user"}));
                        that.xo = null
                    }
                };
                SockJS.getUtils = function () {
                    return utils
                };
                SockJS.getIframeTransport = function () {
                    return IframeTransport
                };
                return SockJS
            }();
            if ("_sockjs_onload"in window)setTimeout(_sockjs_onload, 1);
            if (typeof define === "function" && define.amd) {
                define("sockjs", [], function () {
                    return SockJS
                })
            }
            browserify_shim__define__module__export__(typeof SockJS != "undefined" ? SockJS : window.SockJS)
        }).call(global, undefined, undefined, undefined, undefined, function defineExport(ex) {
                module.exports = ex
            })
    }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
}, {}], 236: [function (require, module, exports) {
    var events = require("events");
    var inherits = require("inherits");

    function Store() {
        this.data = {};
        events.EventEmitter.call(this);
        Object.defineProperty(this, "length", {get: length.bind(this)})
    }

    inherits(Store, events.EventEmitter);
    function keys() {
        return Object.keys(this.data)
    }

    Store.prototype.keys = keys;
    function length() {
        return this.keys().length
    }

    Store.prototype.lengthFunc = length;
    function get(key) {
        return this.data[key] || undefined
    }

    Store.prototype.get = get;
    function set(key, value) {
        this.data[key] = value;
        this.emit("set", key, value)
    }

    Store.prototype.set = set;
    function add(key, value) {
        if ("undefined" !== typeof this.get(key)) {
            return false
        }
        this.set(key, value);
        return true
    }

    Store.prototype.add = add;
    function deleteItem(key) {
        delete this.data[key];
        this.emit("delete", key)
    }

    Store.prototype.delete = deleteItem;
    function pipe(store) {
        this.on("set", function (key, value) {
            store.set(key, value)
        });
        this.on("delete", function (key) {
            store.delete(key)
        })
    }

    Store.prototype.pipe = pipe;
    function fillOnceFrom(store, filter) {
        var did = 0;
        store.keys().forEach(function (key) {
            var value = store.get(key);
            if (filter) {
                value = filter(value);
                if ("undefined" === typeof value) {
                    store.delete(key);
                    return
                }
            }
            did++;
            this.set(key, value)
        }, this);
        return did
    }

    Store.prototype.fillOnceFrom = fillOnceFrom;
    module.exports = Store
}, {events: 44, inherits: 52}], 237: [function (require, module, exports) {
    (function (win) {
        var store = {}, doc = win.document, localStorageName = "localStorage", scriptTag = "script", storage;
        store.disabled = false;
        store.set = function (key, value) {
        };
        store.get = function (key) {
        };
        store.remove = function (key) {
        };
        store.clear = function () {
        };
        store.transact = function (key, defaultVal, transactionFn) {
            var val = store.get(key);
            if (transactionFn == null) {
                transactionFn = defaultVal;
                defaultVal = null
            }
            if (typeof val == "undefined") {
                val = defaultVal || {}
            }
            transactionFn(val);
            store.set(key, val)
        };
        store.getAll = function () {
        };
        store.forEach = function () {
        };
        store.serialize = function (value) {
            return JSON.stringify(value)
        };
        store.deserialize = function (value) {
            if (typeof value != "string") {
                return undefined
            }
            try {
                return JSON.parse(value)
            } catch (e) {
                return value || undefined
            }
        };
        function isLocalStorageNameSupported() {
            try {
                return localStorageName in win && win[localStorageName]
            } catch (err) {
                return false
            }
        }

        if (isLocalStorageNameSupported()) {
            storage = win[localStorageName];
            store.set = function (key, val) {
                if (val === undefined) {
                    return store.remove(key)
                }
                storage.setItem(key, store.serialize(val));
                return val
            };
            store.get = function (key) {
                return store.deserialize(storage.getItem(key))
            };
            store.remove = function (key) {
                storage.removeItem(key)
            };
            store.clear = function () {
                storage.clear()
            };
            store.getAll = function () {
                var ret = {};
                store.forEach(function (key, val) {
                    ret[key] = val
                });
                return ret
            };
            store.forEach = function (callback) {
                for (var i = 0; i < storage.length; i++) {
                    var key = storage.key(i);
                    callback(key, store.get(key))
                }
            }
        } else if (doc.documentElement.addBehavior) {
            var storageOwner, storageContainer;
            try {
                storageContainer = new ActiveXObject("htmlfile");
                storageContainer.open();
                storageContainer.write("<" + scriptTag + ">document.w=window</" + scriptTag + '><iframe src="/favicon.ico"></iframe>');
                storageContainer.close();
                storageOwner = storageContainer.w.frames[0].document;
                storage = storageOwner.createElement("div")
            } catch (e) {
                storage = doc.createElement("div");
                storageOwner = doc.body
            }
            function withIEStorage(storeFunction) {
                return function () {
                    var args = Array.prototype.slice.call(arguments, 0);
                    args.unshift(storage);
                    storageOwner.appendChild(storage);
                    storage.addBehavior("#default#userData");
                    storage.load(localStorageName);
                    var result = storeFunction.apply(store, args);
                    storageOwner.removeChild(storage);
                    return result
                }
            }

            var forbiddenCharsRegex = new RegExp("[!\"#$%&'()*+,/\\\\:;<=>?@[\\]^`{|}~]", "g");

            function ieKeyFix(key) {
                return key.replace(/^d/, "___$&").replace(forbiddenCharsRegex, "___")
            }

            store.set = withIEStorage(function (storage, key, val) {
                key = ieKeyFix(key);
                if (val === undefined) {
                    return store.remove(key)
                }
                storage.setAttribute(key, store.serialize(val));
                storage.save(localStorageName);
                return val
            });
            store.get = withIEStorage(function (storage, key) {
                key = ieKeyFix(key);
                return store.deserialize(storage.getAttribute(key))
            });
            store.remove = withIEStorage(function (storage, key) {
                key = ieKeyFix(key);
                storage.removeAttribute(key);
                storage.save(localStorageName)
            });
            store.clear = withIEStorage(function (storage) {
                var attributes = storage.XMLDocument.documentElement.attributes;
                storage.load(localStorageName);
                for (var i = 0, attr; attr = attributes[i]; i++) {
                    storage.removeAttribute(attr.name)
                }
                storage.save(localStorageName)
            });
            store.getAll = function (storage) {
                var ret = {};
                store.forEach(function (key, val) {
                    ret[key] = val
                });
                return ret
            };
            store.forEach = withIEStorage(function (storage, callback) {
                var attributes = storage.XMLDocument.documentElement.attributes;
                for (var i = 0, attr; attr = attributes[i]; ++i) {
                    callback(attr.name, store.deserialize(storage.getAttribute(attr.name)))
                }
            })
        }
        try {
            var testKey = "__storejs__";
            store.set(testKey, testKey);
            if (store.get(testKey) != testKey) {
                store.disabled = true
            }
            store.remove(testKey)
        } catch (e) {
            store.disabled = true
        }
        store.enabled = !store.disabled;
        if (typeof module != "undefined" && module.exports && this.module !== module) {
            module.exports = store
        } else if (typeof define === "function" && define.amd) {
            define(store)
        } else {
            win.store = store
        }
    })(Function("return this")())
}, {}], 238: [function (require, module, exports) {
    var Emitter = require("emitter");
    var reduce = require("reduce");
    var root = "undefined" == typeof window ? this : window;

    function noop() {
    }

    function isHost(obj) {
        var str = {}.toString.call(obj);
        switch (str) {
            case"[object File]":
            case"[object Blob]":
            case"[object FormData]":
                return true;
            default:
                return false
        }
    }

    function getXHR() {
        if (root.XMLHttpRequest && ("file:" != root.location.protocol || !root.ActiveXObject)) {
            return new XMLHttpRequest
        } else {
            try {
                return new ActiveXObject("Microsoft.XMLHTTP")
            } catch (e) {
            }
            try {
                return new ActiveXObject("Msxml2.XMLHTTP.6.0")
            } catch (e) {
            }
            try {
                return new ActiveXObject("Msxml2.XMLHTTP.3.0")
            } catch (e) {
            }
            try {
                return new ActiveXObject("Msxml2.XMLHTTP")
            } catch (e) {
            }
        }
        return false
    }

    var trim = "".trim ? function (s) {
        return s.trim()
    } : function (s) {
        return s.replace(/(^\s*|\s*$)/g, "")
    };

    function isObject(obj) {
        return obj === Object(obj)
    }

    function serialize(obj) {
        if (!isObject(obj))return obj;
        var pairs = [];
        for (var key in obj) {
            if (null != obj[key]) {
                pairs.push(encodeURIComponent(key) + "=" + encodeURIComponent(obj[key]))
            }
        }
        return pairs.join("&")
    }

    request.serializeObject = serialize;
    function parseString(str) {
        var obj = {};
        var pairs = str.split("&");
        var parts;
        var pair;
        for (var i = 0, len = pairs.length; i < len; ++i) {
            pair = pairs[i];
            parts = pair.split("=");
            obj[decodeURIComponent(parts[0])] = decodeURIComponent(parts[1])
        }
        return obj
    }

    request.parseString = parseString;
    request.types = {html: "text/html", json: "application/json", xml: "application/xml", urlencoded: "application/x-www-form-urlencoded", form: "application/x-www-form-urlencoded", "form-data": "application/x-www-form-urlencoded"};
    request.serialize = {"application/x-www-form-urlencoded": serialize, "application/json": JSON.stringify};
    request.parse = {"application/x-www-form-urlencoded": parseString, "application/json": JSON.parse};
    function parseHeader(str) {
        var lines = str.split(/\r?\n/);
        var fields = {};
        var index;
        var line;
        var field;
        var val;
        lines.pop();
        for (var i = 0, len = lines.length; i < len; ++i) {
            line = lines[i];
            index = line.indexOf(":");
            field = line.slice(0, index).toLowerCase();
            val = trim(line.slice(index + 1));
            fields[field] = val
        }
        return fields
    }

    function type(str) {
        return str.split(/ *; */).shift()
    }

    function params(str) {
        return reduce(str.split(/ *; */), function (obj, str) {
            var parts = str.split(/ *= */), key = parts.shift(), val = parts.shift();
            if (key && val)obj[key] = val;
            return obj
        }, {})
    }

    function Response(req, options) {
        options = options || {};
        this.req = req;
        this.xhr = this.req.xhr;
        this.text = this.xhr.responseText;
        this.setStatusProperties(this.xhr.status);
        this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());
        this.header["content-type"] = this.xhr.getResponseHeader("content-type");
        this.setHeaderProperties(this.header);
        this.body = this.req.method != "HEAD" ? this.parseBody(this.text) : null
    }

    Response.prototype.get = function (field) {
        return this.header[field.toLowerCase()]
    };
    Response.prototype.setHeaderProperties = function (header) {
        var ct = this.header["content-type"] || "";
        this.type = type(ct);
        var obj = params(ct);
        for (var key in obj)this[key] = obj[key]
    };
    Response.prototype.parseBody = function (str) {
        var parse = request.parse[this.type];
        return parse ? parse(str) : null
    };
    Response.prototype.setStatusProperties = function (status) {
        var type = status / 100 | 0;
        this.status = status;
        this.statusType = type;
        this.info = 1 == type;
        this.ok = 2 == type;
        this.clientError = 4 == type;
        this.serverError = 5 == type;
        this.error = 4 == type || 5 == type ? this.toError() : false;
        this.accepted = 202 == status;
        this.noContent = 204 == status || 1223 == status;
        this.badRequest = 400 == status;
        this.unauthorized = 401 == status;
        this.notAcceptable = 406 == status;
        this.notFound = 404 == status;
        this.forbidden = 403 == status
    };
    Response.prototype.toError = function () {
        var req = this.req;
        var method = req.method;
        var url = req.url;
        var msg = "cannot " + method + " " + url + " (" + this.status + ")";
        var err = new Error(msg);
        err.status = this.status;
        err.method = method;
        err.url = url;
        return err
    };
    request.Response = Response;
    function Request(method, url) {
        var self = this;
        Emitter.call(this);
        this._query = this._query || [];
        this.method = method;
        this.url = url;
        this.header = {};
        this._header = {};
        this.on("end", function () {
            var res = new Response(self);
            if ("HEAD" == method)res.text = null;
            self.callback(null, res)
        })
    }

    Emitter(Request.prototype);
    Request.prototype.use = function (fn) {
        fn(this);
        return this
    };
    Request.prototype.timeout = function (ms) {
        this._timeout = ms;
        return this
    };
    Request.prototype.clearTimeout = function () {
        this._timeout = 0;
        clearTimeout(this._timer);
        return this
    };
    Request.prototype.abort = function () {
        if (this.aborted)return;
        this.aborted = true;
        this.xhr.abort();
        this.clearTimeout();
        this.emit("abort");
        return this
    };
    Request.prototype.set = function (field, val) {
        if (isObject(field)) {
            for (var key in field) {
                this.set(key, field[key])
            }
            return this
        }
        this._header[field.toLowerCase()] = val;
        this.header[field] = val;
        return this
    };
    Request.prototype.getHeader = function (field) {
        return this._header[field.toLowerCase()]
    };
    Request.prototype.type = function (type) {
        this.set("Content-Type", request.types[type] || type);
        return this
    };
    Request.prototype.accept = function (type) {
        this.set("Accept", request.types[type] || type);
        return this
    };
    Request.prototype.auth = function (user, pass) {
        var str = btoa(user + ":" + pass);
        this.set("Authorization", "Basic " + str);
        return this
    };
    Request.prototype.query = function (val) {
        if ("string" != typeof val)val = serialize(val);
        if (val)this._query.push(val);
        return this
    };
    Request.prototype.field = function (name, val) {
        if (!this._formData)this._formData = new FormData;
        this._formData.append(name, val);
        return this
    };
    Request.prototype.attach = function (field, file, filename) {
        if (!this._formData)this._formData = new FormData;
        this._formData.append(field, file, filename);
        return this
    };
    Request.prototype.send = function (data) {
        var obj = isObject(data);
        var type = this.getHeader("Content-Type");
        if (obj && isObject(this._data)) {
            for (var key in data) {
                this._data[key] = data[key]
            }
        } else if ("string" == typeof data) {
            if (!type)this.type("form");
            type = this.getHeader("Content-Type");
            if ("application/x-www-form-urlencoded" == type) {
                this._data = this._data ? this._data + "&" + data : data
            } else {
                this._data = (this._data || "") + data
            }
        } else {
            this._data = data
        }
        if (!obj)return this;
        if (!type)this.type("json");
        return this
    };
    Request.prototype.callback = function (err, res) {
        var fn = this._callback;
        if (2 == fn.length)return fn(err, res);
        if (err)return this.emit("error", err);
        fn(res)
    };
    Request.prototype.crossDomainError = function () {
        var err = new Error("Origin is not allowed by Access-Control-Allow-Origin");
        err.crossDomain = true;
        this.callback(err)
    };
    Request.prototype.timeoutError = function () {
        var timeout = this._timeout;
        var err = new Error("timeout of " + timeout + "ms exceeded");
        err.timeout = timeout;
        this.callback(err)
    };
    Request.prototype.withCredentials = function () {
        this._withCredentials = true;
        return this
    };
    Request.prototype.end = function (fn) {
        var self = this;
        var xhr = this.xhr = getXHR();
        var query = this._query.join("&");
        var timeout = this._timeout;
        var data = this._formData || this._data;
        this._callback = fn || noop;
        xhr.onreadystatechange = function () {
            if (4 != xhr.readyState)return;
            if (0 == xhr.status) {
                if (self.aborted)return self.timeoutError();
                return self.crossDomainError()
            }
            self.emit("end")
        };
        if (xhr.upload) {
            xhr.upload.onprogress = function (e) {
                e.percent = e.loaded / e.total * 100;
                self.emit("progress", e)
            }
        }
        if (timeout && !this._timer) {
            this._timer = setTimeout(function () {
                self.abort()
            }, timeout)
        }
        if (query) {
            query = request.serializeObject(query);
            this.url += ~this.url.indexOf("?") ? "&" + query : "?" + query
        }
        xhr.open(this.method, this.url, true);
        if (this._withCredentials)xhr.withCredentials = true;
        if ("GET" != this.method && "HEAD" != this.method && "string" != typeof data && !isHost(data)) {
            var serialize = request.serialize[this.getHeader("Content-Type")];
            if (serialize)data = serialize(data)
        }
        for (var field in this.header) {
            if (null == this.header[field])continue;
            xhr.setRequestHeader(field, this.header[field])
        }
        this.emit("request", this);
        xhr.send(data);
        return this
    };
    request.Request = Request;
    function request(method, url) {
        if ("function" == typeof url) {
            return new Request("GET", method).end(url)
        }
        if (1 == arguments.length) {
            return new Request("GET", method)
        }
        return new Request(method, url)
    }

    request.get = function (url, data, fn) {
        var req = request("GET", url);
        if ("function" == typeof data)fn = data, data = null;
        if (data)req.query(data);
        if (fn)req.end(fn);
        return req
    };
    request.head = function (url, data, fn) {
        var req = request("HEAD", url);
        if ("function" == typeof data)fn = data, data = null;
        if (data)req.send(data);
        if (fn)req.end(fn);
        return req
    };
    request.del = function (url, fn) {
        var req = request("DELETE", url);
        if (fn)req.end(fn);
        return req
    };
    request.patch = function (url, data, fn) {
        var req = request("PATCH", url);
        if ("function" == typeof data)fn = data, data = null;
        if (data)req.send(data);
        if (fn)req.end(fn);
        return req
    };
    request.post = function (url, data, fn) {
        var req = request("POST", url);
        if ("function" == typeof data)fn = data, data = null;
        if (data)req.send(data);
        if (fn)req.end(fn);
        return req
    };
    request.put = function (url, data, fn) {
        var req = request("PUT", url);
        if ("function" == typeof data)fn = data, data = null;
        if (data)req.send(data);
        if (fn)req.end(fn);
        return req
    };
    module.exports = request
}, {emitter: 239, reduce: 240}], 239: [function (require, module, exports) {
    module.exports = Emitter;
    function Emitter(obj) {
        if (obj)return mixin(obj)
    }

    function mixin(obj) {
        for (var key in Emitter.prototype) {
            obj[key] = Emitter.prototype[key]
        }
        return obj
    }

    Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {
        this._callbacks = this._callbacks || {};
        (this._callbacks[event] = this._callbacks[event] || []).push(fn);
        return this
    };
    Emitter.prototype.once = function (event, fn) {
        var self = this;
        this._callbacks = this._callbacks || {};
        function on() {
            self.off(event, on);
            fn.apply(this, arguments)
        }

        on.fn = fn;
        this.on(event, on);
        return this
    };
    Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {
        this._callbacks = this._callbacks || {};
        if (0 == arguments.length) {
            this._callbacks = {};
            return this
        }
        var callbacks = this._callbacks[event];
        if (!callbacks)return this;
        if (1 == arguments.length) {
            delete this._callbacks[event];
            return this
        }
        var cb;
        for (var i = 0; i < callbacks.length; i++) {
            cb = callbacks[i];
            if (cb === fn || cb.fn === fn) {
                callbacks.splice(i, 1);
                break
            }
        }
        return this
    };
    Emitter.prototype.emit = function (event) {
        this._callbacks = this._callbacks || {};
        var args = [].slice.call(arguments, 1), callbacks = this._callbacks[event];
        if (callbacks) {
            callbacks = callbacks.slice(0);
            for (var i = 0, len = callbacks.length; i < len; ++i) {
                callbacks[i].apply(this, args)
            }
        }
        return this
    };
    Emitter.prototype.listeners = function (event) {
        this._callbacks = this._callbacks || {};
        return this._callbacks[event] || []
    };
    Emitter.prototype.hasListeners = function (event) {
        return!!this.listeners(event).length
    }
}, {}], 240: [function (require, module, exports) {
    module.exports = require(221)
}, {}], 241: [function (require, module, exports) {
    var uid = require("uid");
    var event = require("component-event");
    var Promise = require("promise");
    var debug = require("debug")("wpcom-proxy-request");
    module.exports = Promise.nodeify(request);
    var proxyOrigin = "https://public-api.wordpress.com";
    var origin = window.location.protocol + "//" + window.location.host;
    debug('using "origin": %o', origin);
    var iframe;
    var loaded = false;
    var buffered;
    var hasFileSerializationBug = false;
    var requests = {};

    function request(params) {
        debug("request()", params);
        if ("string" == typeof params) {
            params = {path: params}
        }
        if (!iframe)install();
        var id = uid();
        params.callback = id;
        params.supports_args = true;
        params.method = String(params.method || "GET").toUpperCase();
        debug("params object: %o", params);
        var req = new Promise(function (resolve, reject) {
            if (loaded) {
                submitRequest(params, resolve, reject)
            } else {
                debug("buffering API request since proxying <iframe> is not yet loaded");
                buffered.push([params, resolve, reject])
            }
        });
        requests[id] = params;
        return req
    }

    function submitRequest(params, resolve, reject) {
        debug("sending API request to proxy <iframe> %o", params);
        if (hasFileSerializationBug && hasFile(params)) {
            postAsArrayBuffer(params, resolve, reject)
        } else {
            try {
                iframe.contentWindow.postMessage(params, proxyOrigin);
                params.resolve = resolve;
                params.reject = reject
            } catch (e) {
                if (hasFile(params)) {
                    hasFileSerializationBug = true;
                    debug("this browser has the File serialization bug");
                    postAsArrayBuffer(params, resolve, reject)
                } else {
                    throw e
                }
            }
        }
    }

    function hasFile(params) {
        var formData = params.formData;
        if (formData && formData.length > 0) {
            for (var i = 0; i < formData.length; i++) {
                if (isFile(formData[i][1]))return true
            }
        }
        return false
    }

    function isFile(v) {
        return v && Object.prototype.toString.call(v) === "[object File]"
    }

    function postAsArrayBuffer(params, resolve, reject) {
        debug("converting File instances to ArrayBuffer before invoking postMessage()");
        var count = 0;
        var called = false;
        var formData = params.formData;
        for (var i = 0; i < formData.length; i++) {
            var val = formData[i][1];
            if (isFile(val)) {
                count++;
                fileToArrayBuffer(val, i, onload)
            }
        }
        if (0 === count)postMessage();
        function onload(err, file, i) {
            if (called)return;
            if (err) {
                called = true;
                reject(err);
                return
            }
            formData[i][1] = file;
            count--;
            if (0 === count)postMessage()
        }

        function postMessage() {
            debug("finished reading all Files");
            iframe.contentWindow.postMessage(params, proxyOrigin);
            params.resolve = resolve;
            params.reject = reject
        }
    }

    function fileToArrayBuffer(file, index, fn) {
        var reader = new FileReader;
        reader.onload = function (e) {
            var arrayBuffer = e.target.result;
            debug("finished reading file %o (%o bytes)", file.name, arrayBuffer.byteLength);
            fn(null, {fileContents: arrayBuffer, fileName: file.name, mimeType: file.type}, index)
        };
        reader.onerror = function (err) {
            debug("got error reading file %o (%o bytes)", file.name, err);
            fn(err)
        };
        reader.readAsArrayBuffer(file)
    }

    function install() {
        debug("install()");
        if (iframe)uninstall();
        buffered = [];
        event.bind(window, "message", onmessage);
        iframe = document.createElement("iframe");
        event.bind(iframe, "load", onload);
        iframe.src = proxyOrigin + "/wp-admin/rest-proxy/#" + origin;
        iframe.style.display = "none";
        document.body.appendChild(iframe)
    }

    function onload(e) {
        debug('proxy <iframe> "load" event');
        loaded = true;
        for (var i = 0; i < buffered.length; i++) {
            submitRequest.apply(null, buffered[i])
        }
        buffered = null
    }

    function onmessage(e) {
        debug("onmessage");
        if (e.origin !== proxyOrigin) {
            debug("ignoring message... %o !== %o", e.origin, proxyOrigin);
            return
        }
        var data = e.data;
        if (!data || !data.length) {
            debug("`e.data` doesn't appear to be an Array, bailing...");
            return
        }
        var id = data[data.length - 1];
        var params = requests[id];
        delete requests[id];
        var body = data[0];
        var statusCode = data[1];
        var headers = data[2];
        if (!params.metaAPI) {
            debug("got %o status code for URL: %o", statusCode, params.path)
        }
        if (body && headers) {
            body._headers = headers
        }
        if (null == statusCode || 2 === Math.floor(statusCode / 100)) {
            params.resolve(body)
        } else {
            var err = new Error;
            err.statusCode = statusCode;
            for (var i in body)err[i] = body[i];
            if (body.error)err.name = toTitle(body.error) + "Error";
            params.reject(err)
        }
    }

    function toTitle(str) {
        if (!str || "string" !== typeof str)return"";
        return str.replace(/((^|_)[a-z])/g, function ($1) {
            return $1.toUpperCase().replace("_", "")
        })
    }
}, {"component-event": 242, debug: 48, promise: 244, uid: 246}], 242: [function (require, module, exports) {
    var bind = window.addEventListener ? "addEventListener" : "attachEvent", unbind = window.removeEventListener ? "removeEventListener" : "detachEvent", prefix = bind !== "addEventListener" ? "on" : "";
    exports.bind = function (el, type, fn, capture) {
        el[bind](prefix + type, fn, capture || false);
        return fn
    };
    exports.unbind = function (el, type, fn, capture) {
        el[unbind](prefix + type, fn, capture || false);
        return fn
    }
}, {}], 243: [function (require, module, exports) {
    "use strict";
    var asap = require("asap");
    module.exports = Promise;
    function Promise(fn) {
        if (typeof this !== "object")throw new TypeError("Promises must be constructed via new");
        if (typeof fn !== "function")throw new TypeError("not a function");
        var state = null;
        var value = null;
        var deferreds = [];
        var self = this;
        this.then = function (onFulfilled, onRejected) {
            return new Promise(function (resolve, reject) {
                handle(new Handler(onFulfilled, onRejected, resolve, reject))
            })
        };
        function handle(deferred) {
            if (state === null) {
                deferreds.push(deferred);
                return
            }
            asap(function () {
                var cb = state ? deferred.onFulfilled : deferred.onRejected;
                if (cb === null) {
                    (state ? deferred.resolve : deferred.reject)(value);
                    return
                }
                var ret;
                try {
                    ret = cb(value)
                } catch (e) {
                    deferred.reject(e);
                    return
                }
                deferred.resolve(ret)
            })
        }

        function resolve(newValue) {
            try {
                if (newValue === self)throw new TypeError("A promise cannot be resolved with itself.");
                if (newValue && (typeof newValue === "object" || typeof newValue === "function")) {
                    var then = newValue.then;
                    if (typeof then === "function") {
                        doResolve(then.bind(newValue), resolve, reject);
                        return
                    }
                }
                state = true;
                value = newValue;
                finale()
            } catch (e) {
                reject(e)
            }
        }

        function reject(newValue) {
            state = false;
            value = newValue;
            finale()
        }

        function finale() {
            for (var i = 0, len = deferreds.length; i < len; i++)handle(deferreds[i]);
            deferreds = null
        }

        doResolve(fn, resolve, reject)
    }

    function Handler(onFulfilled, onRejected, resolve, reject) {
        this.onFulfilled = typeof onFulfilled === "function" ? onFulfilled : null;
        this.onRejected = typeof onRejected === "function" ? onRejected : null;
        this.resolve = resolve;
        this.reject = reject
    }

    function doResolve(fn, onFulfilled, onRejected) {
        var done = false;
        try {
            fn(function (value) {
                if (done)return;
                done = true;
                onFulfilled(value)
            }, function (reason) {
                if (done)return;
                done = true;
                onRejected(reason)
            })
        } catch (ex) {
            if (done)return;
            done = true;
            onRejected(ex)
        }
    }
}, {asap: 245}], 244: [function (require, module, exports) {
    "use strict";
    var Promise = require("./core.js");
    var asap = require("asap");
    module.exports = Promise;
    function ValuePromise(value) {
        this.then = function (onFulfilled) {
            if (typeof onFulfilled !== "function")return this;
            return new Promise(function (resolve, reject) {
                asap(function () {
                    try {
                        resolve(onFulfilled(value))
                    } catch (ex) {
                        reject(ex)
                    }
                })
            })
        }
    }

    ValuePromise.prototype = Object.create(Promise.prototype);
    var TRUE = new ValuePromise(true);
    var FALSE = new ValuePromise(false);
    var NULL = new ValuePromise(null);
    var UNDEFINED = new ValuePromise(undefined);
    var ZERO = new ValuePromise(0);
    var EMPTYSTRING = new ValuePromise("");
    Promise.resolve = function (value) {
        if (value instanceof Promise)return value;
        if (value === null)return NULL;
        if (value === undefined)return UNDEFINED;
        if (value === true)return TRUE;
        if (value === false)return FALSE;
        if (value === 0)return ZERO;
        if (value === "")return EMPTYSTRING;
        if (typeof value === "object" || typeof value === "function") {
            try {
                var then = value.then;
                if (typeof then === "function") {
                    return new Promise(then.bind(value))
                }
            } catch (ex) {
                return new Promise(function (resolve, reject) {
                    reject(ex)
                })
            }
        }
        return new ValuePromise(value)
    };
    Promise.from = Promise.cast = function (value) {
        var err = new Error("Promise.from and Promise.cast are deprecated, use Promise.resolve instead");
        err.name = "Warning";
        console.warn(err.stack);
        return Promise.resolve(value)
    };
    Promise.denodeify = function (fn, argumentCount) {
        argumentCount = argumentCount || Infinity;
        return function () {
            var self = this;
            var args = Array.prototype.slice.call(arguments);
            return new Promise(function (resolve, reject) {
                while (args.length && args.length > argumentCount) {
                    args.pop()
                }
                args.push(function (err, res) {
                    if (err)reject(err); else resolve(res)
                });
                fn.apply(self, args)
            })
        }
    };
    Promise.nodeify = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            var callback = typeof args[args.length - 1] === "function" ? args.pop() : null;
            try {
                return fn.apply(this, arguments).nodeify(callback)
            } catch (ex) {
                if (callback === null || typeof callback == "undefined") {
                    return new Promise(function (resolve, reject) {
                        reject(ex)
                    })
                } else {
                    asap(function () {
                        callback(ex)
                    })
                }
            }
        }
    };
    Promise.all = function () {
        var calledWithArray = arguments.length === 1 && Array.isArray(arguments[0]);
        var args = Array.prototype.slice.call(calledWithArray ? arguments[0] : arguments);
        if (!calledWithArray) {
            var err = new Error("Promise.all should be called with a single array, calling it with multiple arguments is deprecated");
            err.name = "Warning";
            console.warn(err.stack)
        }
        return new Promise(function (resolve, reject) {
            if (args.length === 0)return resolve([]);
            var remaining = args.length;

            function res(i, val) {
                try {
                    if (val && (typeof val === "object" || typeof val === "function")) {
                        var then = val.then;
                        if (typeof then === "function") {
                            then.call(val, function (val) {
                                res(i, val)
                            }, reject);
                            return
                        }
                    }
                    args[i] = val;
                    if (--remaining === 0) {
                        resolve(args)
                    }
                } catch (ex) {
                    reject(ex)
                }
            }

            for (var i = 0; i < args.length; i++) {
                res(i, args[i])
            }
        })
    };
    Promise.reject = function (value) {
        return new Promise(function (resolve, reject) {
            reject(value)
        })
    };
    Promise.race = function (values) {
        return new Promise(function (resolve, reject) {
            values.forEach(function (value) {
                Promise.resolve(value).then(resolve, reject)
            })
        })
    };
    Promise.prototype.done = function (onFulfilled, onRejected) {
        var self = arguments.length ? this.then.apply(this, arguments) : this;
        self.then(null, function (err) {
            asap(function () {
                throw err
            })
        })
    };
    Promise.prototype.nodeify = function (callback) {
        if (typeof callback != "function")return this;
        this.then(function (value) {
            asap(function () {
                callback(null, value)
            })
        }, function (err) {
            asap(function () {
                callback(err)
            })
        })
    };
    Promise.prototype["catch"] = function (onRejected) {
        return this.then(null, onRejected)
    }
}, {"./core.js": 243, asap: 245}], 245: [function (require, module, exports) {
    (function (process) {
        var head = {task: void 0, next: null};
        var tail = head;
        var flushing = false;
        var requestFlush = void 0;
        var isNodeJS = false;

        function flush() {
            while (head.next) {
                head = head.next;
                var task = head.task;
                head.task = void 0;
                var domain = head.domain;
                if (domain) {
                    head.domain = void 0;
                    domain.enter()
                }
                try {
                    task()
                } catch (e) {
                    if (isNodeJS) {
                        if (domain) {
                            domain.exit()
                        }
                        setTimeout(flush, 0);
                        if (domain) {
                            domain.enter()
                        }
                        throw e
                    } else {
                        setTimeout(function () {
                            throw e
                        }, 0)
                    }
                }
                if (domain) {
                    domain.exit()
                }
            }
            flushing = false
        }

        if (typeof process !== "undefined" && process.nextTick) {
            isNodeJS = true;
            requestFlush = function () {
                process.nextTick(flush)
            }
        } else if (typeof setImmediate === "function") {
            if (typeof window !== "undefined") {
                requestFlush = setImmediate.bind(window, flush)
            } else {
                requestFlush = function () {
                    setImmediate(flush)
                }
            }
        } else if (typeof MessageChannel !== "undefined") {
            var channel = new MessageChannel;
            channel.port1.onmessage = flush;
            requestFlush = function () {
                channel.port2.postMessage(0)
            }
        } else {
            requestFlush = function () {
                setTimeout(flush, 0)
            }
        }
        function asap(task) {
            tail = tail.next = {task: task, domain: isNodeJS && process.domain, next: null};
            if (!flushing) {
                flushing = true;
                requestFlush()
            }
        }

        module.exports = asap
    }).call(this, require("FWaASH"))
}, {FWaASH: 46}], 246: [function (require, module, exports) {
    module.exports = uid;
    function uid(len) {
        len = len || 7;
        return Math.random().toString(35).substr(2, len)
    }
}, {}], 247: [function (require, module, exports) {
    var Me = require("./lib/me");
    var Site = require("./lib/site");
    var Batch = require("./lib/batch");
    var debug = require("debug")("wpcom");

    function WPCOM(request) {
        if (!(this instanceof WPCOM))return new WPCOM(request);
        if ("function" !== typeof request) {
            throw new TypeError("a `request` WP.com function must be passed in")
        }
        this.request = request
    }

    WPCOM.prototype.me = function () {
        return new Me(this)
    };
    WPCOM.prototype.site = function (id) {
        return new Site(id, this)
    };
    WPCOM.prototype.batch = function () {
        return new Batch(this)
    };
    WPCOM.prototype.freshlyPressed = function (query, fn) {
        this.sendRequest("/freshly-pressed", query, null, fn)
    };
    WPCOM.prototype.sendRequest = function (params, query, body, fn) {
        if ("string" == typeof params) {
            params = {path: params}
        }
        debug("sendRequest(%o)", params.path);
        params.method = (params.method || "get").toUpperCase();
        if ("function" == typeof query) {
            fn = query;
            query = null
        }
        if ("function" == typeof body) {
            fn = body;
            body = null
        }
        if (query)params.query = query;
        if (body)params.body = body;
        if (!fn)fn = function (err) {
            if (err)throw err
        };
        this.request(params, fn)
    };
    module.exports = WPCOM
}, {"./lib/batch": 248, "./lib/me": 254, "./lib/site": 258, debug: 260}], 248: [function (require, module, exports) {
    var debug = require("debug")("wpcom:batch");

    function Batch(wpcom) {
        if (!(this instanceof Batch))return new Batch(wpcom);
        this.wpcom = wpcom;
        this.urls = []
    }

    Batch.prototype.add = function (url) {
        this.urls.push(url);
        return this
    };
    Batch.prototype.run = function (query, fn) {
        if ("function" == typeof query) {
            fn = query;
            query = {}
        }
        query.urls = this.urls;
        this.wpcom.sendRequest("/batch", query, null, fn)
    };
    module.exports = Batch
}, {debug: 260}], 249: [function (require, module, exports) {
    var debug = require("debug")("wpcom:category");

    function Category(slug, sid, wpcom) {
        if (!sid) {
            throw new Error("`side id` is not correctly defined")
        }
        if (!(this instanceof Category))return new Category(slug, sid, wpcom);
        this.wpcom = wpcom;
        this._sid = sid;
        this._slug = slug
    }

    Category.prototype.slug = function (slug) {
        this._slug = slug
    };
    Category.prototype.get = function (query, fn) {
        var path = "/sites/" + this._sid + "/categories/slug:" + this._slug;
        this.wpcom.sendRequest(path, query, null, fn)
    };
    Category.prototype.add = function (body, fn) {
        var path = "/sites/" + this._sid + "/categories/new";
        this.wpcom.sendRequest({path: path, method: "post"}, null, body, fn)
    };
    Category.prototype.update = function (body, fn) {
        var path = "/sites/" + this._sid + "/categories/slug:" + this._slug;
        this.wpcom.sendRequest({path: path, method: "post"}, null, body, fn)
    };
    Category.prototype["delete"] = Category.prototype.del = function (fn) {
        var path = "/sites/" + this._sid + "/categories/slug:" + this._slug + "/delete";
        this.wpcom.sendRequest({path: path, method: "post"}, null, null, fn)
    };
    module.exports = Category
}, {debug: 260}], 250: [function (require, module, exports) {
    var CommentLike = require("./commentlike");
    var debug = require("debug")("wpcom:comment");

    function Comment(cid, pid, sid, wpcom) {
        if (!sid) {
            throw new Error("`side id` is not correctly defined")
        }
        if (!(this instanceof Comment))return new Comment(cid, pid, sid, wpcom);
        this.wpcom = wpcom;
        this._cid = cid;
        this._pid = pid;
        this._sid = sid
    }

    Comment.prototype.get = function (query, fn) {
        var path = "/sites/" + this._sid + "/comments/" + this._cid;
        this.wpcom.sendRequest(path, query, null, fn)
    };
    Comment.prototype.replies = function (query, fn) {
        var path = "/sites/" + this._sid + "/posts/" + this._pid + "/replies/";
        this.wpcom.sendRequest(path, query, null, fn)
    };
    Comment.prototype.add = function (body, fn) {
        body = "string" == typeof body ? {content: body} : body;
        var path = "/sites/" + this._sid + "/posts/" + this._pid + "/replies/new";
        this.wpcom.sendRequest({path: path, method: "post"}, null, body, fn)
    };
    Comment.prototype.update = function (body, fn) {
        body = "string" == typeof body ? {content: body} : body;
        var path = "/sites/" + this._sid + "/comments/" + this._cid;
        this.wpcom.sendRequest({path: path, method: "post"}, null, body, fn)
    };
    Comment.prototype.reply = function (body, fn) {
        body = "string" == typeof body ? {content: body} : body;
        var path = "/sites/" + this._sid + "/comments/" + this._cid + "/replies/new";
        this.wpcom.sendRequest({path: path, method: "post"}, null, body, fn)
    };
    Comment.prototype["delete"] = Comment.prototype.del = function (fn) {
        var path = "/sites/" + this._sid + "/comments/" + this._cid + "/delete";
        this.wpcom.sendRequest({path: path, method: "post"}, null, null, fn)
    };
    Comment.prototype.like = function () {
        return CommentLike(this._cid, this._sid, this.wpcom)
    };
    Comment.prototype.likesList = function (query, fn) {
        var path = "/sites/" + this._sid + "/comments/" + this._cid + "/likes";
        this.wpcom.sendRequest(path, query, null, fn)
    };
    module.exports = Comment
}, {"./commentlike": 251, debug: 260}], 251: [function (require, module, exports) {
    var debug = require("debug")("wpcom:commentlike");

    function CommentLike(cid, sid, wpcom) {
        if (!sid) {
            throw new Error("`side id` is not correctly defined")
        }
        if (!cid) {
            throw new Error("`comment id` is not correctly defined")
        }
        if (!(this instanceof CommentLike))return new CommentLike(cid, sid, wpcom);
        this.wpcom = wpcom;
        this._cid = cid;
        this._sid = sid
    }

    CommentLike.prototype.state = CommentLike.prototype.mine = function (query, fn) {
        var path = "/sites/" + this._sid + "/comments/" + this._cid + "/likes/mine";
        this.wpcom.sendRequest(path, query, null, fn)
    };
    CommentLike.prototype.add = function (query, fn) {
        var path = "/sites/" + this._sid + "/comments/" + this._cid + "/likes/new";
        this.wpcom.sendRequest({path: path, method: "post"}, query, null, fn)
    };
    CommentLike.prototype["delete"] = CommentLike.prototype.del = function (fn) {
        var path = "/sites/" + this._sid + "/comments/" + this._cid + "/likes/mine/delete";
        this.wpcom.sendRequest({path: path, method: "post"}, null, null, fn)
    };
    module.exports = CommentLike
}, {debug: 260}], 252: [function (require, module, exports) {
    var debug = require("debug")("wpcom:follow");

    function Follow(site_id, wpcom) {
        if (!site_id) {
            throw new Error("`site id` is not correctly defined")
        }
        if (!(this instanceof Follow))return new Follow(site_id, wpcom);
        this.wpcom = wpcom;
        this._sid = site_id
    }

    Follow.prototype.follow = Follow.prototype.add = function (query, fn) {
        var path = "/sites/" + this._sid + "/follows/new";
        this.wpcom.sendRequest({method: "POST", path: path}, query, null, fn)
    };
    Follow.prototype.unfollow = Follow.prototype.del = function (query, fn) {
        var path = "/sites/" + this._sid + "/follows/mine/delete";
        this.wpcom.sendRequest({method: "POST", path: path}, query, null, fn)
    };
    Follow.prototype.state = Follow.prototype.mine = function (query, fn) {
        var path = "/sites/" + this._sid + "/follows/mine";
        this.wpcom.sendRequest(path, query, null, fn)
    };
    module.exports = Follow
}, {debug: 260}], 253: [function (require, module, exports) {
    var debug = require("debug")("wpcom:like");

    function Like(pid, sid, wpcom) {
        if (!sid) {
            throw new Error("`side id` is not correctly defined")
        }
        if (!pid) {
            throw new Error("`post id` is not correctly defined")
        }
        if (!(this instanceof Like))return new Like(pid, sid, wpcom);
        this.wpcom = wpcom;
        this._pid = pid;
        this._sid = sid
    }

    Like.prototype.state = Like.prototype.mine = function (query, fn) {
        var path = "/sites/" + this._sid + "/posts/" + this._pid + "/likes/mine";
        this.wpcom.sendRequest(path, query, null, fn)
    };
    Like.prototype.add = function (query, fn) {
        var path = "/sites/" + this._sid + "/posts/" + this._pid + "/likes/new";
        this.wpcom.sendRequest({path: path, method: "post"}, query, null, fn)
    };
    Like.prototype["delete"] = Like.prototype.del = function (fn) {
        var path = "/sites/" + this._sid + "/posts/" + this._pid + "/likes/mine/delete";
        this.wpcom.sendRequest({path: path, method: "post"}, null, null, fn)
    };
    module.exports = Like
}, {debug: 260}], 254: [function (require, module, exports) {
    var debug = require("debug")("wpcom:me");

    function Me(wpcom) {
        if (!(this instanceof Me))return new Me(wpcom);
        this.wpcom = wpcom
    }

    Me.prototype.get = function (query, fn) {
        this.wpcom.sendRequest("/me", query, null, fn)
    };
    Me.prototype.sites = function (query, fn) {
        this.wpcom.sendRequest("/me/sites", query, null, fn)
    };
    Me.prototype.likes = function (query, fn) {
        this.wpcom.sendRequest("/me/likes", query, null, fn)
    };
    Me.prototype.groups = function (query, fn) {
        this.wpcom.sendRequest("/me/groups", query, null, fn)
    };
    Me.prototype.connections = function (query, fn) {
        this.wpcom.sendRequest("/me/connections", query, null, fn)
    };
    module.exports = Me
}, {debug: 260}], 255: [function (require, module, exports) {
    var debug = require("debug")("wpcom:media");

    function Media(id, sid, wpcom) {
        if (!(this instanceof Media))return new Media(id, sid, wpcom);
        this.wpcom = wpcom;
        this._sid = sid;
        this._id = id;
        if (!this._id) {
            debug("WARN: media id is not defined")
        }
    }

    Media.prototype.get = function (query, fn) {
        var path = "/sites/" + this._sid + "/media/" + this._id;
        this.wpcom.sendRequest(path, query, null, fn)
    };
    Media.prototype.update = function (body, fn) {
        var path = "/sites/" + this._sid + "/media/" + this._id;
        this.wpcom.sendRequest({path: path, method: "post"}, null, body, fn)
    };
    Media.prototype.addFiles = function (files, fn) {
        var path = "/sites/" + this._sid + "/media/new";
        var params = {path: path, method: "post", formData: []};
        files = Array.isArray(files) ? files : [files];
        for (var i = 0; i < files.length; i++) {
            params.formData.push(["media[]", files[i]])
        }
        this.wpcom.sendRequest(params, null, null, fn)
    };
    Media.prototype.addUrls = function (files, fn) {
        var path = "/sites/" + this._sid + "/media/new";
        var params = {path: path, method: "post"};
        var body = {media_urls: []};
        files = Array.isArray(files) ? files : [files];
        for (var i = 0; i < files.length; i++) {
            body.media_urls.push(files[i])
        }
        this.wpcom.sendRequest(params, null, body, fn)
    };
    Media.prototype["delete"] = Media.prototype.del = function (fn) {
        var path = "/sites/" + this._sid + "/media/" + this._id + "/delete";
        this.wpcom.sendRequest({path: path, method: "post"}, null, null, fn)
    };
    module.exports = Media
}, {debug: 260}], 256: [function (require, module, exports) {
    var Like = require("./like");
    var Reblog = require("./reblog");
    var Comment = require("./comment");
    var debug = require("debug")("wpcom:post");

    function Post(id, sid, wpcom) {
        if (!(this instanceof Post))return new Post(id, sid, wpcom);
        this.wpcom = wpcom;
        this._sid = sid;
        id = id || {};
        if ("object" != typeof id) {
            this._id = id
        } else {
            this._id = id.id;
            this._slug = id.slug
        }
    }

    Post.prototype.id = function (id) {
        this._id = id
    };
    Post.prototype.slug = function (slug) {
        this._slug = slug
    };
    Post.prototype.get = function (query, fn) {
        if (!this._id && this._slug) {
            return this.getBySlug(query, fn)
        }
        var path = "/sites/" + this._sid + "/posts/" + this._id;
        this.wpcom.sendRequest(path, query, null, fn)
    };
    Post.prototype.getBySlug = function (query, fn) {
        var path = "/sites/" + this._sid + "/posts/slug:" + this._slug;
        this.wpcom.sendRequest(path, query, null, fn)
    };
    Post.prototype.add = function (body, fn) {
        var path = "/sites/" + this._sid + "/posts/new";
        this.wpcom.sendRequest({path: path, method: "post"}, null, body, fn)
    };
    Post.prototype.update = function (body, fn) {
        var path = "/sites/" + this._sid + "/posts/" + this._id;
        this.wpcom.sendRequest({path: path, method: "post"}, null, body, fn)
    };
    Post.prototype["delete"] = Post.prototype.del = function (fn) {
        var path = "/sites/" + this._sid + "/posts/" + this._id + "/delete";
        this.wpcom.sendRequest({path: path, method: "post"}, null, null, fn)
    };
    Post.prototype.likesList = function (query, fn) {
        var path = "/sites/" + this._sid + "/posts/" + this._id + "/likes";
        this.wpcom.sendRequest(path, query, null, fn)
    };
    Post.prototype.related = function (body, fn) {
        var path = "/sites/" + this._sid + "/posts/" + this._id + "/related";
        this.wpcom.sendRequest({path: path, method: "post"}, null, body, fn)
    };
    Post.prototype.like = function () {
        return Like(this._id, this._sid, this.wpcom)
    };
    Post.prototype.reblog = function () {
        return Reblog(this._id, this._sid, this.wpcom)
    };
    Post.prototype.comment = function (cid) {
        return Comment(cid, this._id, this._sid, this.wpcom)
    };
    Post.prototype.comments = function (query, fn) {
        var comment = Comment(null, this._id, this._sid, this.wpcom);
        comment.replies(query, fn);
        return comment
    };
    module.exports = Post
}, {"./comment": 250, "./like": 253, "./reblog": 257, debug: 260}], 257: [function (require, module, exports) {
    var debug = require("debug")("wpcom:reblog");

    function Reblog(pid, sid, wpcom) {
        if (!sid) {
            throw new Error("`side id` is not correctly defined")
        }
        if (!pid) {
            throw new Error("`post id` is not correctly defined")
        }
        if (!(this instanceof Reblog))return new Reblog(pid, sid, wpcom);
        this.wpcom = wpcom;
        this._pid = pid;
        this._sid = sid
    }

    Reblog.prototype.state = Reblog.prototype.mine = function (query, fn) {
        var path = "/sites/" + this._sid + "/posts/" + this._pid + "/reblogs/mine";
        this.wpcom.sendRequest(path, query, null, fn)
    };
    Reblog.prototype.add = function (body, fn) {
        if (body && !body.destination_site_id) {
            return fn(new Error("destination_site_id is not defined"))
        }
        var path = "/sites/" + this._sid + "/posts/" + this._pid + "/reblogs/new";
        this.wpcom.sendRequest({path: path, method: "post"}, null, body, fn)
    };
    Reblog.prototype.to = function (dest, note, fn) {
        if ("function" == typeof note) {
            fn = note;
            note = null
        }
        this.add({note: note, destination_site_id: dest}, fn)
    };
    module.exports = Reblog
}, {debug: 260}], 258: [function (require, module, exports) {
    var Post = require("./post");
    var Category = require("./category");
    var Tag = require("./tag");
    var Media = require("./media");
    var Comment = require("./comment");
    var Follow = require("./follow");
    var debug = require("debug")("wpcom:site");
    var resources = ["categories", "comments", "follows", "media", "posts", ["stats", "stats"], ["statsVisits", "stats/visits"], ["statsReferrers", "stats/referrers"], ["statsTopPosts", "stats/top-posts"], ["statsCountryViews", "stats/country-views"], ["statsClicks", "stats/clicks"], ["statsSearchTerms", "stats/search-terms"], "tags", "users"];

    function Site(id, wpcom) {
        if (!(this instanceof Site))return new Site(id, wpcom);
        this.wpcom = wpcom;
        debug("set %o site id", id);
        this._id = id
    }

    Site.prototype.get = function (query, fn) {
        this.wpcom.sendRequest("/sites/" + this._id, query, null, fn)
    };
    var list = function (subpath) {
        return function (query, fn) {
            this.wpcom.sendRequest("/sites/" + this._id + "/" + subpath, query, null, fn)
        }
    };
    for (var i = 0; i < resources.length; i++) {
        var res = resources[i];
        var isarr = Array.isArray(res);
        var name = isarr ? res[0] : res + "List";
        var subpath = isarr ? res[1] : res;
        debug("adding %o method in %o sub-path", "site." + name + "()", subpath);
        Site.prototype[name] = list.call(this, subpath)
    }
    Site.prototype.post = function (id) {
        return Post(id, this._id, this.wpcom)
    };
    Site.prototype.addPost = function (body, fn) {
        var post = Post(null, this._id, this.wpcom);
        post.add(body, fn);
        return post
    };
    Site.prototype.deletePost = function (id, fn) {
        var post = Post(id, this._id, this.wpcom);
        post.delete(fn);
        return post
    };
    Site.prototype.media = function (id) {
        return Media(id, this._id, this.wpcom)
    };
    Site.prototype.addMediaFiles = function (files, fn) {
        var media = Media(null, this._id, this.wpcom);
        media.addFiles(files, fn);
        return media
    };
    Site.prototype.addMediaUrls = function (files, fn) {
        var media = Media(null, this._id, this.wpcom);
        media.addUrls(files, fn);
        return media
    };
    Site.prototype.deleteMedia = function (id, fn) {
        var media = Media(id, this._id, this.wpcom);
        media.del(fn);
        return media
    };
    Site.prototype.comment = function (id) {
        return Comment(id, null, this._id, this.wpcom)
    };
    Site.prototype.follow = function () {
        return Follow(this._id, this.wpcom)
    };
    Site.prototype.cat = Site.prototype.category = function (slug) {
        return Category(slug, this._id, this.wpcom)
    };
    Site.prototype.tag = function (slug) {
        return Tag(slug, this._id, this.wpcom)
    };
    module.exports = Site
}, {"./category": 249, "./comment": 250, "./follow": 252, "./media": 255, "./post": 256, "./tag": 259, debug: 260}], 259: [function (require, module, exports) {
    var debug = require("debug")("wpcom:tag");

    function Tag(slug, sid, wpcom) {
        if (!sid) {
            throw new Error("`side id` is not correctly defined")
        }
        if (!(this instanceof Tag))return new Tag(slug, sid, wpcom);
        this.wpcom = wpcom;
        this._sid = sid;
        this._slug = slug
    }

    Tag.prototype.slug = function (slug) {
        this._slug = slug
    };
    Tag.prototype.get = function (query, fn) {
        var path = "/sites/" + this._sid + "/tags/slug:" + this._slug;
        this.wpcom.sendRequest(path, query, null, fn)
    };
    Tag.prototype.add = function (body, fn) {
        var path = "/sites/" + this._sid + "/tags/new";
        this.wpcom.sendRequest({path: path, method: "post"}, null, body, fn)
    };
    Tag.prototype.update = function (body, fn) {
        var path = "/sites/" + this._sid + "/tags/slug:" + this._slug;
        this.wpcom.sendRequest({path: path, method: "post"}, null, body, fn)
    };
    Tag.prototype["delete"] = Tag.prototype.del = function (fn) {
        var path = "/sites/" + this._sid + "/tags/slug:" + this._slug + "/delete";
        this.wpcom.sendRequest({path: path, method: "post"}, null, null, fn)
    };
    module.exports = Tag
}, {debug: 260}], 260: [function (require, module, exports) {
    exports = module.exports = require("./debug");
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.colors = ["lightseagreen", "forestgreen", "goldenrod", "dodgerblue", "darkorchid", "crimson"];
    function useColors() {
        return"WebkitAppearance"in document.documentElement.style || window.console && (console.firebug || console.exception && console.table) || navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31
    }

    exports.formatters.j = function (v) {
        return JSON.stringify(v)
    };
    function formatArgs() {
        var args = arguments;
        var useColors = this.useColors;
        args[0] = (useColors ? "%c" : "") + this.namespace + (useColors ? " %c" : " ") + args[0] + (useColors ? "%c " : " ") + "+" + exports.humanize(this.diff);
        if (!useColors)return args;
        var c = "color: " + this.color;
        args = [args[0], c, "color: inherit"].concat(Array.prototype.slice.call(args, 1));
        var index = 0;
        var lastC = 0;
        args[0].replace(/%[a-z%]/g, function (match) {
            if ("%%" === match)return;
            index++;
            if ("%c" === match) {
                lastC = index
            }
        });
        args.splice(lastC, 0, c);
        return args
    }

    function log() {
        return"object" == typeof console && "function" == typeof console.log && Function.prototype.apply.call(console.log, console, arguments)
    }

    function save(namespaces) {
        try {
            if (null == namespaces) {
                localStorage.removeItem("debug")
            } else {
                localStorage.debug = namespaces
            }
        } catch (e) {
        }
    }

    function load() {
        var r;
        try {
            r = localStorage.debug
        } catch (e) {
        }
        return r
    }

    exports.enable(load())
}, {"./debug": 261}], 261: [function (require, module, exports) {
    exports = module.exports = debug;
    exports.coerce = coerce;
    exports.disable = disable;
    exports.enable = enable;
    exports.enabled = enabled;
    exports.humanize = require("ms");
    exports.names = [];
    exports.skips = [];
    exports.formatters = {};
    var prevColor = 0;
    var prevTime;

    function selectColor() {
        return exports.colors[prevColor++ % exports.colors.length]
    }

    function debug(namespace) {
        function disabled() {
        }

        disabled.enabled = false;
        function enabled() {
            var self = enabled;
            var curr = +new Date;
            var ms = curr - (prevTime || curr);
            self.diff = ms;
            self.prev = prevTime;
            self.curr = curr;
            prevTime = curr;
            if (null == self.useColors)self.useColors = exports.useColors();
            if (null == self.color && self.useColors)self.color = selectColor();
            var args = Array.prototype.slice.call(arguments);
            args[0] = exports.coerce(args[0]);
            if ("string" !== typeof args[0]) {
                args = ["%o"].concat(args)
            }
            var index = 0;
            args[0] = args[0].replace(/%([a-z%])/g, function (match, format) {
                if (match === "%%")return match;
                index++;
                var formatter = exports.formatters[format];
                if ("function" === typeof formatter) {
                    var val = args[index];
                    match = formatter.call(self, val);
                    args.splice(index, 1);
                    index--
                }
                return match
            });
            if ("function" === typeof exports.formatArgs) {
                args = exports.formatArgs.apply(self, args)
            }
            var logFn = enabled.log || exports.log || console.log.bind(console);
            logFn.apply(self, args)
        }

        enabled.enabled = true;
        var fn = exports.enabled(namespace) ? enabled : disabled;
        fn.namespace = namespace;
        return fn
    }

    function enable(namespaces) {
        exports.save(namespaces);
        var split = (namespaces || "").split(/[\s,]+/);
        var len = split.length;
        for (var i = 0; i < len; i++) {
            if (!split[i])continue;
            namespaces = split[i].replace(/\*/g, ".*?");
            if (namespaces[0] === "-") {
                exports.skips.push(new RegExp("^" + namespaces.substr(1) + "$"))
            } else {
                exports.names.push(new RegExp("^" + namespaces + "$"))
            }
        }
    }

    function disable() {
        exports.enable("")
    }

    function enabled(name) {
        var i, len;
        for (i = 0, len = exports.skips.length; i < len; i++) {
            if (exports.skips[i].test(name)) {
                return false
            }
        }
        for (i = 0, len = exports.names.length; i < len; i++) {
            if (exports.names[i].test(name)) {
                return true
            }
        }
        return false
    }

    function coerce(val) {
        if (val instanceof Error)return val.stack || val.message;
        return val
    }
}, {ms: 262}], 262: [function (require, module, exports) {
    module.exports = require(50)
}, {}], 263: [function (require, module, exports) {
    var superagent = require("superagent");
    var debug = require("debug")("wpcom-xhr-request");
    module.exports = request;
    var proxyOrigin = "https://public-api.wordpress.com";
    var defaultApiVersion = "1";

    function request(params, fn) {
        if ("string" == typeof params) {
            params = {path: params}
        }
        var method = (params.method || "GET").toLowerCase();
        debug("API HTTP Method: %o", method);
        delete params.method;
        var apiVersion = params.apiVersion || defaultApiVersion;
        delete params.apiVersion;
        var url = proxyOrigin + "/rest/v" + apiVersion + params.path;
        debug("API URL: %o", url);
        delete params.path;
        var req = superagent[method](url);
        if (params.authToken) {
            req.set("Authorization", "Bearer " + params.authToken);
            delete params.authToken
        }
        if (params.query) {
            req.query(params.query);
            debug("API send URL querystring: %o", params.query);
            delete params.query
        }
        if (params.body) {
            req.send(params.body);
            debug("API send POST body: ", params.body);
            delete params.body
        }
        if (params.formData) {
            for (var i = 0; i < params.formData.length; i++) {
                var data = params.formData[i];
                var key = data[0];
                var value = data[1];
                debug("adding FormData field %o", key);
                req.field(key, value)
            }
        }
        req.end(function (err, res) {
            if (err)return fn(err);
            var body = res.body;
            var headers = res.headers;
            var statusCode = res.status;
            debug("%o -> %o status code", url, statusCode);
            if (body && headers) {
                body._headers = headers
            }
            if (2 === Math.floor(statusCode / 100)) {
                fn(null, body)
            } else {
                err = new Error;
                err.statusCode = statusCode;
                for (var i in body)err[i] = body[i];
                if (body && body.error)err.name = toTitle(body.error) + "Error";
                fn(err)
            }
        })
    }

    function toTitle(str) {
        if (!str || "string" !== typeof str)return"";
        return str.replace(/((^|_)[a-z])/g, function ($1) {
            return $1.toUpperCase().replace("_", "")
        })
    }
}, {debug: 264, superagent: 267}], 264: [function (require, module, exports) {
    module.exports = require(260)
}, {"./debug": 265}], 265: [function (require, module, exports) {
    module.exports = require(261)
}, {ms: 266}], 266: [function (require, module, exports) {
    module.exports = require(50)
}, {}], 267: [function (require, module, exports) {
    module.exports = require(238)
}, {emitter: 268, reduce: 269}], 268: [function (require, module, exports) {
    module.exports = require(239)
}, {}], 269: [function (require, module, exports) {
    module.exports = require(221)
}, {}], 270: [function (require, module, exports) {
    var _WPCOM = require("./index.js");
    var request = require("wpcom-xhr-request");
    var inherits = require("inherits");
    module.exports = WPCOM;
    function WPCOM(token) {
        if (!(this instanceof WPCOM))return new WPCOM(token);
        _WPCOM.call(this, request);
        this.token = token
    }

    inherits(WPCOM, _WPCOM);
    WPCOM.prototype.setToken = function (token) {
        this.token = token
    };
    WPCOM.prototype.sendRequest = function (params, query, body, fn) {
        if ("string" == typeof params)params = {path: params};
        var token = params.token || this.token;
        if (token)params.authToken = token;
        return _WPCOM.prototype.sendRequest.call(this, params, query, body, fn)
    }
}, {"./index.js": 247, inherits: 52, "wpcom-xhr-request": 263}], 271: [function (require, module, exports) {
    try {
        module.exports = bootstrap ? JSON.parse(decodeURIComponent(bootstrap)) : null
    } catch (e) {
        module.exports = null
    }
}, {}], 272: [function (require, module, exports) {
    module.exports = {hasTouch: function () {
        return"ontouchstart"in window || window.DocumentTouch && document instanceof DocumentTouch
    }}
}, {}], 273: [function (require, module, exports) {
    var debug = require("debug")("notifications:client-switch");
    var config = require("config");
    var client;
    switch (config("notifications_api")) {
        case"rest":
            debug("rest");
            client = require("./rest");
            break;
        case"simperium":
            debug("simperium");
            client = require("./simperium");
            break;
        case"test":
            debug("test");
            client = require("./test");
            break
    }
    module.exports = client
}, {"./rest": 3, "./simperium": 4, "./test": 5, config: 275, debug: 48}], 274: [function (require, module, exports) {
    var debug = require("debug")("notifications:note");

    function getItem(key) {
        var item;
        try {
            item = localStorage.getItem(key);
            return JSON.parse(item)
        } catch (e) {
            if (e instanceof SyntaxError) {
                return item
            }
            debug("couldnt get localStorage item for: %s", key)
        }
        return null
    }

    function setItem(key, value) {
        try {
            localStorage.setItem(key, JSON.stringify(value))
        } catch (e) {
            debug("couldnt set localStorage item for: %s", key)
        }
    }

    function removeItem(key) {
        try {
            localStorage.removeItem(key)
        } catch (e) {
            debug("couldnt remove item from localStorage for: %s", key)
        }
    }

    function cleanupRepliesCache() {
        var keysToRemove = [];
        try {
            for (var i = 0; i < localStorage.length; i++) {
                var storedReplyKey = localStorage.key(i);
                if ("reply_" == localStorage.key(i).substring(0, 6)) {
                    var storedReply = getItem(storedReplyKey);
                    if (storedReply && Date.now() - storedReply[1] >= 24 * 60 * 60 * 1e3) {
                        keysToRemove.push(storedReplyKey)
                    }
                }
            }
        } catch (e) {
            debug("couldnt cleanup cache")
        }
        keysToRemove.forEach(function (key) {
            removeItem(key)
        })
    }

    var LocalStorageMixin = {localStorage: {getItem: getItem, setItem: setItem, removeItem: removeItem}};
    module.exports.cleanup = cleanupRepliesCache;
    module.exports.LocalStorageMixin = LocalStorageMixin
}, {debug: 48}], 275: [function (require, module, exports) {
    var filename = "wpcom.json";
    var data = {env: "production", simperium: {app_id: "victims-markets-c61", api_key: "496bb7cae45f453bb7feab350b823627", bucket: "note20", metabucket: "meta"}, i18n_default_locale_slug: "en", api_transport: "rest-proxy", notifications_api: "rest", rest: {max_refresh_ms: 18e4, refresh_ms: 3e4, initial_limit: 10, increment_limit: 10, max_limit: 100}, prefix: "notifications"};

    function config(key) {
        if (key in data)return data[key];
        throw new Error("config key `" + key + '` does not exist in "' + filename + '"')
    }

    module.exports = config
}, {}], 276: [function (require, module, exports) {
    var cookie = require("cookie");
    module.exports.serialize = cookie.serialize;
    module.exports.parse = parse;
    function parse(cookieString) {
        var cookies = cookie.parse(cookieString);
        var key;
        for (key in cookies) {
            if ("string" !== typeof cookies[key]) {
                continue
            }
            if ("s:" !== cookies[key].slice(0, 2)) {
                continue
            }
            cookies[key] = cookies[key].slice(2, cookies[key].lastIndexOf("."))
        }
        return cookies
    }
}, {cookie: 47}], 277: [function (require, module, exports) {
    module.exports = convert;
    function convert(blob, options) {
        var pieces = [];
        options = options || {};
        options.links = "undefined" === typeof options.links ? true : options.links;
        ["media", "ranges"].forEach(function (group) {
            if (!blob[group]) {
                return
            }
            blob[group].forEach(function (piece) {
                piece.group = group;
                pieces.push(piece)
            })
        });
        pieces.sort(sort);
        var index = 0;
        var out = document.createDocumentFragment();
        pieces.forEach(function (piece) {
            var classes = [];
            var atts = {};
            var tag = "span";
            var el;
            var text = blob.text.slice.apply(blob.text, piece.indices);
            var makeTextNode = true;
            if (index != piece.indices[0]) {
                out.appendChild(document.createTextNode(blob.text.slice(index, piece.indices[0])))
            }
            if (piece.type) {
                classes.push(piece.type)
            }
            if ("media" === piece.group) {
                switch (piece.type) {
                    case"badge":
                        atts.width = 256;
                        atts.height = 256;
                    case"image":
                        tag = "img";
                        atts.src = piece.url;
                        if (text.length) {
                            atts.alt = text
                        }
                        makeTextNode = false;
                        break
                }
            } else {
                switch (piece.type) {
                    case"blockquote":
                        tag = "blockquote";
                        break;
                    case"noticon":
                        text = piece.value;
                        break;
                    default:
                        if (options.links && piece.url) {
                            tag = "a";
                            atts.href = piece.url;
                            atts.target = "_blank";
                            if ("stat" == piece.type)atts.target = "_parent"
                        }
                        break
                }
            }
            el = document.createElement(tag);
            if (classes.length) {
                el.className = classes.join(" ")
            }
            if (makeTextNode) {
                el.appendChild(document.createTextNode(text))
            }
            Object.keys(atts).forEach(function (key) {
                el.setAttribute(key, atts[key])
            });
            out.appendChild(el);
            index = piece.indices[1]
        });
        if (index < blob.text.length) {
            out.appendChild(document.createTextNode(blob.text.slice(index, blob.text.length)))
        }
        return out
    }

    function sort(a, b) {
        return a.indices[0] - b.indices[0]
    }

    function html(blob, options) {
        var div = document.createElement("div");
        div.appendChild(convert(blob, options));
        return div.innerHTML
    }

    convert.html = html
}, {}], 278: [function (require, module, exports) {
    var debug = require("debug")("notifications:note");
    var i18n = require("i18n");
    module.exports = setup;
    function setup() {
        return function (ctx) {
            debug("rendering note view: %s", ctx.params.note);
            ctx.data.title = i18n.translate({original: "Note", context: "noun: a single notification"});
            ctx.data.current = ctx.params.note;
            ctx.render()
        }
    }
}, {debug: 48, i18n: 6}], 279: [function (require, module, exports) {
    var debug = require("debug")("notifications:notfound");
    var i18n = require("i18n");
    module.exports = setup;
    function setup() {
        return function (ctx) {
            var locals = {path: ctx.pathname};
            debug("rendering not found template with locals %o", locals);
            ctx.state.title = i18n.translate({original: "Not Found", context: "an error: this page could not be found"});
            ctx.state.error = ctx.state.title;
            ctx.render()
        }
    }
}, {debug: 48, i18n: 6}], 280: [function (require, module, exports) {
    var debug = require("debug")("notifications:notifications");
    var i18n = require("i18n");
    module.exports = setup;
    function setup() {
        return function (ctx) {
            debug("rendering main view");
            ctx.data.title = i18n.translate({original: "Notifications", context: "noun: plural"});
            ctx.render()
        }
    }
}, {debug: 48, i18n: 6}], 281: [function (require, module, exports) {
    var events = require("events");
    var inherits = require("inherits");
    var wp = require("wp");
    var repliesCache = require("comment-replies-cache");
    var debug = require("debug")("notifications:rest-client");
    var settings = require("config")("rest");
    module.exports = Client;
    function inIframe() {
        try {
            return window.self !== window.top
        } catch (e) {
            return true
        }
    }

    function Client() {
        events.EventEmitter.call(this);
        this.is_ready = false;
        this.notes = [];
        this.noteList = [];
        this.timeout = false;
        this.showing = !inIframe();
        this.lastSeenTime = 0;
        this.lastNewNoteCount = 0;
        this.noteRequestLimit = settings["initial_limit"];
        this.paused = false;
        this.retries = 0;
        window.addEventListener("storage", handleStorageEvent.bind(this));
        if (typeof document.hidden !== "undefined") {
            document.addEventListener("visibilitychange", handleVisibilityChange.bind(this))
        }
        getNotes.call(this)
    }

    function getNote(note_id) {
        var parameters = {fields: "id,type,unread,body,subject,timestamp,meta"};
        wp.undocumented().notifications().get(note_id, parameters, function (err, data) {
            if (!err) {
                for (var i = 0; i < this.notes.length; i++) {
                    if (this.notes[i].id == note_id) {
                        this.notes[i] = data.notes[0];
                        break
                    }
                }
                this.is_ready = true;
                debug("emit ready, showing: %s", this.showing);
                this.emit("ready")
            }
        }.bind(this))
    }

    function getNotes() {
        var parameters = {fields: "id,type,unread,body,subject,timestamp,meta,note_hash", number: this.noteRequestLimit};
        if (this.paused) {
            debug("getNotes: paused, rescheduling");
            clearTimeout(this.timeout);
            this.timeout = setTimeout(getNotes.bind(this), settings["refresh_ms"]);
            return
        }
        if (this.noteRequestLimit > this.notes.length) {
            this.emit("loading")
        }
        wp.undocumented().notifications().list(parameters, function (error, data) {
            if (this.timeout) {
                clearTimeout(this.timeout)
            }
            if (error) {
                this.retries = this.retries + 1;
                var backoff_ms = Math.min(settings["refresh_ms"] * (this.retries + 1), settings["max_refresh_ms"]);
                debug("getNotes error, using backoff_ms=%d", backoff_ms);
                this.noteList = [];
                this.timeout = setTimeout(getNotes.bind(this), backoff_ms)
            } else {
                this.emit("loadingDone");
                this.notes = data.notes;
                this.noteList = data.notes.map(function (note) {
                    return{id: note.id, note_hash: note.note_hash}
                });
                this.updateLastSeenTime(Number(data.last_seen_time));
                if (parameters.number == settings["max_limit"]) {
                    cleanupLocalCache.call(this)
                }
                this.retries = 0;
                if (this.notes.length) {
                    this.timeout = setTimeout(getNotesList.bind(this), settings["refresh_ms"])
                } else {
                    this.timeout = setTimeout(getNotes.bind(this), settings["refresh_ms"])
                }
                ready.call(this)
            }
        }.bind(this))
    }

    function getNotesList() {
        if (!this.notes.length) {
            return
        }
        if (this.timeout) {
            clearTimeout(this.timeout)
        }
        if (this.paused) {
            debug("getNotesList: paused, rescheduling");
            this.timeout = setTimeout(getNotesList.bind(this), settings["refresh_ms"]);
            return
        }
        var parameters = {fields: "id,note_hash", number: this.noteRequestLimit};
        wp.undocumented().notifications().list(parameters, function (error, data) {
            if (this.timeout) {
                clearTimeout(this.timeout)
            }
            if (error) {
                this.retries = this.retries + 1;
                var backoff_ms = Math.min(settings["refresh_ms"] * (this.retries + 1), settings["max_refresh_ms"]);
                debug("getNotesList error, using backoff_ms=%d", backoff_ms);
                this.timeout = setTimeout(getNotesList.bind(this), backoff_ms);
                return
            } else {
                this.retries = 0;
                this.timeout = setTimeout(getNotesList.bind(this), settings["refresh_ms"])
            }
            var serverHasChanges = false;
            var newerNoteList = data.notes.map(function (note) {
                return note.id
            });
            var localNoteList = this.noteList.map(function (note) {
                return note.id
            });
            var notesToRemove = [];
            for (var i = 0; i < localNoteList.length; i++) {
                if (-1 == newerNoteList.indexOf(localNoteList[i])) {
                    notesToRemove.push(localNoteList[i])
                }
            }
            for (var i = 0; i < newerNoteList.length; i++) {
                var indexOfLocalNote = localNoteList.indexOf(newerNoteList[i]);
                if (-1 == indexOfLocalNote) {
                    serverHasChanges = true;
                    break
                }
                if (data.notes[i].note_hash != this.noteList[indexOfLocalNote].note_hash) {
                    serverHasChanges = true;
                    break
                }
            }
            notesToRemove.forEach(function (note) {
                try {
                    localStorage.removeItem("note_read_status_" + note)
                } catch (e) {
                }
                for (var i = 0; i < this.notes.length; i++) {
                    if (note == this.notes[i].id) {
                        this.notes.splice(i, 1);
                        break
                    }
                }
            }.bind(this));
            this.noteList = data.notes;
            this.updateLastSeenTime(Number(data.last_seen_time));
            repliesCache.cleanup();
            if (serverHasChanges) {
                getNotes.call(this)
            } else {
                ready.call(this)
            }
        }.bind(this))
    }

    inherits(Client, events.EventEmitter);
    function sort_notes(a, b) {
        return Date.parse(b.timestamp) - Date.parse(a.timestamp)
    }

    function ready() {
        var newNoteCount = 0;
        this.notes.sort(sort_notes);
        if (this.lastSeenTime) {
            for (newNoteCount = 0; newNoteCount < this.notes.length; newNoteCount++) {
                if (Date.parse(this.notes[newNoteCount].timestamp) / 1e3 <= this.lastSeenTime)break
            }
        }
        this.is_ready = true;
        debug("emit ready: %d new notes, lastSeenTime: %s", newNoteCount, this.lastSeenTime);
        this.emit("ready");
        if (this.lastNewNoteCount !== newNoteCount) {
            this.sendMessage({action: "render", num_new: newNoteCount, latest_type: this.notes[0].type})
        }
        this.lastNewNoteCount = newNoteCount
    }

    function start() {
        if (this.is_ready) {
            this.emit("ready")
        }
    }

    function cleanupLocalCache() {
        var currentNoteIds = this.notes.map(function (note) {
            return note.id
        });
        var keysToRemove = [];
        try {
            for (var i = 0; i < localStorage.length; i++) {
                var stored_id;
                if ("note_read_status_" == localStorage.key(i).substring(0, 17)) {
                    stored_id = Number(localStorage.key(i).substring(18))
                } else if ("reply_" == localStorage.key(i).substring(0, 6)) {
                    stored_id = Number(localStorage.key(i).substring(6))
                }
                if (stored_id && -1 == currentNoteIds.indexOf(stored_id)) {
                    keysToRemove.push(localStorage.key(i))
                }
            }
        } catch (e) {
        }
        keysToRemove.forEach(function (key) {
            try {
                localStorage.removeItem(key)
            } catch (e) {
            }
        })
    }

    function noteIsRead(note) {
        if (note.read) {
            return true
        }
        try {
            var readStatus = localStorage.getItem("note_read_status_" + note.id);
            if (null != readStatus && "1" == readStatus) {
                return true
            }
        } catch (e) {
        }
        return false
    }

    function setReadStatus(id, status) {
        var note = this.notes.filter(function (note) {
            return note.id == id
        }).pop();
        if (!note) {
            return
        }
        status = "undefined" === typeof status ? true : !!status;
        note.read = status ? 1 : 0;
        try {
            localStorage.setItem("note_read_status_" + id, status ? "1" : "0")
        } catch (e) {
        }
        wp.undocumented().notifications().read(id, status)
    }

    function updateLastSeenTime(proposedTime) {
        var delay = 0;
        var updateRemote = false;
        var mostRecentNoteTime = 0;
        if (this.notes.length) {
            mostRecentNoteTime = Date.parse(this.notes[0].timestamp) / 1e3
        }
        if (this.showing && mostRecentNoteTime > proposedTime) {
            proposedTime = mostRecentNoteTime;
            updateRemote = true;
            delay = 3e3
        }
        if (proposedTime > 11234736e5) {
            proposedTime = proposedTime / 1e3
        }
        if (proposedTime <= this.lastSeenTime) {
            return false
        }
        var updateLastSeenMeta = function () {
            this.updateTimer = null;
            this.lastSeenTime = proposedTime;
            if (updateRemote) {
                wp.undocumented().notifications().seen(this.lastSeenTime)
            }
            try {
                localStorage.setItem("notesLastMarkedSeen", this.lastSeenTime)
            } catch (e) {
            }
        }.bind(this);
        if (updateLastSeenTime.updateTimer) {
            return false
        }
        this.updateTimer = window.setTimeout(updateLastSeenMeta, delay);
        return true
    }

    function preloadNoteAssets(note) {
        window.preloadedAssets.preloadImage(note.icon)
    }

    function handleIncomingMessage(message) {
        debug("incoming message: %s", message.action);
        switch (message.action) {
            case"togglePanel":
                if (!inIframe()) {
                    return
                }
                if (this.showing && !message.showing) {
                    this.showing = message.showing;
                    this.router("/", {resetView: true})
                }
                this.showing = message.showing;
                updateLastSeenTime.call(this, 0);
                break;
            case"refreshNotes":
                getNotesList.call(this);
                break;
            case"toggleVisibility":
                handleVisibilityChange.call(this, message.hidden);
                break
        }
    }

    function handleStorageEvent(event) {
        if (!event) {
            return
        }
        if (event.key == "notesLastMarkedSeen") {
            try {
                var lastSeenTime = Number(event.newValue);
                if (updateLastSeenTime.call(this, lastSeenTime)) {
                    this.sendMessage({action: "renderAllSeen"})
                }
            } catch (e) {
            }
        } else if ("note_read_status_" == event.key.substring(0, 17)) {
            this.emit("ready")
        }
    }

    function handleVisibilityChange(hidden) {
        if (typeof hidden !== "boolean") {
            hidden = document.hidden
        }
        if (hidden) {
            debug("visibility changed: client paused");
            this.paused = true
        } else {
            debug("visibility changed: client un-paused");
            this.paused = false
        }
    }

    function loadMore() {
        if (this.noteRequestLimit > this.notes.length) {
            return
        }
        if (this.noteRequestLimit >= settings["max_limit"]) {
            return
        }
        this.noteRequestLimit = this.noteRequestLimit + settings["increment_limit"];
        if (this.noteRequestLimit > settings["max_limit"]) {
            this.noteRequestLimit = settings["max_limit"]
        }
        this.getNotes()
    }

    function approveNoteLocal(id) {
        for (var i = 0; i < this.notes.length; i++) {
            if (this.notes[i].id == id) {
                this.notes[i].body[this.notes[i].body.length - 1].actions["approve-comment"] = true
            }
        }
        this.emit("ready")
    }

    function hasSessionStorageKey(key) {
        var hasKey = false;
        try {
            hasKey = !!sessionStorage[key]
        } catch (e) {
            debug("couldn't get sessionStorage item for: %s", key)
        }
        return hasKey
    }

    function getUsersSuggestions(siteId) {
        var key = "suggestions-" + siteId;
        if (!this.suggestions) {
            this.suggestions = {}
        }
        if (this.suggestions[key]) {
            return
        }
        this.suggestions[key] = [];
        this.emit("loading");
        try {
            if (null != sessionStorage.getItem(key)) {
                var newSuggestions = JSON.parse(sessionStorage.getItem(key));
                this.suggestions[key] = newSuggestions;
                this.emit("loadingDone");
                this.emit("ready");
                return
            }
        } catch (e) {
            debug("couldn't get sessionStorage item for: %s", key)
        }
        wp.undocumented().userSuggestions().get({site_id: siteId}, function (err, data) {
            if (!err) {
                var newSuggestions = data.suggestions;
                newSuggestions.forEach(function (suggestion) {
                    suggestion.name = suggestion.name || suggestion.user_login + " " + suggestion.display_name
                });
                this.suggestions[key] = newSuggestions;
                try {
                    sessionStorage.setItem(key, JSON.stringify(newSuggestions))
                } catch (e) {
                    debug("couldn't set sessionStorage item for: %s", key)
                }
            }
            this.emit("loadingDone");
            this.emit("ready")
        }.bind(this))
    }

    Client.prototype.ready = ready;
    Client.prototype.start = start;
    Client.prototype.getNote = getNote;
    Client.prototype.getNotes = getNotes;
    Client.prototype.getNotesList = getNotesList;
    Client.prototype.noteIsRead = noteIsRead;
    Client.prototype.setReadStatus = setReadStatus;
    Client.prototype.updateLastSeenTime = updateLastSeenTime;
    Client.prototype.handleIncomingMessage = handleIncomingMessage;
    Client.prototype.loadMore = loadMore;
    Client.prototype.approveNoteLocal = approveNoteLocal;
    Client.prototype.getUsersSuggestions = getUsersSuggestions
}, {"comment-replies-cache": 274, config: 275, debug: 48, events: 44, inherits: 52, wp: 34}], 282: [function (require, module, exports) {
    var events = require("events");
    var inherits = require("inherits");
    var simperium = require("simperium");
    var debug = require("debug")("notifications:simperium-client");
    module.exports = Client;
    function inIframe() {
        try {
            return window.self !== window.top
        } catch (e) {
            return true
        }
    }

    function Client(settings) {
        events.EventEmitter.call(this);
        this.app_id = settings.app_id;
        this.bucketname = settings.bucket;
        this.metabucket = settings.metabucket;
        this.token = settings.token || false;
        this.is_ready = false;
        this.showing = !inIframe();
        this.notes = [];
        if (this.token) {
            this.setToken(this.token)
        }
        window.addEventListener("storage", handleStorageEvent.bind(this))
    }

    function setToken(token) {
        this.token = token;
        debug("Connecting to APP:%s, BUCKET:%s with TOKEN:%s", this.app_id, this.bucketname, this.token);
        this.simperium = new simperium(this.app_id);
        this.bucket = this.simperium.bucket(this.bucketname, {token: this.token});
        this.bucket.on("notify_init", notify_init.bind(this));
        this.bucket.on("notify", notify.bind(this));
        this.bucket.on("ready", ready.bind(this));
        this.bucket.start();
        this.meta = this.simperium.bucket(this.metabucket, {token: this.token});
        this.meta.start()
    }

    inherits(Client, events.EventEmitter);
    function notify_init(id, data) {
        debug("Notify INIT ID:%s, DATA:%o", id, data);
        add.call(this, id, data)
    }

    function notify(id, data) {
        debug("Notify ID:%s, DATA:%o", id, data);
        add.call(this, id, data);
        ready.call(this)
    }

    function add(id, data) {
        this.notes = this.notes.filter(function (note) {
            return note.id != id
        });
        if (null === data) {
            return
        }
        preloadNoteAssets(data);
        this.notes.push(data);
        this.emit("loadingDone")
    }

    function sort_notes(a, b) {
        return Date.parse(b.timestamp) - Date.parse(a.timestamp)
    }

    function ready() {
        this.notes.sort(sort_notes);
        this.is_ready = true;
        debug("emit ready");
        this.emit("ready")
    }

    function start() {
        if (this.is_ready) {
            this.emit("ready")
        }
    }

    function noteIsRead(note) {
        if (note.read) {
            return true
        }
        try {
            var readStatus = localStorage.getItem("note_read_status_" + note.id);
            if (null != readStatus && "1" == readStatus) {
                return true
            }
        } catch (e) {
        }
        return false
    }

    function setReadStatus(id, status) {
        var note = this.notes.filter(function (note) {
            return note.id == id
        }).pop();
        if (!note) {
            return
        }
        status = "undefined" === typeof status ? true : !!status;
        note.read = status ? 1 : 0;
        try {
            localStorage.setItem("note_read_status_" + id, status ? "1" : "0")
        } catch (e) {
        }
        this.bucket.update(id.toString(), note)
    }

    function updateLastSeenTime(lastSeenTime) {
        updateLastSeenTime.lastSeenTime = updateLastSeenTime.lastSeenTime || 0;
        updateLastSeenTime.updateTimer = updateLastSeenTime.updateTimer || null;
        if (lastSeenTime > 11234736e5) {
            lastSeenTime = lastSeenTime / 1e3
        }
        if (lastSeenTime < updateLastSeenTime.lastSeenTime) {
            return
        }
        updateLastSeenTime.lastSeenTime = lastSeenTime;
        var _this = this;
        var _func = updateLastSeenTime;
        var updateLastSeenMeta = function () {
            _this.meta.update("meta", {last_seen: _func.lastSeenTime}, true);
            _func.updateTimer = null
        };
        var delay = 200;
        if (updateLastSeenTime.updateTimer) {
            return
        }
        updateLastSeenTime.updateTimer = window.setTimeout(updateLastSeenMeta, delay)
    }

    function preloadNoteAssets(note) {
        window.preloadedAssets.preloadImage(note.icon)
    }

    function handleIncomingMessage(message) {
        debug("incoming message: %s", message.action);
        switch (message.action) {
            case"togglePanel":
                if (!inIframe()) {
                    return
                }
                if (this.showing && !message.showing) {
                    this.showing = message.showing;
                    this.router("/", {resetView: true})
                }
                this.showing = message.showing;
                updateLastSeenTime.call(this, 0);
                break;
            case"refreshNotes":
                break
        }
    }

    function handleStorageEvent(event) {
        if ("note_read_status_" == event.key.substring(0, 17)) {
            this.emit("ready")
        }
    }

    Client.prototype.start = start;
    Client.prototype.setToken = setToken;
    Client.prototype.noteIsRead = noteIsRead;
    Client.prototype.setReadStatus = setReadStatus;
    Client.prototype.updateLastSeenTime = updateLastSeenTime;
    Client.prototype.handleIncomingMessage = handleIncomingMessage;
    Client.prototype.getNote = function () {
    };
    Client.prototype.getNotesList = function () {
    };
    Client.prototype.loadMore = function () {
    }
}, {debug: 48, events: 44, inherits: 52, simperium: 214}], 283: [function (require, module, exports) {
    var Suggestion = require("./suggestion");
    var debug = require("debug")("notifications:note");
    var stopEvent = function (event) {
        if (this.state.suggestionsVisible) {
            event.stopPropagation();
            event.preventDefault()
        }
    };
    var getSuggestionIndexBySelectedId = function () {
        if (!this.suggestions) {
            return null
        }
        if (!this.state.selectedSuggestionId) {
            return 0
        }
        for (var currentIndex = 0; currentIndex < this.suggestions.length; currentIndex++) {
            if (this.suggestions[currentIndex].ID === this.state.selectedSuggestionId) {
                return currentIndex
            }
        }
        return null
    };
    var getSuggestionById = function () {
        if (!this.suggestions) {
            return null
        }
        if (!this.state.selectedSuggestionId && this.suggestions.length > 0) {
            return this.suggestions[0]
        }
        for (var currentIndex = 0; currentIndex < this.suggestions.length; currentIndex++) {
            if (this.suggestions[currentIndex].ID === this.state.selectedSuggestionId) {
                return this.suggestions[currentIndex]
            }
        }
        return null
    };
    var getCaretPosition = function (element, position) {
        var mirror = document.createElement("div");
        mirror.id = "input-textarea-caret-position-mirror-div";
        document.body.appendChild(mirror);
        var style = mirror.style;
        var computedStyles = window.getComputedStyle ? getComputedStyle(element) : element.currentStyle;
        style.whiteSpace = "pre-wrap";
        if (element.nodeName !== "INPUT") {
            style.wordWrap = "break-word"
        }
        style.position = "absolute";
        style.visibility = "hidden";
        var properties = ["direction", "boxSizing", "width", "height", "overflowX", "overflowY", "borderTopWidth", "borderRightWidth", "borderBottomWidth", "borderLeftWidth", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "fontStyle", "fontVariant", "fontWeight", "fontStretch", "fontSize", "fontSizeAdjust", "lineHeight", "fontFamily", "textAlign", "textTransform", "textIndent", "textDecoration", "letterSpacing", "wordSpacing"];
        properties.forEach(function (prop) {
            style[prop] = computedStyles[prop]
        });
        mirror.textContent = element.value.substring(0, position);
        if (element.nodeName === "INPUT") {
            mirror.textContent = mirror.textContent.replace(/\s/g, "")
        }
        var span = document.createElement("span");
        span.textContent = element.value.substring(position) || ".";
        mirror.appendChild(span);
        var coordinates = {top: span.offsetTop + parseInt(computedStyles["borderTopWidth"]), left: span.offsetLeft + parseInt(computedStyles["borderLeftWidth"])};
        return coordinates
    };
    var SuggestionsMixin = {componentWillMount: function () {
        this.suggestions = [];
        this.suggestionsAbove = false
    }, componentWillUnmount: function () {
        window.removeEventListener("keydown", this.handleSuggestionsKeyDown);
        window.removeEventListener("keyup", this.handleSuggestionsKeyUp);
        window.removeEventListener("blur", this.handleSuggestionBlur)
    }, componentDidMount: function () {
        window.addEventListener("keydown", this.handleSuggestionsKeyDown, false);
        window.addEventListener("keyup", this.handleSuggestionsKeyUp, false);
        window.addEventListener("blur", this.handleSuggestionBlur, true)
    }, componentDidUpdate: function () {
        if (this.refs.suggestionList) {
            var suggestionList = this.refs.suggestionList.getDOMNode();
            if (!this.suggestionListMarginTop) {
                this.suggestionListMarginTop = window.getComputedStyle(suggestionList)["margin-top"]
            }
            var textArea = this.refs.replyTextArea.getDOMNode();
            var textAreaClientRect = textArea.getBoundingClientRect();
            if (this.suggestionsAbove) {
                suggestionList.style.top = "-" + (suggestionList.offsetHeight + textAreaClientRect.height + parseInt(this.suggestionListMarginTop)) + "px";
                suggestionList.style.marginTop = "0"
            } else {
                this.suggestionsAbove = suggestionList.offsetHeight > window.innerHeight - textAreaClientRect.top && suggestionList.offsetHeight < textAreaClientRect.top
            }
        }
    }, getCaretPosition: function (element) {
        return element.selectionStart
    }, setCaretPosition: function (element, position) {
        element.focus();
        setTimeout(function () {
            element.setSelectionRange(position, position)
        }.bind(this), 0)
    }, fetchSuggestions: function () {
        var siteId = this.props.note.meta.ids.site || null;
        var key = "suggestions-" + siteId;
        var client = this.props.global.client;
        if (!client.suggestions || !client.suggestions[key]) {
            client.getUsersSuggestions(siteId)
        }
    }, getQueryText: function (element) {
        if (!element.value) {
            return null
        }
        var textBeforeCaret = element.value.slice(0, this.getCaretPosition(element));
        var matcher = new RegExp("(?:^|\\s)@([A-Za-z0-9_+-]*)$|(?:^|\\s)@([^\\x00-\\xff]*)$", "gi");
        var match = matcher.exec(textBeforeCaret);
        if (match) {
            return match[2] || match[1]
        } else {
            return null
        }
    }, insertSuggestion: function (element, suggestion) {
        if (!suggestion) {
            return
        }
        var caretPosition = this.getCaretPosition(element);
        var startString = this.state.value.slice(0, Math.max(caretPosition - this.state.suggestionsQuery.length, 0));
        var endString = this.state.value.slice(caretPosition);
        this.setState({value: startString + suggestion.user_login + endString, suggestionsVisible: false});
        this.setCaretPosition(element, startString.length + suggestion.user_login.length)
    }, handleSuggestionsKeyDown: function (event) {
        if (!this.state.suggestionsVisible || this.suggestions.length === 0) {
            return
        }
        var newState = null;
        switch (event.keyCode) {
            case 13:
                stopEvent.call(this, event);
                break;
            case 38:
                stopEvent.call(this, event);
                var selectedIndex = getSuggestionIndexBySelectedId.call(this);
                if (selectedIndex !== null) {
                    var nextIndex = selectedIndex - 1;
                    if (nextIndex < 0) {
                        nextIndex = this.suggestions.length - 1
                    }
                    newState = {selectedSuggestionId: this.suggestions[nextIndex].ID}
                }
                break;
            case 40:
                stopEvent.call(this, event);
                var selectedIndex = getSuggestionIndexBySelectedId.call(this);
                if (selectedIndex !== null) {
                    var nextIndex = selectedIndex + 1;
                    if (nextIndex === this.suggestions.length) {
                        nextIndex = 0
                    }
                    newState = {selectedSuggestionId: this.suggestions[nextIndex].ID}
                }
                break
        }
        if (newState) {
            this.setState(newState);
            this.ensureSelectedSuggestionVisibility()
        }
    }, handleSuggestionsKeyUp: function (event) {
        var newState = null;
        switch (event.keyCode) {
            case 13:
                if (!this.state.suggestionsVisible || this.suggestions.length === 0) {
                    break
                }
                var suggestion = getSuggestionById.call(this);
                this.insertSuggestion(event.target, suggestion);
                break;
            case 27:
            case 32:
                newState = {suggestionsVisible: false};
                break;
            case 38:
            case 40:
                break;
            default:
                var query = this.getQueryText(event.target);
                if (query !== null) {
                    this.fetchSuggestions()
                }
                newState = {suggestionsQuery: query, suggestionsVisible: typeof query === "string", selectedSuggestionId: null};
                break
        }
        if (newState) {
            this.setState(newState)
        }
    }, handleSuggestionClick: function (suggestion) {
        this.insertSuggestion(this.refs.replyTextArea.getDOMNode(), suggestion)
    }, handleSuggestionBlur: function (event) {
        if (!this.suggestionsCancelBlur && this.isMounted()) {
            this.setState({suggestionsVisible: false})
        }
    }, ensureSelectedSuggestionVisibility: function () {
        var getOffsetTop = function (element) {
            var offset = element.offsetTop;
            if (element.offsetParent) {
                offset += getOffsetTop(element.offsetParent)
            }
            return offset
        };
        var suggestionElement = this.refs["suggestion-node-" + this.state.selectedSuggestionId].getDOMNode();
        var offsetTop = getOffsetTop(suggestionElement);
        var scrollTarget = null;
        if (offsetTop - window.pageYOffset <= 0) {
            scrollTarget = offsetTop
        } else if (window.pageYOffset + window.innerHeight <= offsetTop) {
            scrollTarget = offsetTop + suggestionElement.offsetHeight
        }
        if (scrollTarget !== null) {
            window.scrollTo(0, scrollTarget)
        }
    }, renderSuggestions: function () {
        if (!this.state.suggestionsVisible) {
            return
        }
        var siteId = this.props.note.meta.ids.site || null;
        var key = "suggestions-" + siteId;
        var client = this.props.global.client;
        if (client.suggestions && client.suggestions[key]) {
            this.suggestions = client.suggestions[key]
        }
        var matcher = new RegExp("^" + this.state.suggestionsQuery + "| " + this.state.suggestionsQuery, "ig");
        var suggestions = this.suggestions;
        if (this.state.suggestionsQuery.length > 0) {
            suggestions = [];
            for (var i = 0, len = this.suggestions.length; i < len; i++) {
                var item = this.suggestions[i];
                if (item["name"].toLowerCase().match(matcher)) {
                    suggestions.push(item)
                }
            }
        }
        this.suggestions = suggestions.slice(0, 10);
        if (this.suggestions.length > 0) {
            var selectedSuggestionId = this.state.selectedSuggestionId || this.suggestions[0].ID;
            var items = this.suggestions.map(function (suggestion) {
                return React.createElement(Suggestion, {ref: "suggestion-node-" + suggestion.ID, key: "user-suggestion-" + suggestion.ID, onClick: this.handleSuggestionClick.bind(this, suggestion), onMouseEnter: function (suggestion) {
                    this.setState({selectedSuggestionId: suggestion.ID})
                }.bind(this, suggestion), avatarUrl: suggestion.image_URL, username: suggestion.user_login, fullName: suggestion.display_name, selected: suggestion.ID === selectedSuggestionId, suggestionsQuery: this.state.suggestionsQuery})
            }.bind(this));
            return React.createElement("div", {ref: "suggestionList", className: "suggestions", onMouseEnter: function () {
                this.suggestionsCancelBlur = true
            }.bind(this), onMouseLeave: function () {
                this.suggestionsCancelBlur = false
            }.bind(this)}, React.createElement("ul", null, items))
        }
        return null
    }};
    module.exports = SuggestionsMixin
}, {"./suggestion": 8, debug: 48}], 284: [function (require, module, exports) {
    var BackButton = require("./button-back");
    var NoteList = require("./note-list");
    var AppError = require("./error");
    var i18n = require("i18n");
    var throttle = require("per-frame");
    var debug = require("debug")("notifications:layout");
    var NavButton = React.createClass({displayName: "NavButton", navigateHandler: function (event) {
        this.props.navigate();
        event.stopPropagation();
        event.preventDefault()
    }, render: function () {
        if (this.props.enabled) {
            return React.createElement("a", {className: this.props.className, onClick: this.navigateHandler, href: "#"})
        } else {
            return React.createElement("a", {className: this.props.className + " disabled", disabled: "disabled", href: "#"})
        }
    }});
    module.exports = React.createClass({displayName: "exports", getInitialState: function () {
        return{navigationEnabled: true, title: "", error: false, global: Object.create(null), updateSignal: false}
    }, componentWillMount: function () {
        this.state.global.client = this.props.client;
        this.state.global.toggleNavigation = this.toggleNavigation;
        this.state.global.navigation = Object.create(null);
        this.state.global.navigation.selectedNote = null;
        this.state.global.navigation.lastSelectedIndex = 0;
        this.state.global.keyboardShortcutsAreEnabled = true;
        this.state.global.toggleKeyboardShortcuts = this.toggleKeyboardShortcuts;
        this.state.global.input = {modifierKeyIsActive: this.modifierKeyIsActive, lastInputWasKeyboard: false};
        window.addEventListener("keydown", this.handleKeyDown, false)
    }, componentDidMount: function () {
        window.addEventListener("resize", this.redraw)
    }, componentDidUpdate: function (prevProps, prevState) {
        if (this.props.current) {
            this.state.global.navigation.selectedNote = this.props.current
        }
    }, navigateByDirection: function (direction) {
        var navigation = this.state.global.navigation;
        if (!this.state.global.keyboardShortcutsAreEnabled) {
            return
        }
        if (this.props.notes.length < 1) {
            navigation.selectedNote = null;
            return
        }
        if (null === navigation.selectedNote) {
            navigation.selectedNote = this.props.notes[0].id;
            this.refs["note-list-div"].ensureSelectedNoteVisibility();
            this.triggerClientUpdate();
            return
        }
        var stepAtom = direction > 0 ? 1 : -1;
        var hiddenNotes = this.state.global.hiddenNotes || [];
        var notes = this.props.notes || [];
        var noteIndexIsSelectable = function (index) {
            if ("undefined" === typeof notes[index]) {
                return false
            }
            if (hiddenNotes.indexOf(notes[index].id) > -1) {
                return false
            }
            return true
        };
        var currentIndex = 0;
        for (currentIndex = 0; currentIndex < notes.length; currentIndex++) {
            if (notes[currentIndex].id == navigation.selectedNote) {
                break
            }
        }
        if (notes.length == currentIndex) {
            var step = 0;
            for (var i = navigation.lastSelectedIndex; 0 <= i && i < notes.length; i = currentIndex + step) {
                if (noteIndexIsSelectable(i)) {
                    currentIndex = i;
                    break
                } else {
                    step = -step + (step > 0)
                }
            }
        }
        if (currentIndex + stepAtom < 0 || currentIndex + stepAtom >= notes.length) {
            return
        }
        var newIndex = 0;
        for (newIndex = currentIndex + stepAtom; newIndex >= 0 && newIndex < notes.length; newIndex += stepAtom) {
            if (noteIndexIsSelectable(newIndex)) {
                break
            }
        }
        if (!noteIndexIsSelectable(newIndex)) {
            for (newIndex = currentIndex - stepAtom; newIndex >= 0 && newIndex < notes.length; newIndex -= stepAtom) {
                if (noteIndexIsSelectable(newIndex)) {
                    break
                }
            }
        }
        if (!noteIndexIsSelectable(newIndex)) {
            return
        }
        navigation.selectedNote = this.props.notes[newIndex].id;
        navigation.lastSelectedIndex = newIndex;
        if (this.props.current) {
            this.props.router("/" + navigation.selectedNote)
        }
        this.refs["note-list-div"].ensureSelectedNoteVisibility();
        this.triggerClientUpdate()
    }, navigateToNextNote: function () {
        this.navigateByDirection(1)
    }, componentWillUnmount: function () {
        window.removeEventListener("resize", this.redraw)
    }, navigateToPrevNote: function () {
        this.navigateByDirection(-1)
    }, toggleNavigation: function (doEnable) {
        var isEnabled = this.state.navigationEnabled;
        if ("boolean" === typeof doEnable) {
            isEnabled = doEnable
        }
        this.setState({navigationEnabled: isEnabled})
    }, toggleKeyboardShortcuts: function (doEnable) {
        var isEnabled = this.state.global.keyboardShortcutsAreEnabled;
        if ("boolean" === typeof doEnable) {
            isEnabled = doEnable
        }
        this.state.global.keyboardShortcutsAreEnabled = isEnabled
    }, redraw: throttle(function () {
        this.forceUpdate()
    }), triggerClientUpdate: function () {
        this.setState({updateSignal: !this.state.updateSignal})
    }, resetViewComplete: function () {
        this.state.global.navigation.selectedNote = null;
        this.state.global.navigation.lastSelectedIndex = 0;
        this.setState({resetView: false})
    }, modifierKeyIsActive: function (e) {
        return e.altKey || e.ctrlKey || e.metaKey
    }, handleKeyDown: function (event) {
        var stopEvent = function () {
            event.stopPropagation();
            event.preventDefault()
        };
        if (!this.props.client.showing) {
            return
        }
        if (27 == event.keyCode) {
            this.props.client.sendMessage({action: "togglePanel"});
            stopEvent();
            return
        }
        if (!this.state.global.keyboardShortcutsAreEnabled) {
            return
        }
        if (this.state.global.input.modifierKeyIsActive(event)) {
            return
        }
        var activateKeyboard = function () {
            this.state.global.input.lastInputWasKeyboard = true
        }.bind(this);
        switch (event.keyCode) {
            case 27:
            case 78:
                this.props.client.sendMessage({action: "togglePanel"});
                stopEvent();
                break;
            case 37:
            case 72:
                activateKeyboard();
                this.props.router("/");
                break;
            case 13:
            case 39:
            case 76:
                if (!this.props.current && null !== this.state.global.navigation.selectedNote) {
                    activateKeyboard();
                    this.props.router("/" + this.state.global.navigation.selectedNote)
                }
                break;
            case 40:
            case 74:
                activateKeyboard();
                this.navigateToNextNote();
                stopEvent();
                break;
            case 38:
            case 75:
                activateKeyboard();
                this.navigateToPrevNote();
                stopEvent();
                break
        }
    }, render: function () {
        var currentNote = this.props.notes.filter(function (note) {
            return note.id == this.props.current
        }, this).pop();
        var title = currentNote && currentNote.title ? currentNote.title : this.props.title;
        var className, back, content, navPrev, navNext;
        if (this.props.error) {
            className = "error-view"
        } else if (this.props.current) {
            className = "single-view"
        } else {
            className = "list-view";
            back = "";
            navPrev = "";
            navNext = ""
        }
        if (this.props.error || this.props.current) {
            back = React.createElement(BackButton, {enabled: this.state.navigationEnabled, client: this.props.client, global: this.state.global});
            navPrev = React.createElement(NavButton, {className: "prev", navigate: this.navigateToPrevNote, enabled: this.props.notes[0] && this.props.notes[0].id != this.props.current});
            navNext = React.createElement(NavButton, {className: "next", navigate: this.navigateToNextNote, enabled: this.props.notes[0] && this.props.notes[this.props.notes.length - 1].id != this.props.current})
        }
        if (this.props.error) {
            content = React.createElement(AppError, {error: this.props.error})
        } else {
            content = React.createElement(NoteList, {ref: "note-list-div", global: this.state.global, notes: this.props.notes, current: this.props.current, router: this.props.router, client: this.props.client, headerHeight: this.state.headerHeight, resetView: this.state.resetView, resetViewComplete: this.resetViewComplete})
        }
        var divStyle = {width: document.body.clientWidth};
        return React.createElement("div", {style: divStyle, className: className}, React.createElement("header", {ref: "header"}, React.createElement("h1", null, title), React.createElement("nav", null, back, React.createElement("div", null, navPrev, navNext))), content)
    }})
}, {"./button-back": 15, "./error": 21, "./note-list": 25, debug: 48, i18n: 6, "per-frame": 57}], 285: [function (require, module, exports) {
    var events = require("events");
    var inherits = require("inherits");
    var wp = require("wp");
    var debug = require("debug")("notifications:test-client");
    var data = require("./data");
    module.exports = Client;
    function Client() {
        events.EventEmitter.call(this);
        debug("loading %d test notes", data.notes.length);
        this.notes = data.notes;
        this.is_ready = true;
        this.emit("ready")
    }

    inherits(Client, events.EventEmitter);
    function start() {
        if (this.is_ready) {
            this.emit("ready")
        }
    }

    function setReadStatus(id, status) {
        var note = this.notes.filter(function (note) {
            return note.id == id
        }).pop();
        if (!note) {
            return
        }
        status = "undefined" === typeof status ? true : !!status;
        note.read = status ? 1 : 0
    }

    function updateLastSeenTime(lastSeenTime) {
    }

    Client.prototype.start = start;
    Client.prototype.setReadStatus = setReadStatus;
    Client.prototype.updateLastSeenTime = updateLastSeenTime
}, {"./data": 32, debug: 48, events: 44, inherits: 52, wp: 34}]}, {}, [1]);
//# sourceMappingURL=build.min.js.map?d23c761ae9c994ec1b9c88651ba411ce